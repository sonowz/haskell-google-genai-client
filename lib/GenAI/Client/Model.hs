{-
   Generative Language API

   The Gemini API allows developers to build generative AI applications using Gemini models. Gemini is our most capable model, built from the ground up to be multimodal. It can generalize and seamlessly understand, operate across, and combine different types of information including language, images, audio, video, and code. You can use the Gemini API for use cases like reasoning across text and images, content generation, dialogue agents, summarization and classification systems, and more.

   OpenAPI Version: 3.0.3
   Generative Language API API version: v1beta
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

{- |
Module : GenAI.Client.Model
-}
module GenAI.Client.Model where

import GenAI.Client.Core
import GenAI.Client.MimeTypes

import Data.Aeson ((.:), (.:!), (.:?), (.=))

import Control.Arrow qualified as P (left)
import Data.Aeson qualified as A
import Data.ByteString qualified as B
import Data.ByteString.Base64 qualified as B64
import Data.ByteString.Char8 qualified as BC
import Data.ByteString.Lazy qualified as BL
import Data.Data qualified as P (TypeRep, Typeable, typeOf, typeRep)
import Data.Foldable qualified as P
import Data.HashMap.Lazy qualified as HM
import Data.Map qualified as Map
import Data.Maybe qualified as P
import Data.Set qualified as Set
import Data.Text qualified as T
import Data.Text.Encoding qualified as T
import Data.Time qualified as TI
import Lens.Micro qualified as L
import Web.FormUrlEncoded qualified as WH
import Web.HttpApiData qualified as WH

import Control.Applicative (Alternative, (<|>))
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (Applicative, Bool (..), Char, Double, FilePath, Float, Functor, Int, Integer, Maybe (..), Monad, String, fmap, maybe, mempty, pure, undefined, ($), (.), (/=), (<$>), (<*>), (=<<), (>>=))

import Prelude qualified as P

-- * Parameter newtypes

-- ** Alt
newtype Alt = Alt {unAlt :: E'Alt} deriving (P.Eq, P.Show)

-- ** Callback
newtype Callback = Callback {unCallback :: Text} deriving (P.Eq, P.Show)

-- ** Chunk2
newtype Chunk2 = Chunk2 {unChunk2 :: Text} deriving (P.Eq, P.Show)

-- ** Corpus2
newtype Corpus2 = Corpus2 {unCorpus2 :: Text} deriving (P.Eq, P.Show)

-- ** Document2
newtype Document2 = Document2 {unDocument2 :: Text} deriving (P.Eq, P.Show)

-- ** DynamicId
newtype DynamicId = DynamicId {unDynamicId :: Text} deriving (P.Eq, P.Show)

-- ** File2
newtype File2 = File2 {unFile2 :: Text} deriving (P.Eq, P.Show)

-- ** Filter
newtype Filter = Filter {unFilter :: Text} deriving (P.Eq, P.Show)

-- ** Force
newtype Force = Force {unForce :: Bool} deriving (P.Eq, P.Show)

-- ** GenerateContentBatch
newtype GenerateContentBatch = GenerateContentBatch {unGenerateContentBatch :: Text} deriving (P.Eq, P.Show)

-- ** GeneratedFile2
newtype GeneratedFile2 = GeneratedFile2 {unGeneratedFile2 :: Text} deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id {unId :: Text} deriving (P.Eq, P.Show)

-- ** Model2
newtype Model2 = Model2 {unModel2 :: Text} deriving (P.Eq, P.Show)

-- ** Operation2
newtype Operation2 = Operation2 {unOperation2 :: Text} deriving (P.Eq, P.Show)

-- ** PageSize
newtype PageSize = PageSize {unPageSize :: Int} deriving (P.Eq, P.Show)

-- ** PageToken
newtype PageToken = PageToken {unPageToken :: Text} deriving (P.Eq, P.Show)

-- ** Permission2
newtype Permission2 = Permission2 {unPermission2 :: Text} deriving (P.Eq, P.Show)

-- ** PrettyPrint
newtype PrettyPrint = PrettyPrint {unPrettyPrint :: Bool} deriving (P.Eq, P.Show)

-- ** TunedModel2
newtype TunedModel2 = TunedModel2 {unTunedModel2 :: Text} deriving (P.Eq, P.Show)

-- ** TunedModelId
newtype TunedModelId = TunedModelId {unTunedModelId :: Text} deriving (P.Eq, P.Show)

-- ** UpdateMask
newtype UpdateMask = UpdateMask {unUpdateMask :: Text} deriving (P.Eq, P.Show)

-- ** Xgafv
newtype Xgafv = Xgafv {unXgafv :: E'Xgafv} deriving (P.Eq, P.Show)

-- * Models

-- ** AttributionSourceId

{- | AttributionSourceId
Identifier for the source contributing to this attribution.
-}
data AttributionSourceId = AttributionSourceId
  { attributionSourceIdGroundingPassage :: !(Maybe GroundingPassageId)
  -- ^ "groundingPassage" - Identifier for an inline passage.
  , attributionSourceIdSemanticRetrieverChunk :: !(Maybe SemanticRetrieverChunk)
  -- ^ "semanticRetrieverChunk" - Identifier for a &#x60;Chunk&#x60; fetched via Semantic Retriever.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AttributionSourceId
instance A.FromJSON AttributionSourceId where
  parseJSON = A.withObject "AttributionSourceId" $ \o ->
    AttributionSourceId
      <$> (o .:? "groundingPassage")
      <*> (o .:? "semanticRetrieverChunk")

-- | ToJSON AttributionSourceId
instance A.ToJSON AttributionSourceId where
  toJSON AttributionSourceId {..} =
    _omitNulls
      [ "groundingPassage" .= attributionSourceIdGroundingPassage
      , "semanticRetrieverChunk" .= attributionSourceIdSemanticRetrieverChunk
      ]

-- | Construct a value of type 'AttributionSourceId' (by applying it's required fields, if any)
mkAttributionSourceId ::
  AttributionSourceId
mkAttributionSourceId =
  AttributionSourceId
    { attributionSourceIdGroundingPassage = Nothing
    , attributionSourceIdSemanticRetrieverChunk = Nothing
    }

-- ** BaseOperation

{- | BaseOperation
This resource represents a long-running operation that is the result of a network API call.
-}
data BaseOperation = BaseOperation
  { baseOperationDone :: !(Maybe Bool)
  -- ^ "done" - If the value is &#x60;false&#x60;, it means the operation is still in progress. If &#x60;true&#x60;, the operation is completed, and either &#x60;error&#x60; or &#x60;response&#x60; is available.
  , baseOperationName :: !(Maybe Text)
  -- ^ "name" - The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the &#x60;name&#x60; should be a resource name ending with &#x60;operations/{unique_id}&#x60;.
  , baseOperationError :: !(Maybe Status)
  -- ^ "error" - The error result of the operation in case of failure or cancellation.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BaseOperation
instance A.FromJSON BaseOperation where
  parseJSON = A.withObject "BaseOperation" $ \o ->
    BaseOperation
      <$> (o .:? "done")
      <*> (o .:? "name")
      <*> (o .:? "error")

-- | ToJSON BaseOperation
instance A.ToJSON BaseOperation where
  toJSON BaseOperation {..} =
    _omitNulls
      [ "done" .= baseOperationDone
      , "name" .= baseOperationName
      , "error" .= baseOperationError
      ]

-- | Construct a value of type 'BaseOperation' (by applying it's required fields, if any)
mkBaseOperation ::
  BaseOperation
mkBaseOperation =
  BaseOperation
    { baseOperationDone = Nothing
    , baseOperationName = Nothing
    , baseOperationError = Nothing
    }

-- ** BatchCreateChunksRequest

{- | BatchCreateChunksRequest
Request to batch create `Chunk`s.
-}
data BatchCreateChunksRequest = BatchCreateChunksRequest
  { batchCreateChunksRequestRequests :: !([CreateChunkRequest])
  -- ^ /Required/ "requests" - Required. The request messages specifying the &#x60;Chunk&#x60;s to create. A maximum of 100 &#x60;Chunk&#x60;s can be created in a batch.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchCreateChunksRequest
instance A.FromJSON BatchCreateChunksRequest where
  parseJSON = A.withObject "BatchCreateChunksRequest" $ \o ->
    BatchCreateChunksRequest
      <$> (o .: "requests")

-- | ToJSON BatchCreateChunksRequest
instance A.ToJSON BatchCreateChunksRequest where
  toJSON BatchCreateChunksRequest {..} =
    _omitNulls
      [ "requests" .= batchCreateChunksRequestRequests
      ]

-- | Construct a value of type 'BatchCreateChunksRequest' (by applying it's required fields, if any)
mkBatchCreateChunksRequest ::
  -- | 'batchCreateChunksRequestRequests': Required. The request messages specifying the `Chunk`s to create. A maximum of 100 `Chunk`s can be created in a batch.
  [CreateChunkRequest] ->
  BatchCreateChunksRequest
mkBatchCreateChunksRequest batchCreateChunksRequestRequests =
  BatchCreateChunksRequest
    { batchCreateChunksRequestRequests
    }

-- ** BatchCreateChunksResponse

{- | BatchCreateChunksResponse
Response from `BatchCreateChunks` containing a list of created `Chunk`s.
-}
data BatchCreateChunksResponse = BatchCreateChunksResponse
  { batchCreateChunksResponseChunks :: !(Maybe [Chunk])
  -- ^ "chunks" - &#x60;Chunk&#x60;s created.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchCreateChunksResponse
instance A.FromJSON BatchCreateChunksResponse where
  parseJSON = A.withObject "BatchCreateChunksResponse" $ \o ->
    BatchCreateChunksResponse
      <$> (o .:? "chunks")

-- | ToJSON BatchCreateChunksResponse
instance A.ToJSON BatchCreateChunksResponse where
  toJSON BatchCreateChunksResponse {..} =
    _omitNulls
      [ "chunks" .= batchCreateChunksResponseChunks
      ]

-- | Construct a value of type 'BatchCreateChunksResponse' (by applying it's required fields, if any)
mkBatchCreateChunksResponse ::
  BatchCreateChunksResponse
mkBatchCreateChunksResponse =
  BatchCreateChunksResponse
    { batchCreateChunksResponseChunks = Nothing
    }

-- ** BatchDeleteChunksRequest

{- | BatchDeleteChunksRequest
Request to batch delete `Chunk`s.
-}
data BatchDeleteChunksRequest = BatchDeleteChunksRequest
  { batchDeleteChunksRequestRequests :: !([DeleteChunkRequest])
  -- ^ /Required/ "requests" - Required. The request messages specifying the &#x60;Chunk&#x60;s to delete.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchDeleteChunksRequest
instance A.FromJSON BatchDeleteChunksRequest where
  parseJSON = A.withObject "BatchDeleteChunksRequest" $ \o ->
    BatchDeleteChunksRequest
      <$> (o .: "requests")

-- | ToJSON BatchDeleteChunksRequest
instance A.ToJSON BatchDeleteChunksRequest where
  toJSON BatchDeleteChunksRequest {..} =
    _omitNulls
      [ "requests" .= batchDeleteChunksRequestRequests
      ]

-- | Construct a value of type 'BatchDeleteChunksRequest' (by applying it's required fields, if any)
mkBatchDeleteChunksRequest ::
  -- | 'batchDeleteChunksRequestRequests': Required. The request messages specifying the `Chunk`s to delete.
  [DeleteChunkRequest] ->
  BatchDeleteChunksRequest
mkBatchDeleteChunksRequest batchDeleteChunksRequestRequests =
  BatchDeleteChunksRequest
    { batchDeleteChunksRequestRequests
    }

-- ** BatchEmbedContentsRequest

{- | BatchEmbedContentsRequest
Batch request to get embeddings from the model for a list of prompts.
-}
data BatchEmbedContentsRequest = BatchEmbedContentsRequest
  { batchEmbedContentsRequestRequests :: !([EmbedContentRequest])
  -- ^ /Required/ "requests" - Required. Embed requests for the batch. The model in each of these requests must match the model specified &#x60;BatchEmbedContentsRequest.model&#x60;.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchEmbedContentsRequest
instance A.FromJSON BatchEmbedContentsRequest where
  parseJSON = A.withObject "BatchEmbedContentsRequest" $ \o ->
    BatchEmbedContentsRequest
      <$> (o .: "requests")

-- | ToJSON BatchEmbedContentsRequest
instance A.ToJSON BatchEmbedContentsRequest where
  toJSON BatchEmbedContentsRequest {..} =
    _omitNulls
      [ "requests" .= batchEmbedContentsRequestRequests
      ]

-- | Construct a value of type 'BatchEmbedContentsRequest' (by applying it's required fields, if any)
mkBatchEmbedContentsRequest ::
  -- | 'batchEmbedContentsRequestRequests': Required. Embed requests for the batch. The model in each of these requests must match the model specified `BatchEmbedContentsRequest.model`.
  [EmbedContentRequest] ->
  BatchEmbedContentsRequest
mkBatchEmbedContentsRequest batchEmbedContentsRequestRequests =
  BatchEmbedContentsRequest
    { batchEmbedContentsRequestRequests
    }

-- ** BatchEmbedContentsResponse

{- | BatchEmbedContentsResponse
The response to a `BatchEmbedContentsRequest`.
-}
data BatchEmbedContentsResponse = BatchEmbedContentsResponse
  { batchEmbedContentsResponseEmbeddings :: !(Maybe [ContentEmbedding])
  -- ^ /ReadOnly/ "embeddings" - Output only. The embeddings for each request, in the same order as provided in the batch request.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchEmbedContentsResponse
instance A.FromJSON BatchEmbedContentsResponse where
  parseJSON = A.withObject "BatchEmbedContentsResponse" $ \o ->
    BatchEmbedContentsResponse
      <$> (o .:? "embeddings")

-- | ToJSON BatchEmbedContentsResponse
instance A.ToJSON BatchEmbedContentsResponse where
  toJSON BatchEmbedContentsResponse {..} =
    _omitNulls
      [ "embeddings" .= batchEmbedContentsResponseEmbeddings
      ]

-- | Construct a value of type 'BatchEmbedContentsResponse' (by applying it's required fields, if any)
mkBatchEmbedContentsResponse ::
  BatchEmbedContentsResponse
mkBatchEmbedContentsResponse =
  BatchEmbedContentsResponse
    { batchEmbedContentsResponseEmbeddings = Nothing
    }

-- ** BatchEmbedTextRequest

{- | BatchEmbedTextRequest
Batch request to get a text embedding from the model.
-}
data BatchEmbedTextRequest = BatchEmbedTextRequest
  { batchEmbedTextRequestRequests :: !(Maybe [EmbedTextRequest])
  -- ^ "requests" - Optional. Embed requests for the batch. Only one of &#x60;texts&#x60; or &#x60;requests&#x60; can be set.
  , batchEmbedTextRequestTexts :: !(Maybe [Text])
  -- ^ "texts" - Optional. The free-form input texts that the model will turn into an embedding. The current limit is 100 texts, over which an error will be thrown.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchEmbedTextRequest
instance A.FromJSON BatchEmbedTextRequest where
  parseJSON = A.withObject "BatchEmbedTextRequest" $ \o ->
    BatchEmbedTextRequest
      <$> (o .:? "requests")
      <*> (o .:? "texts")

-- | ToJSON BatchEmbedTextRequest
instance A.ToJSON BatchEmbedTextRequest where
  toJSON BatchEmbedTextRequest {..} =
    _omitNulls
      [ "requests" .= batchEmbedTextRequestRequests
      , "texts" .= batchEmbedTextRequestTexts
      ]

-- | Construct a value of type 'BatchEmbedTextRequest' (by applying it's required fields, if any)
mkBatchEmbedTextRequest ::
  BatchEmbedTextRequest
mkBatchEmbedTextRequest =
  BatchEmbedTextRequest
    { batchEmbedTextRequestRequests = Nothing
    , batchEmbedTextRequestTexts = Nothing
    }

-- ** BatchEmbedTextResponse

{- | BatchEmbedTextResponse
The response to a EmbedTextRequest.
-}
data BatchEmbedTextResponse = BatchEmbedTextResponse
  { batchEmbedTextResponseEmbeddings :: !(Maybe [Embedding])
  -- ^ /ReadOnly/ "embeddings" - Output only. The embeddings generated from the input text.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchEmbedTextResponse
instance A.FromJSON BatchEmbedTextResponse where
  parseJSON = A.withObject "BatchEmbedTextResponse" $ \o ->
    BatchEmbedTextResponse
      <$> (o .:? "embeddings")

-- | ToJSON BatchEmbedTextResponse
instance A.ToJSON BatchEmbedTextResponse where
  toJSON BatchEmbedTextResponse {..} =
    _omitNulls
      [ "embeddings" .= batchEmbedTextResponseEmbeddings
      ]

-- | Construct a value of type 'BatchEmbedTextResponse' (by applying it's required fields, if any)
mkBatchEmbedTextResponse ::
  BatchEmbedTextResponse
mkBatchEmbedTextResponse =
  BatchEmbedTextResponse
    { batchEmbedTextResponseEmbeddings = Nothing
    }

-- ** BatchUpdateChunksRequest

{- | BatchUpdateChunksRequest
Request to batch update `Chunk`s.
-}
data BatchUpdateChunksRequest = BatchUpdateChunksRequest
  { batchUpdateChunksRequestRequests :: !([UpdateChunkRequest])
  -- ^ /Required/ "requests" - Required. The request messages specifying the &#x60;Chunk&#x60;s to update. A maximum of 100 &#x60;Chunk&#x60;s can be updated in a batch.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchUpdateChunksRequest
instance A.FromJSON BatchUpdateChunksRequest where
  parseJSON = A.withObject "BatchUpdateChunksRequest" $ \o ->
    BatchUpdateChunksRequest
      <$> (o .: "requests")

-- | ToJSON BatchUpdateChunksRequest
instance A.ToJSON BatchUpdateChunksRequest where
  toJSON BatchUpdateChunksRequest {..} =
    _omitNulls
      [ "requests" .= batchUpdateChunksRequestRequests
      ]

-- | Construct a value of type 'BatchUpdateChunksRequest' (by applying it's required fields, if any)
mkBatchUpdateChunksRequest ::
  -- | 'batchUpdateChunksRequestRequests': Required. The request messages specifying the `Chunk`s to update. A maximum of 100 `Chunk`s can be updated in a batch.
  [UpdateChunkRequest] ->
  BatchUpdateChunksRequest
mkBatchUpdateChunksRequest batchUpdateChunksRequestRequests =
  BatchUpdateChunksRequest
    { batchUpdateChunksRequestRequests
    }

-- ** BatchUpdateChunksResponse

{- | BatchUpdateChunksResponse
Response from `BatchUpdateChunks` containing a list of updated `Chunk`s.
-}
data BatchUpdateChunksResponse = BatchUpdateChunksResponse
  { batchUpdateChunksResponseChunks :: !(Maybe [Chunk])
  -- ^ "chunks" - &#x60;Chunk&#x60;s updated.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchUpdateChunksResponse
instance A.FromJSON BatchUpdateChunksResponse where
  parseJSON = A.withObject "BatchUpdateChunksResponse" $ \o ->
    BatchUpdateChunksResponse
      <$> (o .:? "chunks")

-- | ToJSON BatchUpdateChunksResponse
instance A.ToJSON BatchUpdateChunksResponse where
  toJSON BatchUpdateChunksResponse {..} =
    _omitNulls
      [ "chunks" .= batchUpdateChunksResponseChunks
      ]

-- | Construct a value of type 'BatchUpdateChunksResponse' (by applying it's required fields, if any)
mkBatchUpdateChunksResponse ::
  BatchUpdateChunksResponse
mkBatchUpdateChunksResponse =
  BatchUpdateChunksResponse
    { batchUpdateChunksResponseChunks = Nothing
    }

-- ** Blob

{- | Blob
Raw media bytes.  Text should not be sent as raw bytes, use the 'text' field.
-}
data Blob = Blob
  { blobData :: !(Maybe ByteArray)
  -- ^ "data" - Raw bytes for media formats.
  , blobMimeType :: !(Maybe Text)
  -- ^ "mimeType" - The IANA standard MIME type of the source data. Examples:   - image/png   - image/jpeg If an unsupported MIME type is provided, an error will be returned. For a complete list of supported types, see [Supported file formats](https://ai.google.dev/gemini-api/docs/prompting_with_media#supported_file_formats).
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Blob
instance A.FromJSON Blob where
  parseJSON = A.withObject "Blob" $ \o ->
    Blob
      <$> (o .:? "data")
      <*> (o .:? "mimeType")

-- | ToJSON Blob
instance A.ToJSON Blob where
  toJSON Blob {..} =
    _omitNulls
      [ "data" .= blobData
      , "mimeType" .= blobMimeType
      ]

-- | Construct a value of type 'Blob' (by applying it's required fields, if any)
mkBlob ::
  Blob
mkBlob =
  Blob
    { blobData = Nothing
    , blobMimeType = Nothing
    }

-- ** CachedContent

{- | CachedContent
Content that has been preprocessed and can be used in subsequent request to GenerativeService.  Cached content can be only used with model it was created for.
-}
data CachedContent = CachedContent
  { cachedContentTools :: !(Maybe [Tool])
  -- ^ "tools" - Optional. Input only. Immutable. A list of &#x60;Tools&#x60; the model may use to generate the next response
  , cachedContentDisplayName :: !(Maybe Text)
  -- ^ "displayName" - Optional. Immutable. The user-generated meaningful display name of the cached content. Maximum 128 Unicode characters.
  , cachedContentModel :: !(Text)
  -- ^ /Required/ "model" - Required. Immutable. The name of the &#x60;Model&#x60; to use for cached content Format: &#x60;models/{model}&#x60;
  , cachedContentExpireTime :: !(Maybe DateTime)
  -- ^ "expireTime" - Timestamp in UTC of when this resource is considered expired. This is *always* provided on output, regardless of what was sent on input.
  , cachedContentUsageMetadata :: !(Maybe CachedContentUsageMetadata)
  -- ^ /ReadOnly/ "usageMetadata" - Output only. Metadata on the usage of the cached content.
  , cachedContentName :: !(Maybe Text)
  -- ^ /ReadOnly/ "name" - Output only. Identifier. The resource name referring to the cached content. Format: &#x60;cachedContents/{id}&#x60;
  , cachedContentContents :: !(Maybe [Content])
  -- ^ "contents" - Optional. Input only. Immutable. The content to cache.
  , cachedContentSystemInstruction :: !(Maybe Content)
  -- ^ "systemInstruction" - Optional. Input only. Immutable. Developer set system instruction. Currently text only.
  , cachedContentToolConfig :: !(Maybe ToolConfig)
  -- ^ "toolConfig" - Optional. Input only. Immutable. Tool config. This config is shared for all tools.
  , cachedContentCreateTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "createTime" - Output only. Creation time of the cache entry.
  , cachedContentTtl :: !(Maybe Text)
  -- ^ "ttl" - Input only. New TTL for this resource, input only.
  , cachedContentUpdateTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "updateTime" - Output only. When the cache entry was last updated in UTC time.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CachedContent
instance A.FromJSON CachedContent where
  parseJSON = A.withObject "CachedContent" $ \o ->
    CachedContent
      <$> (o .:? "tools")
      <*> (o .:? "displayName")
      <*> (o .: "model")
      <*> (o .:? "expireTime")
      <*> (o .:? "usageMetadata")
      <*> (o .:? "name")
      <*> (o .:? "contents")
      <*> (o .:? "systemInstruction")
      <*> (o .:? "toolConfig")
      <*> (o .:? "createTime")
      <*> (o .:? "ttl")
      <*> (o .:? "updateTime")

-- | ToJSON CachedContent
instance A.ToJSON CachedContent where
  toJSON CachedContent {..} =
    _omitNulls
      [ "tools" .= cachedContentTools
      , "displayName" .= cachedContentDisplayName
      , "model" .= cachedContentModel
      , "expireTime" .= cachedContentExpireTime
      , "usageMetadata" .= cachedContentUsageMetadata
      , "name" .= cachedContentName
      , "contents" .= cachedContentContents
      , "systemInstruction" .= cachedContentSystemInstruction
      , "toolConfig" .= cachedContentToolConfig
      , "createTime" .= cachedContentCreateTime
      , "ttl" .= cachedContentTtl
      , "updateTime" .= cachedContentUpdateTime
      ]

-- | Construct a value of type 'CachedContent' (by applying it's required fields, if any)
mkCachedContent ::
  -- | 'cachedContentModel': Required. Immutable. The name of the `Model` to use for cached content Format: `models/{model}`
  Text ->
  CachedContent
mkCachedContent cachedContentModel =
  CachedContent
    { cachedContentTools = Nothing
    , cachedContentDisplayName = Nothing
    , cachedContentModel
    , cachedContentExpireTime = Nothing
    , cachedContentUsageMetadata = Nothing
    , cachedContentName = Nothing
    , cachedContentContents = Nothing
    , cachedContentSystemInstruction = Nothing
    , cachedContentToolConfig = Nothing
    , cachedContentCreateTime = Nothing
    , cachedContentTtl = Nothing
    , cachedContentUpdateTime = Nothing
    }

-- ** CachedContentUsageMetadata

{- | CachedContentUsageMetadata
Metadata on the usage of the cached content.
-}
data CachedContentUsageMetadata = CachedContentUsageMetadata
  { cachedContentUsageMetadataTotalTokenCount :: !(Maybe Int)
  -- ^ "totalTokenCount" - Total number of tokens that the cached content consumes.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CachedContentUsageMetadata
instance A.FromJSON CachedContentUsageMetadata where
  parseJSON = A.withObject "CachedContentUsageMetadata" $ \o ->
    CachedContentUsageMetadata
      <$> (o .:? "totalTokenCount")

-- | ToJSON CachedContentUsageMetadata
instance A.ToJSON CachedContentUsageMetadata where
  toJSON CachedContentUsageMetadata {..} =
    _omitNulls
      [ "totalTokenCount" .= cachedContentUsageMetadataTotalTokenCount
      ]

-- | Construct a value of type 'CachedContentUsageMetadata' (by applying it's required fields, if any)
mkCachedContentUsageMetadata ::
  CachedContentUsageMetadata
mkCachedContentUsageMetadata =
  CachedContentUsageMetadata
    { cachedContentUsageMetadataTotalTokenCount = Nothing
    }

-- ** Candidate

{- | Candidate
A response candidate generated from the model.
-}
data Candidate = Candidate
  { candidateCitationMetadata :: !(Maybe CitationMetadata)
  -- ^ /ReadOnly/ "citationMetadata" - Output only. Citation information for model-generated candidate.  This field may be populated with recitation information for any text included in the &#x60;content&#x60;. These are passages that are \&quot;recited\&quot; from copyrighted material in the foundational LLM&#39;s training data.
  , candidateGroundingMetadata :: !(Maybe GroundingMetadata)
  -- ^ /ReadOnly/ "groundingMetadata" - Output only. Grounding metadata for the candidate.  This field is populated for &#x60;GenerateContent&#x60; calls.
  , candidateUrlContextMetadata :: !(Maybe UrlContextMetadata)
  -- ^ /ReadOnly/ "urlContextMetadata" - Output only. Metadata related to url context retrieval tool.
  , candidateGroundingAttributions :: !(Maybe [GroundingAttribution])
  -- ^ /ReadOnly/ "groundingAttributions" - Output only. Attribution information for sources that contributed to a grounded answer.  This field is populated for &#x60;GenerateAnswer&#x60; calls.
  , candidateLogprobsResult :: !(Maybe LogprobsResult)
  -- ^ /ReadOnly/ "logprobsResult" - Output only. Log-likelihood scores for the response tokens and top tokens
  , candidateContent :: !(Maybe Content)
  -- ^ /ReadOnly/ "content" - Output only. Generated content returned from the model.
  , candidateAvgLogprobs :: !(Maybe Double)
  -- ^ /ReadOnly/ "avgLogprobs" - Output only. Average log probability score of the candidate.
  , candidateIndex :: !(Maybe Int)
  -- ^ /ReadOnly/ "index" - Output only. Index of the candidate in the list of response candidates.
  , candidateFinishReason :: !(Maybe E'FinishReason)
  -- ^ /ReadOnly/ "finishReason" - Optional. Output only. The reason why the model stopped generating tokens.  If empty, the model has not stopped generating tokens.
  , candidateSafetyRatings :: !(Maybe [SafetyRating])
  -- ^ "safetyRatings" - List of ratings for the safety of a response candidate.  There is at most one rating per category.
  , candidateTokenCount :: !(Maybe Int)
  -- ^ /ReadOnly/ "tokenCount" - Output only. Token count for this candidate.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Candidate
instance A.FromJSON Candidate where
  parseJSON = A.withObject "Candidate" $ \o ->
    Candidate
      <$> (o .:? "citationMetadata")
      <*> (o .:? "groundingMetadata")
      <*> (o .:? "urlContextMetadata")
      <*> (o .:? "groundingAttributions")
      <*> (o .:? "logprobsResult")
      <*> (o .:? "content")
      <*> (o .:? "avgLogprobs")
      <*> (o .:? "index")
      <*> (o .:? "finishReason")
      <*> (o .:? "safetyRatings")
      <*> (o .:? "tokenCount")

-- | ToJSON Candidate
instance A.ToJSON Candidate where
  toJSON Candidate {..} =
    _omitNulls
      [ "citationMetadata" .= candidateCitationMetadata
      , "groundingMetadata" .= candidateGroundingMetadata
      , "urlContextMetadata" .= candidateUrlContextMetadata
      , "groundingAttributions" .= candidateGroundingAttributions
      , "logprobsResult" .= candidateLogprobsResult
      , "content" .= candidateContent
      , "avgLogprobs" .= candidateAvgLogprobs
      , "index" .= candidateIndex
      , "finishReason" .= candidateFinishReason
      , "safetyRatings" .= candidateSafetyRatings
      , "tokenCount" .= candidateTokenCount
      ]

-- | Construct a value of type 'Candidate' (by applying it's required fields, if any)
mkCandidate ::
  Candidate
mkCandidate =
  Candidate
    { candidateCitationMetadata = Nothing
    , candidateGroundingMetadata = Nothing
    , candidateUrlContextMetadata = Nothing
    , candidateGroundingAttributions = Nothing
    , candidateLogprobsResult = Nothing
    , candidateContent = Nothing
    , candidateAvgLogprobs = Nothing
    , candidateIndex = Nothing
    , candidateFinishReason = Nothing
    , candidateSafetyRatings = Nothing
    , candidateTokenCount = Nothing
    }

-- ** Chunk

{- | Chunk
A `Chunk` is a subpart of a `Document` that is treated as an independent unit for the purposes of vector representation and storage. A `Corpus` can have a maximum of 1 million `Chunk`s.
-}
data Chunk = Chunk
  { chunkCreateTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "createTime" - Output only. The Timestamp of when the &#x60;Chunk&#x60; was created.
  , chunkCustomMetadata :: !(Maybe [CustomMetadata])
  -- ^ "customMetadata" - Optional. User provided custom metadata stored as key-value pairs. The maximum number of &#x60;CustomMetadata&#x60; per chunk is 20.
  , chunkData :: !(ChunkData)
  -- ^ /Required/ "data" - Required. The content for the &#x60;Chunk&#x60;, such as the text string. The maximum number of tokens per chunk is 2043.
  , chunkUpdateTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "updateTime" - Output only. The Timestamp of when the &#x60;Chunk&#x60; was last updated.
  , chunkState :: !(Maybe E'State4)
  -- ^ /ReadOnly/ "state" - Output only. Current state of the &#x60;Chunk&#x60;.
  , chunkName :: !(Maybe Text)
  -- ^ "name" - Immutable. Identifier. The &#x60;Chunk&#x60; resource name. The ID (name excluding the \&quot;corpora/*/documents/*/chunks/\&quot; prefix) can contain up to 40 characters that are lowercase alphanumeric or dashes (-). The ID cannot start or end with a dash. If the name is empty on create, a random 12-character unique ID will be generated. Example: &#x60;corpora/{corpus_id}/documents/{document_id}/chunks/123a456b789c&#x60;
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Chunk
instance A.FromJSON Chunk where
  parseJSON = A.withObject "Chunk" $ \o ->
    Chunk
      <$> (o .:? "createTime")
      <*> (o .:? "customMetadata")
      <*> (o .: "data")
      <*> (o .:? "updateTime")
      <*> (o .:? "state")
      <*> (o .:? "name")

-- | ToJSON Chunk
instance A.ToJSON Chunk where
  toJSON Chunk {..} =
    _omitNulls
      [ "createTime" .= chunkCreateTime
      , "customMetadata" .= chunkCustomMetadata
      , "data" .= chunkData
      , "updateTime" .= chunkUpdateTime
      , "state" .= chunkState
      , "name" .= chunkName
      ]

-- | Construct a value of type 'Chunk' (by applying it's required fields, if any)
mkChunk ::
  -- | 'chunkData': Required. The content for the `Chunk`, such as the text string. The maximum number of tokens per chunk is 2043.
  ChunkData ->
  Chunk
mkChunk chunkData =
  Chunk
    { chunkCreateTime = Nothing
    , chunkCustomMetadata = Nothing
    , chunkData
    , chunkUpdateTime = Nothing
    , chunkState = Nothing
    , chunkName = Nothing
    }

-- ** ChunkData

{- | ChunkData
Extracted data that represents the `Chunk` content.
-}
data ChunkData = ChunkData
  { chunkDataStringValue :: !(Maybe Text)
  -- ^ "stringValue" - The &#x60;Chunk&#x60; content as a string. The maximum number of tokens per chunk is 2043.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChunkData
instance A.FromJSON ChunkData where
  parseJSON = A.withObject "ChunkData" $ \o ->
    ChunkData
      <$> (o .:? "stringValue")

-- | ToJSON ChunkData
instance A.ToJSON ChunkData where
  toJSON ChunkData {..} =
    _omitNulls
      [ "stringValue" .= chunkDataStringValue
      ]

-- | Construct a value of type 'ChunkData' (by applying it's required fields, if any)
mkChunkData ::
  ChunkData
mkChunkData =
  ChunkData
    { chunkDataStringValue = Nothing
    }

-- ** CitationMetadata

{- | CitationMetadata
A collection of source attributions for a piece of content.
-}
data CitationMetadata = CitationMetadata
  { citationMetadataCitationSources :: !(Maybe [CitationSource])
  -- ^ "citationSources" - Citations to sources for a specific response.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CitationMetadata
instance A.FromJSON CitationMetadata where
  parseJSON = A.withObject "CitationMetadata" $ \o ->
    CitationMetadata
      <$> (o .:? "citationSources")

-- | ToJSON CitationMetadata
instance A.ToJSON CitationMetadata where
  toJSON CitationMetadata {..} =
    _omitNulls
      [ "citationSources" .= citationMetadataCitationSources
      ]

-- | Construct a value of type 'CitationMetadata' (by applying it's required fields, if any)
mkCitationMetadata ::
  CitationMetadata
mkCitationMetadata =
  CitationMetadata
    { citationMetadataCitationSources = Nothing
    }

-- ** CitationSource

{- | CitationSource
A citation to a source for a portion of a specific response.
-}
data CitationSource = CitationSource
  { citationSourceStartIndex :: !(Maybe Int)
  -- ^ "startIndex" - Optional. Start of segment of the response that is attributed to this source.  Index indicates the start of the segment, measured in bytes.
  , citationSourceUri :: !(Maybe Text)
  -- ^ "uri" - Optional. URI that is attributed as a source for a portion of the text.
  , citationSourceEndIndex :: !(Maybe Int)
  -- ^ "endIndex" - Optional. End of the attributed segment, exclusive.
  , citationSourceLicense :: !(Maybe Text)
  -- ^ "license" - Optional. License for the GitHub project that is attributed as a source for segment.  License info is required for code citations.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CitationSource
instance A.FromJSON CitationSource where
  parseJSON = A.withObject "CitationSource" $ \o ->
    CitationSource
      <$> (o .:? "startIndex")
      <*> (o .:? "uri")
      <*> (o .:? "endIndex")
      <*> (o .:? "license")

-- | ToJSON CitationSource
instance A.ToJSON CitationSource where
  toJSON CitationSource {..} =
    _omitNulls
      [ "startIndex" .= citationSourceStartIndex
      , "uri" .= citationSourceUri
      , "endIndex" .= citationSourceEndIndex
      , "license" .= citationSourceLicense
      ]

-- | Construct a value of type 'CitationSource' (by applying it's required fields, if any)
mkCitationSource ::
  CitationSource
mkCitationSource =
  CitationSource
    { citationSourceStartIndex = Nothing
    , citationSourceUri = Nothing
    , citationSourceEndIndex = Nothing
    , citationSourceLicense = Nothing
    }

-- ** CodeExecutionResult

{- | CodeExecutionResult
Result of executing the `ExecutableCode`.  Only generated when using the `CodeExecution`, and always follows a `part` containing the `ExecutableCode`.
-}
data CodeExecutionResult = CodeExecutionResult
  { codeExecutionResultOutcome :: !(E'Outcome)
  -- ^ /Required/ "outcome" - Required. Outcome of the code execution.
  , codeExecutionResultOutput :: !(Maybe Text)
  -- ^ "output" - Optional. Contains stdout when code execution is successful, stderr or other description otherwise.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CodeExecutionResult
instance A.FromJSON CodeExecutionResult where
  parseJSON = A.withObject "CodeExecutionResult" $ \o ->
    CodeExecutionResult
      <$> (o .: "outcome")
      <*> (o .:? "output")

-- | ToJSON CodeExecutionResult
instance A.ToJSON CodeExecutionResult where
  toJSON CodeExecutionResult {..} =
    _omitNulls
      [ "outcome" .= codeExecutionResultOutcome
      , "output" .= codeExecutionResultOutput
      ]

-- | Construct a value of type 'CodeExecutionResult' (by applying it's required fields, if any)
mkCodeExecutionResult ::
  -- | 'codeExecutionResultOutcome': Required. Outcome of the code execution.
  E'Outcome ->
  CodeExecutionResult
mkCodeExecutionResult codeExecutionResultOutcome =
  CodeExecutionResult
    { codeExecutionResultOutcome
    , codeExecutionResultOutput = Nothing
    }

-- ** Condition

{- | Condition
Filter condition applicable to a single key.
-}
data Condition = Condition
  { conditionNumericValue :: !(Maybe Float)
  -- ^ "numericValue" - The numeric value to filter the metadata on.
  , conditionOperation :: !(E'Operation)
  -- ^ /Required/ "operation" - Required. Operator applied to the given key-value pair to trigger the condition.
  , conditionStringValue :: !(Maybe Text)
  -- ^ "stringValue" - The string value to filter the metadata on.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Condition
instance A.FromJSON Condition where
  parseJSON = A.withObject "Condition" $ \o ->
    Condition
      <$> (o .:? "numericValue")
      <*> (o .: "operation")
      <*> (o .:? "stringValue")

-- | ToJSON Condition
instance A.ToJSON Condition where
  toJSON Condition {..} =
    _omitNulls
      [ "numericValue" .= conditionNumericValue
      , "operation" .= conditionOperation
      , "stringValue" .= conditionStringValue
      ]

-- | Construct a value of type 'Condition' (by applying it's required fields, if any)
mkCondition ::
  -- | 'conditionOperation': Required. Operator applied to the given key-value pair to trigger the condition.
  E'Operation ->
  Condition
mkCondition conditionOperation =
  Condition
    { conditionNumericValue = Nothing
    , conditionOperation
    , conditionStringValue = Nothing
    }

-- ** Content

{- | Content
The base structured datatype containing multi-part content of a message.  A `Content` includes a `role` field designating the producer of the `Content` and a `parts` field containing multi-part data that contains the content of the message turn.
-}
data Content = Content
  { contentParts :: !(Maybe [Part])
  -- ^ "parts" - Ordered &#x60;Parts&#x60; that constitute a single message. Parts may have different MIME types.
  , contentRole :: !(Maybe Text)
  -- ^ "role" - Optional. The producer of the content. Must be either &#39;user&#39; or &#39;model&#39;.  Useful to set for multi-turn conversations, otherwise can be left blank or unset.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Content
instance A.FromJSON Content where
  parseJSON = A.withObject "Content" $ \o ->
    Content
      <$> (o .:? "parts")
      <*> (o .:? "role")

-- | ToJSON Content
instance A.ToJSON Content where
  toJSON Content {..} =
    _omitNulls
      [ "parts" .= contentParts
      , "role" .= contentRole
      ]

-- | Construct a value of type 'Content' (by applying it's required fields, if any)
mkContent ::
  Content
mkContent =
  Content
    { contentParts = Nothing
    , contentRole = Nothing
    }

-- ** ContentEmbedding

{- | ContentEmbedding
A list of floats representing an embedding.
-}
data ContentEmbedding = ContentEmbedding
  { contentEmbeddingValues :: !(Maybe [Float])
  -- ^ "values" - The embedding values.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContentEmbedding
instance A.FromJSON ContentEmbedding where
  parseJSON = A.withObject "ContentEmbedding" $ \o ->
    ContentEmbedding
      <$> (o .:? "values")

-- | ToJSON ContentEmbedding
instance A.ToJSON ContentEmbedding where
  toJSON ContentEmbedding {..} =
    _omitNulls
      [ "values" .= contentEmbeddingValues
      ]

-- | Construct a value of type 'ContentEmbedding' (by applying it's required fields, if any)
mkContentEmbedding ::
  ContentEmbedding
mkContentEmbedding =
  ContentEmbedding
    { contentEmbeddingValues = Nothing
    }

-- ** ContentFilter

{- | ContentFilter
Content filtering metadata associated with processing a single request.  ContentFilter contains a reason and an optional supporting string. The reason may be unspecified.
-}
data ContentFilter = ContentFilter
  { contentFilterReason :: !(Maybe E'Reason)
  -- ^ "reason" - The reason content was blocked during request processing.
  , contentFilterMessage :: !(Maybe Text)
  -- ^ "message" - A string that describes the filtering behavior in more detail.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContentFilter
instance A.FromJSON ContentFilter where
  parseJSON = A.withObject "ContentFilter" $ \o ->
    ContentFilter
      <$> (o .:? "reason")
      <*> (o .:? "message")

-- | ToJSON ContentFilter
instance A.ToJSON ContentFilter where
  toJSON ContentFilter {..} =
    _omitNulls
      [ "reason" .= contentFilterReason
      , "message" .= contentFilterMessage
      ]

-- | Construct a value of type 'ContentFilter' (by applying it's required fields, if any)
mkContentFilter ::
  ContentFilter
mkContentFilter =
  ContentFilter
    { contentFilterReason = Nothing
    , contentFilterMessage = Nothing
    }

-- ** Corpus

{- | Corpus
A `Corpus` is a collection of `Document`s. A project can create up to 5 corpora.
-}
data Corpus = Corpus
  { corpusUpdateTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "updateTime" - Output only. The Timestamp of when the &#x60;Corpus&#x60; was last updated.
  , corpusCreateTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "createTime" - Output only. The Timestamp of when the &#x60;Corpus&#x60; was created.
  , corpusDisplayName :: !(Maybe Text)
  -- ^ "displayName" - Optional. The human-readable display name for the &#x60;Corpus&#x60;. The display name must be no more than 512 characters in length, including spaces. Example: \&quot;Docs on Semantic Retriever\&quot;
  , corpusName :: !(Maybe Text)
  -- ^ "name" - Immutable. Identifier. The &#x60;Corpus&#x60; resource name. The ID (name excluding the \&quot;corpora/\&quot; prefix) can contain up to 40 characters that are lowercase alphanumeric or dashes (-). The ID cannot start or end with a dash. If the name is empty on create, a unique name will be derived from &#x60;display_name&#x60; along with a 12 character random suffix. Example: &#x60;corpora/my-awesome-corpora-123a456b789c&#x60;
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Corpus
instance A.FromJSON Corpus where
  parseJSON = A.withObject "Corpus" $ \o ->
    Corpus
      <$> (o .:? "updateTime")
      <*> (o .:? "createTime")
      <*> (o .:? "displayName")
      <*> (o .:? "name")

-- | ToJSON Corpus
instance A.ToJSON Corpus where
  toJSON Corpus {..} =
    _omitNulls
      [ "updateTime" .= corpusUpdateTime
      , "createTime" .= corpusCreateTime
      , "displayName" .= corpusDisplayName
      , "name" .= corpusName
      ]

-- | Construct a value of type 'Corpus' (by applying it's required fields, if any)
mkCorpus ::
  Corpus
mkCorpus =
  Corpus
    { corpusUpdateTime = Nothing
    , corpusCreateTime = Nothing
    , corpusDisplayName = Nothing
    , corpusName = Nothing
    }

-- ** CountMessageTokensRequest

{- | CountMessageTokensRequest
Counts the number of tokens in the `prompt` sent to a model.  Models may tokenize text differently, so each model may return a different `token_count`.
-}
data CountMessageTokensRequest = CountMessageTokensRequest
  { countMessageTokensRequestPrompt :: !(MessagePrompt)
  -- ^ /Required/ "prompt" - Required. The prompt, whose token count is to be returned.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CountMessageTokensRequest
instance A.FromJSON CountMessageTokensRequest where
  parseJSON = A.withObject "CountMessageTokensRequest" $ \o ->
    CountMessageTokensRequest
      <$> (o .: "prompt")

-- | ToJSON CountMessageTokensRequest
instance A.ToJSON CountMessageTokensRequest where
  toJSON CountMessageTokensRequest {..} =
    _omitNulls
      [ "prompt" .= countMessageTokensRequestPrompt
      ]

-- | Construct a value of type 'CountMessageTokensRequest' (by applying it's required fields, if any)
mkCountMessageTokensRequest ::
  -- | 'countMessageTokensRequestPrompt': Required. The prompt, whose token count is to be returned.
  MessagePrompt ->
  CountMessageTokensRequest
mkCountMessageTokensRequest countMessageTokensRequestPrompt =
  CountMessageTokensRequest
    { countMessageTokensRequestPrompt
    }

-- ** CountMessageTokensResponse

{- | CountMessageTokensResponse
A response from `CountMessageTokens`.  It returns the model's `token_count` for the `prompt`.
-}
data CountMessageTokensResponse = CountMessageTokensResponse
  { countMessageTokensResponseTokenCount :: !(Maybe Int)
  -- ^ "tokenCount" - The number of tokens that the &#x60;model&#x60; tokenizes the &#x60;prompt&#x60; into.  Always non-negative.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CountMessageTokensResponse
instance A.FromJSON CountMessageTokensResponse where
  parseJSON = A.withObject "CountMessageTokensResponse" $ \o ->
    CountMessageTokensResponse
      <$> (o .:? "tokenCount")

-- | ToJSON CountMessageTokensResponse
instance A.ToJSON CountMessageTokensResponse where
  toJSON CountMessageTokensResponse {..} =
    _omitNulls
      [ "tokenCount" .= countMessageTokensResponseTokenCount
      ]

-- | Construct a value of type 'CountMessageTokensResponse' (by applying it's required fields, if any)
mkCountMessageTokensResponse ::
  CountMessageTokensResponse
mkCountMessageTokensResponse =
  CountMessageTokensResponse
    { countMessageTokensResponseTokenCount = Nothing
    }

-- ** CountTextTokensRequest

{- | CountTextTokensRequest
Counts the number of tokens in the `prompt` sent to a model.  Models may tokenize text differently, so each model may return a different `token_count`.
-}
data CountTextTokensRequest = CountTextTokensRequest
  { countTextTokensRequestPrompt :: !(TextPrompt)
  -- ^ /Required/ "prompt" - Required. The free-form input text given to the model as a prompt.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CountTextTokensRequest
instance A.FromJSON CountTextTokensRequest where
  parseJSON = A.withObject "CountTextTokensRequest" $ \o ->
    CountTextTokensRequest
      <$> (o .: "prompt")

-- | ToJSON CountTextTokensRequest
instance A.ToJSON CountTextTokensRequest where
  toJSON CountTextTokensRequest {..} =
    _omitNulls
      [ "prompt" .= countTextTokensRequestPrompt
      ]

-- | Construct a value of type 'CountTextTokensRequest' (by applying it's required fields, if any)
mkCountTextTokensRequest ::
  -- | 'countTextTokensRequestPrompt': Required. The free-form input text given to the model as a prompt.
  TextPrompt ->
  CountTextTokensRequest
mkCountTextTokensRequest countTextTokensRequestPrompt =
  CountTextTokensRequest
    { countTextTokensRequestPrompt
    }

-- ** CountTextTokensResponse

{- | CountTextTokensResponse
A response from `CountTextTokens`.  It returns the model's `token_count` for the `prompt`.
-}
data CountTextTokensResponse = CountTextTokensResponse
  { countTextTokensResponseTokenCount :: !(Maybe Int)
  -- ^ "tokenCount" - The number of tokens that the &#x60;model&#x60; tokenizes the &#x60;prompt&#x60; into.  Always non-negative.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CountTextTokensResponse
instance A.FromJSON CountTextTokensResponse where
  parseJSON = A.withObject "CountTextTokensResponse" $ \o ->
    CountTextTokensResponse
      <$> (o .:? "tokenCount")

-- | ToJSON CountTextTokensResponse
instance A.ToJSON CountTextTokensResponse where
  toJSON CountTextTokensResponse {..} =
    _omitNulls
      [ "tokenCount" .= countTextTokensResponseTokenCount
      ]

-- | Construct a value of type 'CountTextTokensResponse' (by applying it's required fields, if any)
mkCountTextTokensResponse ::
  CountTextTokensResponse
mkCountTextTokensResponse =
  CountTextTokensResponse
    { countTextTokensResponseTokenCount = Nothing
    }

-- ** CountTokensRequest

{- | CountTokensRequest
Counts the number of tokens in the `prompt` sent to a model.  Models may tokenize text differently, so each model may return a different `token_count`.
-}
data CountTokensRequest = CountTokensRequest
  { countTokensRequestContents :: !(Maybe [Content])
  -- ^ "contents" - Optional. The input given to the model as a prompt. This field is ignored when &#x60;generate_content_request&#x60; is set.
  , countTokensRequestGenerateContentRequest :: !(Maybe GenerateContentRequest)
  -- ^ "generateContentRequest" - Optional. The overall input given to the &#x60;Model&#x60;. This includes the prompt as well as other model steering information like [system instructions](https://ai.google.dev/gemini-api/docs/system-instructions), and/or function declarations for [function calling](https://ai.google.dev/gemini-api/docs/function-calling). &#x60;Model&#x60;s/&#x60;Content&#x60;s and &#x60;generate_content_request&#x60;s are mutually exclusive. You can either send &#x60;Model&#x60; + &#x60;Content&#x60;s or a &#x60;generate_content_request&#x60;, but never both.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CountTokensRequest
instance A.FromJSON CountTokensRequest where
  parseJSON = A.withObject "CountTokensRequest" $ \o ->
    CountTokensRequest
      <$> (o .:? "contents")
      <*> (o .:? "generateContentRequest")

-- | ToJSON CountTokensRequest
instance A.ToJSON CountTokensRequest where
  toJSON CountTokensRequest {..} =
    _omitNulls
      [ "contents" .= countTokensRequestContents
      , "generateContentRequest" .= countTokensRequestGenerateContentRequest
      ]

-- | Construct a value of type 'CountTokensRequest' (by applying it's required fields, if any)
mkCountTokensRequest ::
  CountTokensRequest
mkCountTokensRequest =
  CountTokensRequest
    { countTokensRequestContents = Nothing
    , countTokensRequestGenerateContentRequest = Nothing
    }

-- ** CountTokensResponse

{- | CountTokensResponse
A response from `CountTokens`.  It returns the model's `token_count` for the `prompt`.
-}
data CountTokensResponse = CountTokensResponse
  { countTokensResponseCacheTokensDetails :: !(Maybe [ModalityTokenCount])
  -- ^ /ReadOnly/ "cacheTokensDetails" - Output only. List of modalities that were processed in the cached content.
  , countTokensResponsePromptTokensDetails :: !(Maybe [ModalityTokenCount])
  -- ^ /ReadOnly/ "promptTokensDetails" - Output only. List of modalities that were processed in the request input.
  , countTokensResponseTotalTokens :: !(Maybe Int)
  -- ^ "totalTokens" - The number of tokens that the &#x60;Model&#x60; tokenizes the &#x60;prompt&#x60; into. Always non-negative.
  , countTokensResponseCachedContentTokenCount :: !(Maybe Int)
  -- ^ "cachedContentTokenCount" - Number of tokens in the cached part of the prompt (the cached content).
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CountTokensResponse
instance A.FromJSON CountTokensResponse where
  parseJSON = A.withObject "CountTokensResponse" $ \o ->
    CountTokensResponse
      <$> (o .:? "cacheTokensDetails")
      <*> (o .:? "promptTokensDetails")
      <*> (o .:? "totalTokens")
      <*> (o .:? "cachedContentTokenCount")

-- | ToJSON CountTokensResponse
instance A.ToJSON CountTokensResponse where
  toJSON CountTokensResponse {..} =
    _omitNulls
      [ "cacheTokensDetails" .= countTokensResponseCacheTokensDetails
      , "promptTokensDetails" .= countTokensResponsePromptTokensDetails
      , "totalTokens" .= countTokensResponseTotalTokens
      , "cachedContentTokenCount" .= countTokensResponseCachedContentTokenCount
      ]

-- | Construct a value of type 'CountTokensResponse' (by applying it's required fields, if any)
mkCountTokensResponse ::
  CountTokensResponse
mkCountTokensResponse =
  CountTokensResponse
    { countTokensResponseCacheTokensDetails = Nothing
    , countTokensResponsePromptTokensDetails = Nothing
    , countTokensResponseTotalTokens = Nothing
    , countTokensResponseCachedContentTokenCount = Nothing
    }

-- ** CreateChunkRequest

{- | CreateChunkRequest
Request to create a `Chunk`.
-}
data CreateChunkRequest = CreateChunkRequest
  { createChunkRequestParent :: !(Text)
  -- ^ /Required/ "parent" - Required. The name of the &#x60;Document&#x60; where this &#x60;Chunk&#x60; will be created. Example: &#x60;corpora/my-corpus-123/documents/the-doc-abc&#x60;
  , createChunkRequestChunk :: !(Chunk)
  -- ^ /Required/ "chunk" - Required. The &#x60;Chunk&#x60; to create.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChunkRequest
instance A.FromJSON CreateChunkRequest where
  parseJSON = A.withObject "CreateChunkRequest" $ \o ->
    CreateChunkRequest
      <$> (o .: "parent")
      <*> (o .: "chunk")

-- | ToJSON CreateChunkRequest
instance A.ToJSON CreateChunkRequest where
  toJSON CreateChunkRequest {..} =
    _omitNulls
      [ "parent" .= createChunkRequestParent
      , "chunk" .= createChunkRequestChunk
      ]

-- | Construct a value of type 'CreateChunkRequest' (by applying it's required fields, if any)
mkCreateChunkRequest ::
  -- | 'createChunkRequestParent': Required. The name of the `Document` where this `Chunk` will be created. Example: `corpora/my-corpus-123/documents/the-doc-abc`
  Text ->
  -- | 'createChunkRequestChunk': Required. The `Chunk` to create.
  Chunk ->
  CreateChunkRequest
mkCreateChunkRequest createChunkRequestParent createChunkRequestChunk =
  CreateChunkRequest
    { createChunkRequestParent
    , createChunkRequestChunk
    }

-- ** CreateFileRequest

{- | CreateFileRequest
Request for `CreateFile`.
-}
data CreateFileRequest = CreateFileRequest
  { createFileRequestFile :: !(Maybe File)
  -- ^ "file" - Optional. Metadata for the file to create.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateFileRequest
instance A.FromJSON CreateFileRequest where
  parseJSON = A.withObject "CreateFileRequest" $ \o ->
    CreateFileRequest
      <$> (o .:? "file")

-- | ToJSON CreateFileRequest
instance A.ToJSON CreateFileRequest where
  toJSON CreateFileRequest {..} =
    _omitNulls
      [ "file" .= createFileRequestFile
      ]

-- | Construct a value of type 'CreateFileRequest' (by applying it's required fields, if any)
mkCreateFileRequest ::
  CreateFileRequest
mkCreateFileRequest =
  CreateFileRequest
    { createFileRequestFile = Nothing
    }

-- ** CreateFileResponse

{- | CreateFileResponse
Response for `CreateFile`.
-}
data CreateFileResponse = CreateFileResponse
  { createFileResponseFile :: !(Maybe File)
  -- ^ "file" - Metadata for the created file.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateFileResponse
instance A.FromJSON CreateFileResponse where
  parseJSON = A.withObject "CreateFileResponse" $ \o ->
    CreateFileResponse
      <$> (o .:? "file")

-- | ToJSON CreateFileResponse
instance A.ToJSON CreateFileResponse where
  toJSON CreateFileResponse {..} =
    _omitNulls
      [ "file" .= createFileResponseFile
      ]

-- | Construct a value of type 'CreateFileResponse' (by applying it's required fields, if any)
mkCreateFileResponse ::
  CreateFileResponse
mkCreateFileResponse =
  CreateFileResponse
    { createFileResponseFile = Nothing
    }

-- ** CreateTunedModelMetadata

{- | CreateTunedModelMetadata
Metadata about the state and progress of creating a tuned model returned from the long-running operation
-}
data CreateTunedModelMetadata = CreateTunedModelMetadata
  { createTunedModelMetadataCompletedPercent :: !(Maybe Float)
  -- ^ "completedPercent" - The completed percentage for the tuning operation.
  , createTunedModelMetadataCompletedSteps :: !(Maybe Int)
  -- ^ "completedSteps" - The number of steps completed.
  , createTunedModelMetadataTotalSteps :: !(Maybe Int)
  -- ^ "totalSteps" - The total number of tuning steps.
  , createTunedModelMetadataSnapshots :: !(Maybe [TuningSnapshot])
  -- ^ "snapshots" - Metrics collected during tuning.
  , createTunedModelMetadataTunedModel :: !(Maybe Text)
  -- ^ "tunedModel" - Name of the tuned model associated with the tuning operation.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTunedModelMetadata
instance A.FromJSON CreateTunedModelMetadata where
  parseJSON = A.withObject "CreateTunedModelMetadata" $ \o ->
    CreateTunedModelMetadata
      <$> (o .:? "completedPercent")
      <*> (o .:? "completedSteps")
      <*> (o .:? "totalSteps")
      <*> (o .:? "snapshots")
      <*> (o .:? "tunedModel")

-- | ToJSON CreateTunedModelMetadata
instance A.ToJSON CreateTunedModelMetadata where
  toJSON CreateTunedModelMetadata {..} =
    _omitNulls
      [ "completedPercent" .= createTunedModelMetadataCompletedPercent
      , "completedSteps" .= createTunedModelMetadataCompletedSteps
      , "totalSteps" .= createTunedModelMetadataTotalSteps
      , "snapshots" .= createTunedModelMetadataSnapshots
      , "tunedModel" .= createTunedModelMetadataTunedModel
      ]

-- | Construct a value of type 'CreateTunedModelMetadata' (by applying it's required fields, if any)
mkCreateTunedModelMetadata ::
  CreateTunedModelMetadata
mkCreateTunedModelMetadata =
  CreateTunedModelMetadata
    { createTunedModelMetadataCompletedPercent = Nothing
    , createTunedModelMetadataCompletedSteps = Nothing
    , createTunedModelMetadataTotalSteps = Nothing
    , createTunedModelMetadataSnapshots = Nothing
    , createTunedModelMetadataTunedModel = Nothing
    }

-- ** CreateTunedModelOperation

{- | CreateTunedModelOperation
This resource represents a long-running operation where metadata and response fields are strongly typed.
-}
data CreateTunedModelOperation = CreateTunedModelOperation
  { createTunedModelOperationDone :: !(Maybe Bool)
  -- ^ "done" - If the value is &#x60;false&#x60;, it means the operation is still in progress. If &#x60;true&#x60;, the operation is completed, and either &#x60;error&#x60; or &#x60;response&#x60; is available.
  , createTunedModelOperationName :: !(Maybe Text)
  -- ^ "name" - The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the &#x60;name&#x60; should be a resource name ending with &#x60;operations/{unique_id}&#x60;.
  , createTunedModelOperationError :: !(Maybe Status)
  -- ^ "error" - The error result of the operation in case of failure or cancellation.
  , createTunedModelOperationMetadata :: !(Maybe CreateTunedModelMetadata)
  -- ^ "metadata"
  , createTunedModelOperationResponse :: !(Maybe TunedModel)
  -- ^ "response"
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTunedModelOperation
instance A.FromJSON CreateTunedModelOperation where
  parseJSON = A.withObject "CreateTunedModelOperation" $ \o ->
    CreateTunedModelOperation
      <$> (o .:? "done")
      <*> (o .:? "name")
      <*> (o .:? "error")
      <*> (o .:? "metadata")
      <*> (o .:? "response")

-- | ToJSON CreateTunedModelOperation
instance A.ToJSON CreateTunedModelOperation where
  toJSON CreateTunedModelOperation {..} =
    _omitNulls
      [ "done" .= createTunedModelOperationDone
      , "name" .= createTunedModelOperationName
      , "error" .= createTunedModelOperationError
      , "metadata" .= createTunedModelOperationMetadata
      , "response" .= createTunedModelOperationResponse
      ]

-- | Construct a value of type 'CreateTunedModelOperation' (by applying it's required fields, if any)
mkCreateTunedModelOperation ::
  CreateTunedModelOperation
mkCreateTunedModelOperation =
  CreateTunedModelOperation
    { createTunedModelOperationDone = Nothing
    , createTunedModelOperationName = Nothing
    , createTunedModelOperationError = Nothing
    , createTunedModelOperationMetadata = Nothing
    , createTunedModelOperationResponse = Nothing
    }

-- ** CustomMetadata

{- | CustomMetadata
User provided metadata stored as key-value pairs.
-}
data CustomMetadata = CustomMetadata
  { customMetadataStringListValue :: !(Maybe StringList)
  -- ^ "stringListValue" - The StringList value of the metadata to store.
  , customMetadataStringValue :: !(Maybe Text)
  -- ^ "stringValue" - The string value of the metadata to store.
  , customMetadataKey :: !(Text)
  -- ^ /Required/ "key" - Required. The key of the metadata to store.
  , customMetadataNumericValue :: !(Maybe Float)
  -- ^ "numericValue" - The numeric value of the metadata to store.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomMetadata
instance A.FromJSON CustomMetadata where
  parseJSON = A.withObject "CustomMetadata" $ \o ->
    CustomMetadata
      <$> (o .:? "stringListValue")
      <*> (o .:? "stringValue")
      <*> (o .: "key")
      <*> (o .:? "numericValue")

-- | ToJSON CustomMetadata
instance A.ToJSON CustomMetadata where
  toJSON CustomMetadata {..} =
    _omitNulls
      [ "stringListValue" .= customMetadataStringListValue
      , "stringValue" .= customMetadataStringValue
      , "key" .= customMetadataKey
      , "numericValue" .= customMetadataNumericValue
      ]

-- | Construct a value of type 'CustomMetadata' (by applying it's required fields, if any)
mkCustomMetadata ::
  -- | 'customMetadataKey': Required. The key of the metadata to store.
  Text ->
  CustomMetadata
mkCustomMetadata customMetadataKey =
  CustomMetadata
    { customMetadataStringListValue = Nothing
    , customMetadataStringValue = Nothing
    , customMetadataKey
    , customMetadataNumericValue = Nothing
    }

-- ** Dataset

{- | Dataset
Dataset for training or validation.
-}
data Dataset = Dataset
  { datasetExamples :: !(Maybe TuningExamples)
  -- ^ "examples" - Optional. Inline examples with simple input/output text.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Dataset
instance A.FromJSON Dataset where
  parseJSON = A.withObject "Dataset" $ \o ->
    Dataset
      <$> (o .:? "examples")

-- | ToJSON Dataset
instance A.ToJSON Dataset where
  toJSON Dataset {..} =
    _omitNulls
      [ "examples" .= datasetExamples
      ]

-- | Construct a value of type 'Dataset' (by applying it's required fields, if any)
mkDataset ::
  Dataset
mkDataset =
  Dataset
    { datasetExamples = Nothing
    }

-- ** DeleteChunkRequest

{- | DeleteChunkRequest
Request to delete a `Chunk`.
-}
data DeleteChunkRequest = DeleteChunkRequest
  { deleteChunkRequestName :: !(Text)
  -- ^ /Required/ "name" - Required. The resource name of the &#x60;Chunk&#x60; to delete. Example: &#x60;corpora/my-corpus-123/documents/the-doc-abc/chunks/some-chunk&#x60;
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteChunkRequest
instance A.FromJSON DeleteChunkRequest where
  parseJSON = A.withObject "DeleteChunkRequest" $ \o ->
    DeleteChunkRequest
      <$> (o .: "name")

-- | ToJSON DeleteChunkRequest
instance A.ToJSON DeleteChunkRequest where
  toJSON DeleteChunkRequest {..} =
    _omitNulls
      [ "name" .= deleteChunkRequestName
      ]

-- | Construct a value of type 'DeleteChunkRequest' (by applying it's required fields, if any)
mkDeleteChunkRequest ::
  -- | 'deleteChunkRequestName': Required. The resource name of the `Chunk` to delete. Example: `corpora/my-corpus-123/documents/the-doc-abc/chunks/some-chunk`
  Text ->
  DeleteChunkRequest
mkDeleteChunkRequest deleteChunkRequestName =
  DeleteChunkRequest
    { deleteChunkRequestName
    }

-- ** Document

{- | Document
A `Document` is a collection of `Chunk`s. A `Corpus` can have a maximum of 10,000 `Document`s.
-}
data Document = Document
  { documentUpdateTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "updateTime" - Output only. The Timestamp of when the &#x60;Document&#x60; was last updated.
  , documentName :: !(Maybe Text)
  -- ^ "name" - Immutable. Identifier. The &#x60;Document&#x60; resource name. The ID (name excluding the \&quot;corpora/*/documents/\&quot; prefix) can contain up to 40 characters that are lowercase alphanumeric or dashes (-). The ID cannot start or end with a dash. If the name is empty on create, a unique name will be derived from &#x60;display_name&#x60; along with a 12 character random suffix. Example: &#x60;corpora/{corpus_id}/documents/my-awesome-doc-123a456b789c&#x60;
  , documentCustomMetadata :: !(Maybe [CustomMetadata])
  -- ^ "customMetadata" - Optional. User provided custom metadata stored as key-value pairs used for querying. A &#x60;Document&#x60; can have a maximum of 20 &#x60;CustomMetadata&#x60;.
  , documentCreateTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "createTime" - Output only. The Timestamp of when the &#x60;Document&#x60; was created.
  , documentDisplayName :: !(Maybe Text)
  -- ^ "displayName" - Optional. The human-readable display name for the &#x60;Document&#x60;. The display name must be no more than 512 characters in length, including spaces. Example: \&quot;Semantic Retriever Documentation\&quot;
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Document
instance A.FromJSON Document where
  parseJSON = A.withObject "Document" $ \o ->
    Document
      <$> (o .:? "updateTime")
      <*> (o .:? "name")
      <*> (o .:? "customMetadata")
      <*> (o .:? "createTime")
      <*> (o .:? "displayName")

-- | ToJSON Document
instance A.ToJSON Document where
  toJSON Document {..} =
    _omitNulls
      [ "updateTime" .= documentUpdateTime
      , "name" .= documentName
      , "customMetadata" .= documentCustomMetadata
      , "createTime" .= documentCreateTime
      , "displayName" .= documentDisplayName
      ]

-- | Construct a value of type 'Document' (by applying it's required fields, if any)
mkDocument ::
  Document
mkDocument =
  Document
    { documentUpdateTime = Nothing
    , documentName = Nothing
    , documentCustomMetadata = Nothing
    , documentCreateTime = Nothing
    , documentDisplayName = Nothing
    }

-- ** DynamicRetrievalConfig

{- | DynamicRetrievalConfig
Describes the options to customize dynamic retrieval.
-}
data DynamicRetrievalConfig = DynamicRetrievalConfig
  { dynamicRetrievalConfigDynamicThreshold :: !(Maybe Float)
  -- ^ "dynamicThreshold" - The threshold to be used in dynamic retrieval. If not set, a system default value is used.
  , dynamicRetrievalConfigMode :: !(Maybe E'Mode)
  -- ^ "mode" - The mode of the predictor to be used in dynamic retrieval.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DynamicRetrievalConfig
instance A.FromJSON DynamicRetrievalConfig where
  parseJSON = A.withObject "DynamicRetrievalConfig" $ \o ->
    DynamicRetrievalConfig
      <$> (o .:? "dynamicThreshold")
      <*> (o .:? "mode")

-- | ToJSON DynamicRetrievalConfig
instance A.ToJSON DynamicRetrievalConfig where
  toJSON DynamicRetrievalConfig {..} =
    _omitNulls
      [ "dynamicThreshold" .= dynamicRetrievalConfigDynamicThreshold
      , "mode" .= dynamicRetrievalConfigMode
      ]

-- | Construct a value of type 'DynamicRetrievalConfig' (by applying it's required fields, if any)
mkDynamicRetrievalConfig ::
  DynamicRetrievalConfig
mkDynamicRetrievalConfig =
  DynamicRetrievalConfig
    { dynamicRetrievalConfigDynamicThreshold = Nothing
    , dynamicRetrievalConfigMode = Nothing
    }

-- ** EmbedContentRequest

{- | EmbedContentRequest
Request containing the `Content` for the model to embed.
-}
data EmbedContentRequest = EmbedContentRequest
  { embedContentRequestTaskType :: !(Maybe TaskType)
  -- ^ "taskType" - Optional. Optional task type for which the embeddings will be used. Not supported on earlier models (&#x60;models/embedding-001&#x60;).
  , embedContentRequestContent :: !(Content)
  -- ^ /Required/ "content" - Required. The content to embed. Only the &#x60;parts.text&#x60; fields will be counted.
  , embedContentRequestOutputDimensionality :: !(Maybe Int)
  -- ^ "outputDimensionality" - Optional. Optional reduced dimension for the output embedding. If set, excessive values in the output embedding are truncated from the end. Supported by newer models since 2024 only. You cannot set this value if using the earlier model (&#x60;models/embedding-001&#x60;).
  , embedContentRequestModel :: !(Text)
  -- ^ /Required/ "model" - Required. The model&#39;s resource name. This serves as an ID for the Model to use.  This name should match a model name returned by the &#x60;ListModels&#x60; method.  Format: &#x60;models/{model}&#x60;
  , embedContentRequestTitle :: !(Maybe Text)
  -- ^ "title" - Optional. An optional title for the text. Only applicable when TaskType is &#x60;RETRIEVAL_DOCUMENT&#x60;.  Note: Specifying a &#x60;title&#x60; for &#x60;RETRIEVAL_DOCUMENT&#x60; provides better quality embeddings for retrieval.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmbedContentRequest
instance A.FromJSON EmbedContentRequest where
  parseJSON = A.withObject "EmbedContentRequest" $ \o ->
    EmbedContentRequest
      <$> (o .:? "taskType")
      <*> (o .: "content")
      <*> (o .:? "outputDimensionality")
      <*> (o .: "model")
      <*> (o .:? "title")

-- | ToJSON EmbedContentRequest
instance A.ToJSON EmbedContentRequest where
  toJSON EmbedContentRequest {..} =
    _omitNulls
      [ "taskType" .= embedContentRequestTaskType
      , "content" .= embedContentRequestContent
      , "outputDimensionality" .= embedContentRequestOutputDimensionality
      , "model" .= embedContentRequestModel
      , "title" .= embedContentRequestTitle
      ]

-- | Construct a value of type 'EmbedContentRequest' (by applying it's required fields, if any)
mkEmbedContentRequest ::
  -- | 'embedContentRequestContent': Required. The content to embed. Only the `parts.text` fields will be counted.
  Content ->
  -- | 'embedContentRequestModel': Required. The model's resource name. This serves as an ID for the Model to use.  This name should match a model name returned by the `ListModels` method.  Format: `models/{model}`
  Text ->
  EmbedContentRequest
mkEmbedContentRequest embedContentRequestContent embedContentRequestModel =
  EmbedContentRequest
    { embedContentRequestTaskType = Nothing
    , embedContentRequestContent
    , embedContentRequestOutputDimensionality = Nothing
    , embedContentRequestModel
    , embedContentRequestTitle = Nothing
    }

-- ** EmbedContentResponse

{- | EmbedContentResponse
The response to an `EmbedContentRequest`.
-}
data EmbedContentResponse = EmbedContentResponse
  { embedContentResponseEmbedding :: !(Maybe ContentEmbedding)
  -- ^ /ReadOnly/ "embedding" - Output only. The embedding generated from the input content.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmbedContentResponse
instance A.FromJSON EmbedContentResponse where
  parseJSON = A.withObject "EmbedContentResponse" $ \o ->
    EmbedContentResponse
      <$> (o .:? "embedding")

-- | ToJSON EmbedContentResponse
instance A.ToJSON EmbedContentResponse where
  toJSON EmbedContentResponse {..} =
    _omitNulls
      [ "embedding" .= embedContentResponseEmbedding
      ]

-- | Construct a value of type 'EmbedContentResponse' (by applying it's required fields, if any)
mkEmbedContentResponse ::
  EmbedContentResponse
mkEmbedContentResponse =
  EmbedContentResponse
    { embedContentResponseEmbedding = Nothing
    }

-- ** EmbedTextRequest

{- | EmbedTextRequest
Request to get a text embedding from the model.
-}
data EmbedTextRequest = EmbedTextRequest
  { embedTextRequestText :: !(Maybe Text)
  -- ^ "text" - Optional. The free-form input text that the model will turn into an embedding.
  , embedTextRequestModel :: !(Text)
  -- ^ /Required/ "model" - Required. The model name to use with the format model&#x3D;models/{model}.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmbedTextRequest
instance A.FromJSON EmbedTextRequest where
  parseJSON = A.withObject "EmbedTextRequest" $ \o ->
    EmbedTextRequest
      <$> (o .:? "text")
      <*> (o .: "model")

-- | ToJSON EmbedTextRequest
instance A.ToJSON EmbedTextRequest where
  toJSON EmbedTextRequest {..} =
    _omitNulls
      [ "text" .= embedTextRequestText
      , "model" .= embedTextRequestModel
      ]

-- | Construct a value of type 'EmbedTextRequest' (by applying it's required fields, if any)
mkEmbedTextRequest ::
  -- | 'embedTextRequestModel': Required. The model name to use with the format model=models/{model}.
  Text ->
  EmbedTextRequest
mkEmbedTextRequest embedTextRequestModel =
  EmbedTextRequest
    { embedTextRequestText = Nothing
    , embedTextRequestModel
    }

-- ** EmbedTextResponse

{- | EmbedTextResponse
The response to a EmbedTextRequest.
-}
data EmbedTextResponse = EmbedTextResponse
  { embedTextResponseEmbedding :: !(Maybe Embedding)
  -- ^ /ReadOnly/ "embedding" - Output only. The embedding generated from the input text.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmbedTextResponse
instance A.FromJSON EmbedTextResponse where
  parseJSON = A.withObject "EmbedTextResponse" $ \o ->
    EmbedTextResponse
      <$> (o .:? "embedding")

-- | ToJSON EmbedTextResponse
instance A.ToJSON EmbedTextResponse where
  toJSON EmbedTextResponse {..} =
    _omitNulls
      [ "embedding" .= embedTextResponseEmbedding
      ]

-- | Construct a value of type 'EmbedTextResponse' (by applying it's required fields, if any)
mkEmbedTextResponse ::
  EmbedTextResponse
mkEmbedTextResponse =
  EmbedTextResponse
    { embedTextResponseEmbedding = Nothing
    }

-- ** Embedding

{- | Embedding
A list of floats representing the embedding.
-}
data Embedding = Embedding
  { embeddingValue :: !(Maybe [Float])
  -- ^ "value" - The embedding values.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Embedding
instance A.FromJSON Embedding where
  parseJSON = A.withObject "Embedding" $ \o ->
    Embedding
      <$> (o .:? "value")

-- | ToJSON Embedding
instance A.ToJSON Embedding where
  toJSON Embedding {..} =
    _omitNulls
      [ "value" .= embeddingValue
      ]

-- | Construct a value of type 'Embedding' (by applying it's required fields, if any)
mkEmbedding ::
  Embedding
mkEmbedding =
  Embedding
    { embeddingValue = Nothing
    }

-- ** Example

{- | Example
An input/output example used to instruct the Model.  It demonstrates how the model should respond or format its response.
-}
data Example = Example
  { exampleOutput :: !(Message)
  -- ^ /Required/ "output" - Required. An example of what the model should output given the input.
  , exampleInput :: !(Message)
  -- ^ /Required/ "input" - Required. An example of an input &#x60;Message&#x60; from the user.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Example
instance A.FromJSON Example where
  parseJSON = A.withObject "Example" $ \o ->
    Example
      <$> (o .: "output")
      <*> (o .: "input")

-- | ToJSON Example
instance A.ToJSON Example where
  toJSON Example {..} =
    _omitNulls
      [ "output" .= exampleOutput
      , "input" .= exampleInput
      ]

-- | Construct a value of type 'Example' (by applying it's required fields, if any)
mkExample ::
  -- | 'exampleOutput': Required. An example of what the model should output given the input.
  Message ->
  -- | 'exampleInput': Required. An example of an input `Message` from the user.
  Message ->
  Example
mkExample exampleOutput exampleInput =
  Example
    { exampleOutput
    , exampleInput
    }

-- ** ExecutableCode

{- | ExecutableCode
Code generated by the model that is meant to be executed, and the result returned to the model.  Only generated when using the `CodeExecution` tool, in which the code will be automatically executed, and a corresponding `CodeExecutionResult` will also be generated.
-}
data ExecutableCode = ExecutableCode
  { executableCodeLanguage :: !(E'Language)
  -- ^ /Required/ "language" - Required. Programming language of the &#x60;code&#x60;.
  , executableCodeCode :: !(Text)
  -- ^ /Required/ "code" - Required. The code to be executed.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecutableCode
instance A.FromJSON ExecutableCode where
  parseJSON = A.withObject "ExecutableCode" $ \o ->
    ExecutableCode
      <$> (o .: "language")
      <*> (o .: "code")

-- | ToJSON ExecutableCode
instance A.ToJSON ExecutableCode where
  toJSON ExecutableCode {..} =
    _omitNulls
      [ "language" .= executableCodeLanguage
      , "code" .= executableCodeCode
      ]

-- | Construct a value of type 'ExecutableCode' (by applying it's required fields, if any)
mkExecutableCode ::
  -- | 'executableCodeLanguage': Required. Programming language of the `code`.
  E'Language ->
  -- | 'executableCodeCode': Required. The code to be executed.
  Text ->
  ExecutableCode
mkExecutableCode executableCodeLanguage executableCodeCode =
  ExecutableCode
    { executableCodeLanguage
    , executableCodeCode
    }

-- ** File

{- | File
A file uploaded to the API. Next ID: 15
-}
data File = File
  { fileUri :: !(Maybe Text)
  -- ^ /ReadOnly/ "uri" - Output only. The uri of the &#x60;File&#x60;.
  , fileName :: !(Maybe Text)
  -- ^ "name" - Immutable. Identifier. The &#x60;File&#x60; resource name. The ID (name excluding the \&quot;files/\&quot; prefix) can contain up to 40 characters that are lowercase alphanumeric or dashes (-). The ID cannot start or end with a dash. If the name is empty on create, a unique name will be generated. Example: &#x60;files/123-456&#x60;
  , fileExpirationTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "expirationTime" - Output only. The timestamp of when the &#x60;File&#x60; will be deleted. Only set if the &#x60;File&#x60; is scheduled to expire.
  , fileDisplayName :: !(Maybe Text)
  -- ^ "displayName" - Optional. The human-readable display name for the &#x60;File&#x60;. The display name must be no more than 512 characters in length, including spaces. Example: \&quot;Welcome Image\&quot;
  , fileVideoMetadata :: !(Maybe VideoFileMetadata)
  -- ^ /ReadOnly/ "videoMetadata" - Output only. Metadata for a video.
  , fileState :: !(Maybe E'State)
  -- ^ /ReadOnly/ "state" - Output only. Processing state of the File.
  , fileSource :: !(Maybe E'Source)
  -- ^ "source" - Source of the File.
  , fileMimeType :: !(Maybe Text)
  -- ^ /ReadOnly/ "mimeType" - Output only. MIME type of the file.
  , fileCreateTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "createTime" - Output only. The timestamp of when the &#x60;File&#x60; was created.
  , fileError :: !(Maybe Status)
  -- ^ /ReadOnly/ "error" - Output only. Error status if File processing failed.
  , fileDownloadUri :: !(Maybe Text)
  -- ^ /ReadOnly/ "downloadUri" - Output only. The download uri of the &#x60;File&#x60;.
  , fileSizeBytes :: !(Maybe Text)
  -- ^ /ReadOnly/ "sizeBytes" - Output only. Size of the file in bytes.
  , fileSha256Hash :: !(Maybe ByteArray)
  -- ^ /ReadOnly/ "sha256Hash" - Output only. SHA-256 hash of the uploaded bytes.
  , fileUpdateTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "updateTime" - Output only. The timestamp of when the &#x60;File&#x60; was last updated.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON File
instance A.FromJSON File where
  parseJSON = A.withObject "File" $ \o ->
    File
      <$> (o .:? "uri")
      <*> (o .:? "name")
      <*> (o .:? "expirationTime")
      <*> (o .:? "displayName")
      <*> (o .:? "videoMetadata")
      <*> (o .:? "state")
      <*> (o .:? "source")
      <*> (o .:? "mimeType")
      <*> (o .:? "createTime")
      <*> (o .:? "error")
      <*> (o .:? "downloadUri")
      <*> (o .:? "sizeBytes")
      <*> (o .:? "sha256Hash")
      <*> (o .:? "updateTime")

-- | ToJSON File
instance A.ToJSON File where
  toJSON File {..} =
    _omitNulls
      [ "uri" .= fileUri
      , "name" .= fileName
      , "expirationTime" .= fileExpirationTime
      , "displayName" .= fileDisplayName
      , "videoMetadata" .= fileVideoMetadata
      , "state" .= fileState
      , "source" .= fileSource
      , "mimeType" .= fileMimeType
      , "createTime" .= fileCreateTime
      , "error" .= fileError
      , "downloadUri" .= fileDownloadUri
      , "sizeBytes" .= fileSizeBytes
      , "sha256Hash" .= fileSha256Hash
      , "updateTime" .= fileUpdateTime
      ]

-- | Construct a value of type 'File' (by applying it's required fields, if any)
mkFile ::
  File
mkFile =
  File
    { fileUri = Nothing
    , fileName = Nothing
    , fileExpirationTime = Nothing
    , fileDisplayName = Nothing
    , fileVideoMetadata = Nothing
    , fileState = Nothing
    , fileSource = Nothing
    , fileMimeType = Nothing
    , fileCreateTime = Nothing
    , fileError = Nothing
    , fileDownloadUri = Nothing
    , fileSizeBytes = Nothing
    , fileSha256Hash = Nothing
    , fileUpdateTime = Nothing
    }

-- ** FileData

{- | FileData
URI based data.
-}
data FileData = FileData
  { fileDataMimeType :: !(Maybe Text)
  -- ^ "mimeType" - Optional. The IANA standard MIME type of the source data.
  , fileDataFileUri :: !(Text)
  -- ^ /Required/ "fileUri" - Required. URI.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FileData
instance A.FromJSON FileData where
  parseJSON = A.withObject "FileData" $ \o ->
    FileData
      <$> (o .:? "mimeType")
      <*> (o .: "fileUri")

-- | ToJSON FileData
instance A.ToJSON FileData where
  toJSON FileData {..} =
    _omitNulls
      [ "mimeType" .= fileDataMimeType
      , "fileUri" .= fileDataFileUri
      ]

-- | Construct a value of type 'FileData' (by applying it's required fields, if any)
mkFileData ::
  -- | 'fileDataFileUri': Required. URI.
  Text ->
  FileData
mkFileData fileDataFileUri =
  FileData
    { fileDataMimeType = Nothing
    , fileDataFileUri
    }

-- ** FunctionCall

{- | FunctionCall
A predicted `FunctionCall` returned from the model that contains a string representing the `FunctionDeclaration.name` with the arguments and their values.
-}
data FunctionCall = FunctionCall
  { functionCallArgs :: !(Maybe (Map.Map String String))
  -- ^ "args" - Optional. The function parameters and values in JSON object format.
  , functionCallId :: !(Maybe Text)
  -- ^ "id" - Optional. The unique id of the function call. If populated, the client to execute the &#x60;function_call&#x60; and return the response with the matching &#x60;id&#x60;.
  , functionCallName :: !(Text)
  -- ^ /Required/ "name" - Required. The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FunctionCall
instance A.FromJSON FunctionCall where
  parseJSON = A.withObject "FunctionCall" $ \o ->
    FunctionCall
      <$> (o .:? "args")
      <*> (o .:? "id")
      <*> (o .: "name")

-- | ToJSON FunctionCall
instance A.ToJSON FunctionCall where
  toJSON FunctionCall {..} =
    _omitNulls
      [ "args" .= functionCallArgs
      , "id" .= functionCallId
      , "name" .= functionCallName
      ]

-- | Construct a value of type 'FunctionCall' (by applying it's required fields, if any)
mkFunctionCall ::
  -- | 'functionCallName': Required. The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
  Text ->
  FunctionCall
mkFunctionCall functionCallName =
  FunctionCall
    { functionCallArgs = Nothing
    , functionCallId = Nothing
    , functionCallName
    }

-- ** FunctionCallingConfig

{- | FunctionCallingConfig
Configuration for specifying function calling behavior.
-}
data FunctionCallingConfig = FunctionCallingConfig
  { functionCallingConfigMode :: !(Maybe E'Mode2)
  -- ^ "mode" - Optional. Specifies the mode in which function calling should execute. If unspecified, the default value will be set to AUTO.
  , functionCallingConfigAllowedFunctionNames :: !(Maybe [Text])
  -- ^ "allowedFunctionNames" - Optional. A set of function names that, when provided, limits the functions the model will call.  This should only be set when the Mode is ANY. Function names should match [FunctionDeclaration.name]. With mode set to ANY, model will predict a function call from the set of function names provided.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FunctionCallingConfig
instance A.FromJSON FunctionCallingConfig where
  parseJSON = A.withObject "FunctionCallingConfig" $ \o ->
    FunctionCallingConfig
      <$> (o .:? "mode")
      <*> (o .:? "allowedFunctionNames")

-- | ToJSON FunctionCallingConfig
instance A.ToJSON FunctionCallingConfig where
  toJSON FunctionCallingConfig {..} =
    _omitNulls
      [ "mode" .= functionCallingConfigMode
      , "allowedFunctionNames" .= functionCallingConfigAllowedFunctionNames
      ]

-- | Construct a value of type 'FunctionCallingConfig' (by applying it's required fields, if any)
mkFunctionCallingConfig ::
  FunctionCallingConfig
mkFunctionCallingConfig =
  FunctionCallingConfig
    { functionCallingConfigMode = Nothing
    , functionCallingConfigAllowedFunctionNames = Nothing
    }

-- ** FunctionDeclaration

{- | FunctionDeclaration
Structured representation of a function declaration as defined by the [OpenAPI 3.03 specification](https://spec.openapis.org/oas/v3.0.3). Included in this declaration are the function name and parameters. This FunctionDeclaration is a representation of a block of code that can be used as a `Tool` by the model and executed by the client.
-}
data FunctionDeclaration = FunctionDeclaration
  { functionDeclarationParameters :: !(Maybe Schema)
  -- ^ "parameters" - Optional. Describes the parameters to this function. Reflects the Open API 3.03 Parameter Object string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter.
  , functionDeclarationName :: !(Text)
  -- ^ /Required/ "name" - Required. The name of the function. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
  , functionDeclarationBehavior :: !(Maybe E'Behavior)
  -- ^ "behavior" - Optional. Specifies the function Behavior. Currently only supported by the BidiGenerateContent method.
  , functionDeclarationDescription :: !(Text)
  -- ^ /Required/ "description" - Required. A brief description of the function.
  , functionDeclarationResponse :: !(Maybe Schema)
  -- ^ "response" - Optional. Describes the output from this function in JSON Schema format. Reflects the Open API 3.03 Response Object. The Schema defines the type used for the response value of the function.
  , functionDeclarationResponseJsonSchema :: !(Maybe String)
  -- ^ "responseJsonSchema" - Optional. Describes the output from this function in JSON Schema format. The value specified by the schema is the response value of the function.  This field is mutually exclusive with &#x60;response&#x60;.
  , functionDeclarationParametersJsonSchema :: !(Maybe String)
  -- ^ "parametersJsonSchema" - Optional. Describes the parameters to the function in JSON Schema format. The schema must describe an object where the properties are the parameters to the function. For example:  &#x60;&#x60;&#x60; {   \&quot;type\&quot;: \&quot;object\&quot;,   \&quot;properties\&quot;: {     \&quot;name\&quot;: { \&quot;type\&quot;: \&quot;string\&quot; },     \&quot;age\&quot;: { \&quot;type\&quot;: \&quot;integer\&quot; }   },   \&quot;additionalProperties\&quot;: false,   \&quot;required\&quot;: [\&quot;name\&quot;, \&quot;age\&quot;],   \&quot;propertyOrdering\&quot;: [\&quot;name\&quot;, \&quot;age\&quot;] } &#x60;&#x60;&#x60;  This field is mutually exclusive with &#x60;parameters&#x60;.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FunctionDeclaration
instance A.FromJSON FunctionDeclaration where
  parseJSON = A.withObject "FunctionDeclaration" $ \o ->
    FunctionDeclaration
      <$> (o .:? "parameters")
      <*> (o .: "name")
      <*> (o .:? "behavior")
      <*> (o .: "description")
      <*> (o .:? "response")
      <*> (o .:? "responseJsonSchema")
      <*> (o .:? "parametersJsonSchema")

-- | ToJSON FunctionDeclaration
instance A.ToJSON FunctionDeclaration where
  toJSON FunctionDeclaration {..} =
    _omitNulls
      [ "parameters" .= functionDeclarationParameters
      , "name" .= functionDeclarationName
      , "behavior" .= functionDeclarationBehavior
      , "description" .= functionDeclarationDescription
      , "response" .= functionDeclarationResponse
      , "responseJsonSchema" .= functionDeclarationResponseJsonSchema
      , "parametersJsonSchema" .= functionDeclarationParametersJsonSchema
      ]

-- | Construct a value of type 'FunctionDeclaration' (by applying it's required fields, if any)
mkFunctionDeclaration ::
  -- | 'functionDeclarationName': Required. The name of the function. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
  Text ->
  -- | 'functionDeclarationDescription': Required. A brief description of the function.
  Text ->
  FunctionDeclaration
mkFunctionDeclaration functionDeclarationName functionDeclarationDescription =
  FunctionDeclaration
    { functionDeclarationParameters = Nothing
    , functionDeclarationName
    , functionDeclarationBehavior = Nothing
    , functionDeclarationDescription
    , functionDeclarationResponse = Nothing
    , functionDeclarationResponseJsonSchema = Nothing
    , functionDeclarationParametersJsonSchema = Nothing
    }

-- ** FunctionResponse

{- | FunctionResponse
The result output from a `FunctionCall` that contains a string representing the `FunctionDeclaration.name` and a structured JSON object containing any output from the function is used as context to the model. This should contain the result of a`FunctionCall` made based on model prediction.
-}
data FunctionResponse = FunctionResponse
  { functionResponseScheduling :: !(Maybe E'Scheduling)
  -- ^ "scheduling" - Optional. Specifies how the response should be scheduled in the conversation. Only applicable to NON_BLOCKING function calls, is ignored otherwise. Defaults to WHEN_IDLE.
  , functionResponseId :: !(Maybe Text)
  -- ^ "id" - Optional. The id of the function call this response is for. Populated by the client to match the corresponding function call &#x60;id&#x60;.
  , functionResponseWillContinue :: !(Maybe Bool)
  -- ^ "willContinue" - Optional. Signals that function call continues, and more responses will be returned, turning the function call into a generator. Is only applicable to NON_BLOCKING function calls, is ignored otherwise. If set to false, future responses will not be considered. It is allowed to return empty &#x60;response&#x60; with &#x60;will_continue&#x3D;False&#x60; to signal that the function call is finished. This may still trigger the model generation. To avoid triggering the generation and finish the function call, additionally set &#x60;scheduling&#x60; to &#x60;SILENT&#x60;.
  , functionResponseName :: !(Text)
  -- ^ /Required/ "name" - Required. The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
  , functionResponseResponse :: !((Map.Map String String))
  -- ^ /Required/ "response" - Required. The function response in JSON object format.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FunctionResponse
instance A.FromJSON FunctionResponse where
  parseJSON = A.withObject "FunctionResponse" $ \o ->
    FunctionResponse
      <$> (o .:? "scheduling")
      <*> (o .:? "id")
      <*> (o .:? "willContinue")
      <*> (o .: "name")
      <*> (o .: "response")

-- | ToJSON FunctionResponse
instance A.ToJSON FunctionResponse where
  toJSON FunctionResponse {..} =
    _omitNulls
      [ "scheduling" .= functionResponseScheduling
      , "id" .= functionResponseId
      , "willContinue" .= functionResponseWillContinue
      , "name" .= functionResponseName
      , "response" .= functionResponseResponse
      ]

-- | Construct a value of type 'FunctionResponse' (by applying it's required fields, if any)
mkFunctionResponse ::
  -- | 'functionResponseName': Required. The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
  Text ->
  -- | 'functionResponseResponse': Required. The function response in JSON object format.
  (Map.Map String String) ->
  FunctionResponse
mkFunctionResponse functionResponseName functionResponseResponse =
  FunctionResponse
    { functionResponseScheduling = Nothing
    , functionResponseId = Nothing
    , functionResponseWillContinue = Nothing
    , functionResponseName
    , functionResponseResponse
    }

-- ** GenerateAnswerRequest

{- | GenerateAnswerRequest
Request to generate a grounded answer from the `Model`.
-}
data GenerateAnswerRequest = GenerateAnswerRequest
  { generateAnswerRequestSemanticRetriever :: !(Maybe SemanticRetrieverConfig)
  -- ^ "semanticRetriever" - Content retrieved from resources created via the Semantic Retriever API.
  , generateAnswerRequestTemperature :: !(Maybe Float)
  -- ^ "temperature" - Optional. Controls the randomness of the output.  Values can range from [0.0,1.0], inclusive. A value closer to 1.0 will produce responses that are more varied and creative, while a value closer to 0.0 will typically result in more straightforward responses from the model. A low temperature (~0.2) is usually recommended for Attributed-Question-Answering use cases.
  , generateAnswerRequestAnswerStyle :: !(E'AnswerStyle)
  -- ^ /Required/ "answerStyle" - Required. Style in which answers should be returned.
  , generateAnswerRequestContents :: !([Content])
  -- ^ /Required/ "contents" - Required. The content of the current conversation with the &#x60;Model&#x60;. For single-turn queries, this is a single question to answer. For multi-turn queries, this is a repeated field that contains conversation history and the last &#x60;Content&#x60; in the list containing the question.  Note: &#x60;GenerateAnswer&#x60; only supports queries in English.
  , generateAnswerRequestSafetySettings :: !(Maybe [SafetySetting])
  -- ^ "safetySettings" - Optional. A list of unique &#x60;SafetySetting&#x60; instances for blocking unsafe content.  This will be enforced on the &#x60;GenerateAnswerRequest.contents&#x60; and &#x60;GenerateAnswerResponse.candidate&#x60;. There should not be more than one setting for each &#x60;SafetyCategory&#x60; type. The API will block any contents and responses that fail to meet the thresholds set by these settings. This list overrides the default settings for each &#x60;SafetyCategory&#x60; specified in the safety_settings. If there is no &#x60;SafetySetting&#x60; for a given &#x60;SafetyCategory&#x60; provided in the list, the API will use the default safety setting for that category. Harm categories HARM_CATEGORY_HATE_SPEECH, HARM_CATEGORY_SEXUALLY_EXPLICIT, HARM_CATEGORY_DANGEROUS_CONTENT, HARM_CATEGORY_HARASSMENT are supported. Refer to the [guide](https://ai.google.dev/gemini-api/docs/safety-settings) for detailed information on available safety settings. Also refer to the [Safety guidance](https://ai.google.dev/gemini-api/docs/safety-guidance) to learn how to incorporate safety considerations in your AI applications.
  , generateAnswerRequestInlinePassages :: !(Maybe GroundingPassages)
  -- ^ "inlinePassages" - Passages provided inline with the request.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateAnswerRequest
instance A.FromJSON GenerateAnswerRequest where
  parseJSON = A.withObject "GenerateAnswerRequest" $ \o ->
    GenerateAnswerRequest
      <$> (o .:? "semanticRetriever")
      <*> (o .:? "temperature")
      <*> (o .: "answerStyle")
      <*> (o .: "contents")
      <*> (o .:? "safetySettings")
      <*> (o .:? "inlinePassages")

-- | ToJSON GenerateAnswerRequest
instance A.ToJSON GenerateAnswerRequest where
  toJSON GenerateAnswerRequest {..} =
    _omitNulls
      [ "semanticRetriever" .= generateAnswerRequestSemanticRetriever
      , "temperature" .= generateAnswerRequestTemperature
      , "answerStyle" .= generateAnswerRequestAnswerStyle
      , "contents" .= generateAnswerRequestContents
      , "safetySettings" .= generateAnswerRequestSafetySettings
      , "inlinePassages" .= generateAnswerRequestInlinePassages
      ]

-- | Construct a value of type 'GenerateAnswerRequest' (by applying it's required fields, if any)
mkGenerateAnswerRequest ::
  -- | 'generateAnswerRequestAnswerStyle': Required. Style in which answers should be returned.
  E'AnswerStyle ->
  -- | 'generateAnswerRequestContents': Required. The content of the current conversation with the `Model`. For single-turn queries, this is a single question to answer. For multi-turn queries, this is a repeated field that contains conversation history and the last `Content` in the list containing the question.  Note: `GenerateAnswer` only supports queries in English.
  [Content] ->
  GenerateAnswerRequest
mkGenerateAnswerRequest generateAnswerRequestAnswerStyle generateAnswerRequestContents =
  GenerateAnswerRequest
    { generateAnswerRequestSemanticRetriever = Nothing
    , generateAnswerRequestTemperature = Nothing
    , generateAnswerRequestAnswerStyle
    , generateAnswerRequestContents
    , generateAnswerRequestSafetySettings = Nothing
    , generateAnswerRequestInlinePassages = Nothing
    }

-- ** GenerateAnswerResponse

{- | GenerateAnswerResponse
Response from the model for a grounded answer.
-}
data GenerateAnswerResponse = GenerateAnswerResponse
  { generateAnswerResponseAnswer :: !(Maybe Candidate)
  -- ^ "answer" - Candidate answer from the model.  Note: The model *always* attempts to provide a grounded answer, even when the answer is unlikely to be answerable from the given passages. In that case, a low-quality or ungrounded answer may be provided, along with a low &#x60;answerable_probability&#x60;.
  , generateAnswerResponseInputFeedback :: !(Maybe InputFeedback)
  -- ^ /ReadOnly/ "inputFeedback" - Output only. Feedback related to the input data used to answer the question, as opposed to the model-generated response to the question.  The input data can be one or more of the following:  - Question specified by the last entry in &#x60;GenerateAnswerRequest.content&#x60; - Conversation history specified by the other entries in &#x60;GenerateAnswerRequest.content&#x60; - Grounding sources (&#x60;GenerateAnswerRequest.semantic_retriever&#x60; or &#x60;GenerateAnswerRequest.inline_passages&#x60;)
  , generateAnswerResponseAnswerableProbability :: !(Maybe Float)
  -- ^ /ReadOnly/ "answerableProbability" - Output only. The model&#39;s estimate of the probability that its answer is correct and grounded in the input passages.  A low &#x60;answerable_probability&#x60; indicates that the answer might not be grounded in the sources.  When &#x60;answerable_probability&#x60; is low, you may want to:  * Display a message to the effect of \&quot;We couldn’t answer that question\&quot; to the user. * Fall back to a general-purpose LLM that answers the question from world knowledge. The threshold and nature of such fallbacks will depend on individual use cases. &#x60;0.5&#x60; is a good starting threshold.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateAnswerResponse
instance A.FromJSON GenerateAnswerResponse where
  parseJSON = A.withObject "GenerateAnswerResponse" $ \o ->
    GenerateAnswerResponse
      <$> (o .:? "answer")
      <*> (o .:? "inputFeedback")
      <*> (o .:? "answerableProbability")

-- | ToJSON GenerateAnswerResponse
instance A.ToJSON GenerateAnswerResponse where
  toJSON GenerateAnswerResponse {..} =
    _omitNulls
      [ "answer" .= generateAnswerResponseAnswer
      , "inputFeedback" .= generateAnswerResponseInputFeedback
      , "answerableProbability" .= generateAnswerResponseAnswerableProbability
      ]

-- | Construct a value of type 'GenerateAnswerResponse' (by applying it's required fields, if any)
mkGenerateAnswerResponse ::
  GenerateAnswerResponse
mkGenerateAnswerResponse =
  GenerateAnswerResponse
    { generateAnswerResponseAnswer = Nothing
    , generateAnswerResponseInputFeedback = Nothing
    , generateAnswerResponseAnswerableProbability = Nothing
    }

-- ** GenerateContentRequest

{- | GenerateContentRequest
Request to generate a completion from the model. NEXT ID: 13
-}
data GenerateContentRequest = GenerateContentRequest
  { generateContentRequestToolConfig :: !(Maybe ToolConfig)
  -- ^ "toolConfig" - Optional. Tool configuration for any &#x60;Tool&#x60; specified in the request. Refer to the [Function calling guide](https://ai.google.dev/gemini-api/docs/function-calling#function_calling_mode) for a usage example.
  , generateContentRequestTools :: !(Maybe [Tool])
  -- ^ "tools" - Optional. A list of &#x60;Tools&#x60; the &#x60;Model&#x60; may use to generate the next response.  A &#x60;Tool&#x60; is a piece of code that enables the system to interact with external systems to perform an action, or set of actions, outside of knowledge and scope of the &#x60;Model&#x60;. Supported &#x60;Tool&#x60;s are &#x60;Function&#x60; and &#x60;code_execution&#x60;. Refer to the [Function calling](https://ai.google.dev/gemini-api/docs/function-calling) and the [Code execution](https://ai.google.dev/gemini-api/docs/code-execution) guides to learn more.
  , generateContentRequestContents :: !([Content])
  -- ^ /Required/ "contents" - Required. The content of the current conversation with the model.  For single-turn queries, this is a single instance. For multi-turn queries like [chat](https://ai.google.dev/gemini-api/docs/text-generation#chat), this is a repeated field that contains the conversation history and the latest request.
  , generateContentRequestSystemInstruction :: !(Maybe Content)
  -- ^ "systemInstruction" - Optional. Developer set [system instruction(s)](https://ai.google.dev/gemini-api/docs/system-instructions). Currently, text only.
  , generateContentRequestCachedContent :: !(Maybe Text)
  -- ^ "cachedContent" - Optional. The name of the content [cached](https://ai.google.dev/gemini-api/docs/caching) to use as context to serve the prediction. Format: &#x60;cachedContents/{cachedContent}&#x60;
  , generateContentRequestSafetySettings :: !(Maybe [SafetySetting])
  -- ^ "safetySettings" - Optional. A list of unique &#x60;SafetySetting&#x60; instances for blocking unsafe content.  This will be enforced on the &#x60;GenerateContentRequest.contents&#x60; and &#x60;GenerateContentResponse.candidates&#x60;. There should not be more than one setting for each &#x60;SafetyCategory&#x60; type. The API will block any contents and responses that fail to meet the thresholds set by these settings. This list overrides the default settings for each &#x60;SafetyCategory&#x60; specified in the safety_settings. If there is no &#x60;SafetySetting&#x60; for a given &#x60;SafetyCategory&#x60; provided in the list, the API will use the default safety setting for that category. Harm categories HARM_CATEGORY_HATE_SPEECH, HARM_CATEGORY_SEXUALLY_EXPLICIT, HARM_CATEGORY_DANGEROUS_CONTENT, HARM_CATEGORY_HARASSMENT, HARM_CATEGORY_CIVIC_INTEGRITY are supported. Refer to the [guide](https://ai.google.dev/gemini-api/docs/safety-settings) for detailed information on available safety settings. Also refer to the [Safety guidance](https://ai.google.dev/gemini-api/docs/safety-guidance) to learn how to incorporate safety considerations in your AI applications.
  , generateContentRequestModel :: !(Text)
  -- ^ /Required/ "model" - Required. The name of the &#x60;Model&#x60; to use for generating the completion.  Format: &#x60;models/{model}&#x60;.
  , generateContentRequestGenerationConfig :: !(Maybe GenerationConfig)
  -- ^ "generationConfig" - Optional. Configuration options for model generation and outputs.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateContentRequest
instance A.FromJSON GenerateContentRequest where
  parseJSON = A.withObject "GenerateContentRequest" $ \o ->
    GenerateContentRequest
      <$> (o .:? "toolConfig")
      <*> (o .:? "tools")
      <*> (o .: "contents")
      <*> (o .:? "systemInstruction")
      <*> (o .:? "cachedContent")
      <*> (o .:? "safetySettings")
      <*> (o .: "model")
      <*> (o .:? "generationConfig")

-- | ToJSON GenerateContentRequest
instance A.ToJSON GenerateContentRequest where
  toJSON GenerateContentRequest {..} =
    _omitNulls
      [ "toolConfig" .= generateContentRequestToolConfig
      , "tools" .= generateContentRequestTools
      , "contents" .= generateContentRequestContents
      , "systemInstruction" .= generateContentRequestSystemInstruction
      , "cachedContent" .= generateContentRequestCachedContent
      , "safetySettings" .= generateContentRequestSafetySettings
      , "model" .= generateContentRequestModel
      , "generationConfig" .= generateContentRequestGenerationConfig
      ]

-- | Construct a value of type 'GenerateContentRequest' (by applying it's required fields, if any)
mkGenerateContentRequest ::
  -- | 'generateContentRequestContents': Required. The content of the current conversation with the model.  For single-turn queries, this is a single instance. For multi-turn queries like [chat](https://ai.google.dev/gemini-api/docs/text-generation#chat), this is a repeated field that contains the conversation history and the latest request.
  [Content] ->
  -- | 'generateContentRequestModel': Required. The name of the `Model` to use for generating the completion.  Format: `models/{model}`.
  Text ->
  GenerateContentRequest
mkGenerateContentRequest generateContentRequestContents generateContentRequestModel =
  GenerateContentRequest
    { generateContentRequestToolConfig = Nothing
    , generateContentRequestTools = Nothing
    , generateContentRequestContents
    , generateContentRequestSystemInstruction = Nothing
    , generateContentRequestCachedContent = Nothing
    , generateContentRequestSafetySettings = Nothing
    , generateContentRequestModel
    , generateContentRequestGenerationConfig = Nothing
    }

-- ** GenerateContentResponse

{- | GenerateContentResponse
Response from the model supporting multiple candidate responses.  Safety ratings and content filtering are reported for both prompt in `GenerateContentResponse.prompt_feedback` and for each candidate in `finish_reason` and in `safety_ratings`. The API:  - Returns either all requested candidates or none of them  - Returns no candidates at all only if there was something wrong with the    prompt (check `prompt_feedback`)  - Reports feedback on each candidate in `finish_reason` and    `safety_ratings`.
-}
data GenerateContentResponse = GenerateContentResponse
  { generateContentResponseCandidates :: !(Maybe [Candidate])
  -- ^ "candidates" - Candidate responses from the model.
  , generateContentResponseUsageMetadata :: !(Maybe UsageMetadata)
  -- ^ /ReadOnly/ "usageMetadata" - Output only. Metadata on the generation requests&#39; token usage.
  , generateContentResponseModelVersion :: !(Maybe Text)
  -- ^ /ReadOnly/ "modelVersion" - Output only. The model version used to generate the response.
  , generateContentResponsePromptFeedback :: !(Maybe PromptFeedback)
  -- ^ "promptFeedback" - Returns the prompt&#39;s feedback related to the content filters.
  , generateContentResponseResponseId :: !(Maybe Text)
  -- ^ /ReadOnly/ "responseId" - Output only. response_id is used to identify each response.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateContentResponse
instance A.FromJSON GenerateContentResponse where
  parseJSON = A.withObject "GenerateContentResponse" $ \o ->
    GenerateContentResponse
      <$> (o .:? "candidates")
      <*> (o .:? "usageMetadata")
      <*> (o .:? "modelVersion")
      <*> (o .:? "promptFeedback")
      <*> (o .:? "responseId")

-- | ToJSON GenerateContentResponse
instance A.ToJSON GenerateContentResponse where
  toJSON GenerateContentResponse {..} =
    _omitNulls
      [ "candidates" .= generateContentResponseCandidates
      , "usageMetadata" .= generateContentResponseUsageMetadata
      , "modelVersion" .= generateContentResponseModelVersion
      , "promptFeedback" .= generateContentResponsePromptFeedback
      , "responseId" .= generateContentResponseResponseId
      ]

-- | Construct a value of type 'GenerateContentResponse' (by applying it's required fields, if any)
mkGenerateContentResponse ::
  GenerateContentResponse
mkGenerateContentResponse =
  GenerateContentResponse
    { generateContentResponseCandidates = Nothing
    , generateContentResponseUsageMetadata = Nothing
    , generateContentResponseModelVersion = Nothing
    , generateContentResponsePromptFeedback = Nothing
    , generateContentResponseResponseId = Nothing
    }

-- ** GenerateMessageRequest

{- | GenerateMessageRequest
Request to generate a message response from the model.
-}
data GenerateMessageRequest = GenerateMessageRequest
  { generateMessageRequestTemperature :: !(Maybe Float)
  -- ^ "temperature" - Optional. Controls the randomness of the output.  Values can range over &#x60;[0.0,1.0]&#x60;, inclusive. A value closer to &#x60;1.0&#x60; will produce responses that are more varied, while a value closer to &#x60;0.0&#x60; will typically result in less surprising responses from the model.
  , generateMessageRequestTopP :: !(Maybe Float)
  -- ^ "topP" - Optional. The maximum cumulative probability of tokens to consider when sampling.  The model uses combined Top-k and nucleus sampling.  Nucleus sampling considers the smallest set of tokens whose probability sum is at least &#x60;top_p&#x60;.
  , generateMessageRequestCandidateCount :: !(Maybe Int)
  -- ^ "candidateCount" - Optional. The number of generated response messages to return.  This value must be between &#x60;[1, 8]&#x60;, inclusive. If unset, this will default to &#x60;1&#x60;.
  , generateMessageRequestTopK :: !(Maybe Int)
  -- ^ "topK" - Optional. The maximum number of tokens to consider when sampling.  The model uses combined Top-k and nucleus sampling.  Top-k sampling considers the set of &#x60;top_k&#x60; most probable tokens.
  , generateMessageRequestPrompt :: !(MessagePrompt)
  -- ^ /Required/ "prompt" - Required. The structured textual input given to the model as a prompt.  Given a prompt, the model will return what it predicts is the next message in the discussion.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateMessageRequest
instance A.FromJSON GenerateMessageRequest where
  parseJSON = A.withObject "GenerateMessageRequest" $ \o ->
    GenerateMessageRequest
      <$> (o .:? "temperature")
      <*> (o .:? "topP")
      <*> (o .:? "candidateCount")
      <*> (o .:? "topK")
      <*> (o .: "prompt")

-- | ToJSON GenerateMessageRequest
instance A.ToJSON GenerateMessageRequest where
  toJSON GenerateMessageRequest {..} =
    _omitNulls
      [ "temperature" .= generateMessageRequestTemperature
      , "topP" .= generateMessageRequestTopP
      , "candidateCount" .= generateMessageRequestCandidateCount
      , "topK" .= generateMessageRequestTopK
      , "prompt" .= generateMessageRequestPrompt
      ]

-- | Construct a value of type 'GenerateMessageRequest' (by applying it's required fields, if any)
mkGenerateMessageRequest ::
  -- | 'generateMessageRequestPrompt': Required. The structured textual input given to the model as a prompt.  Given a prompt, the model will return what it predicts is the next message in the discussion.
  MessagePrompt ->
  GenerateMessageRequest
mkGenerateMessageRequest generateMessageRequestPrompt =
  GenerateMessageRequest
    { generateMessageRequestTemperature = Nothing
    , generateMessageRequestTopP = Nothing
    , generateMessageRequestCandidateCount = Nothing
    , generateMessageRequestTopK = Nothing
    , generateMessageRequestPrompt
    }

-- ** GenerateMessageResponse

{- | GenerateMessageResponse
The response from the model.  This includes candidate messages and conversation history in the form of chronologically-ordered messages.
-}
data GenerateMessageResponse = GenerateMessageResponse
  { generateMessageResponseCandidates :: !(Maybe [Message])
  -- ^ "candidates" - Candidate response messages from the model.
  , generateMessageResponseMessages :: !(Maybe [Message])
  -- ^ "messages" - The conversation history used by the model.
  , generateMessageResponseFilters :: !(Maybe [ContentFilter])
  -- ^ "filters" - A set of content filtering metadata for the prompt and response text.  This indicates which &#x60;SafetyCategory&#x60;(s) blocked a candidate from this response, the lowest &#x60;HarmProbability&#x60; that triggered a block, and the HarmThreshold setting for that category.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateMessageResponse
instance A.FromJSON GenerateMessageResponse where
  parseJSON = A.withObject "GenerateMessageResponse" $ \o ->
    GenerateMessageResponse
      <$> (o .:? "candidates")
      <*> (o .:? "messages")
      <*> (o .:? "filters")

-- | ToJSON GenerateMessageResponse
instance A.ToJSON GenerateMessageResponse where
  toJSON GenerateMessageResponse {..} =
    _omitNulls
      [ "candidates" .= generateMessageResponseCandidates
      , "messages" .= generateMessageResponseMessages
      , "filters" .= generateMessageResponseFilters
      ]

-- | Construct a value of type 'GenerateMessageResponse' (by applying it's required fields, if any)
mkGenerateMessageResponse ::
  GenerateMessageResponse
mkGenerateMessageResponse =
  GenerateMessageResponse
    { generateMessageResponseCandidates = Nothing
    , generateMessageResponseMessages = Nothing
    , generateMessageResponseFilters = Nothing
    }

-- ** GenerateTextRequest

{- | GenerateTextRequest
Request to generate a text completion response from the model.
-}
data GenerateTextRequest = GenerateTextRequest
  { generateTextRequestStopSequences :: !(Maybe [Text])
  -- ^ "stopSequences" - The set of character sequences (up to 5) that will stop output generation. If specified, the API will stop at the first appearance of a stop sequence. The stop sequence will not be included as part of the response.
  , generateTextRequestPrompt :: !(TextPrompt)
  -- ^ /Required/ "prompt" - Required. The free-form input text given to the model as a prompt.  Given a prompt, the model will generate a TextCompletion response it predicts as the completion of the input text.
  , generateTextRequestMaxOutputTokens :: !(Maybe Int)
  -- ^ "maxOutputTokens" - Optional. The maximum number of tokens to include in a candidate.  If unset, this will default to output_token_limit specified in the &#x60;Model&#x60; specification.
  , generateTextRequestSafetySettings :: !(Maybe [SafetySetting])
  -- ^ "safetySettings" - Optional. A list of unique &#x60;SafetySetting&#x60; instances for blocking unsafe content.  that will be enforced on the &#x60;GenerateTextRequest.prompt&#x60; and &#x60;GenerateTextResponse.candidates&#x60;. There should not be more than one setting for each &#x60;SafetyCategory&#x60; type. The API will block any prompts and responses that fail to meet the thresholds set by these settings. This list overrides the default settings for each &#x60;SafetyCategory&#x60; specified in the safety_settings. If there is no &#x60;SafetySetting&#x60; for a given &#x60;SafetyCategory&#x60; provided in the list, the API will use the default safety setting for that category. Harm categories HARM_CATEGORY_DEROGATORY, HARM_CATEGORY_TOXICITY, HARM_CATEGORY_VIOLENCE, HARM_CATEGORY_SEXUAL, HARM_CATEGORY_MEDICAL, HARM_CATEGORY_DANGEROUS are supported in text service.
  , generateTextRequestTemperature :: !(Maybe Float)
  -- ^ "temperature" - Optional. Controls the randomness of the output. Note: The default value varies by model, see the &#x60;Model.temperature&#x60; attribute of the &#x60;Model&#x60; returned the &#x60;getModel&#x60; function.  Values can range from [0.0,1.0], inclusive. A value closer to 1.0 will produce responses that are more varied and creative, while a value closer to 0.0 will typically result in more straightforward responses from the model.
  , generateTextRequestTopK :: !(Maybe Int)
  -- ^ "topK" - Optional. The maximum number of tokens to consider when sampling.  The model uses combined Top-k and nucleus sampling.  Top-k sampling considers the set of &#x60;top_k&#x60; most probable tokens. Defaults to 40.  Note: The default value varies by model, see the &#x60;Model.top_k&#x60; attribute of the &#x60;Model&#x60; returned the &#x60;getModel&#x60; function.
  , generateTextRequestTopP :: !(Maybe Float)
  -- ^ "topP" - Optional. The maximum cumulative probability of tokens to consider when sampling.  The model uses combined Top-k and nucleus sampling.  Tokens are sorted based on their assigned probabilities so that only the most likely tokens are considered. Top-k sampling directly limits the maximum number of tokens to consider, while Nucleus sampling limits number of tokens based on the cumulative probability.  Note: The default value varies by model, see the &#x60;Model.top_p&#x60; attribute of the &#x60;Model&#x60; returned the &#x60;getModel&#x60; function.
  , generateTextRequestCandidateCount :: !(Maybe Int)
  -- ^ "candidateCount" - Optional. Number of generated responses to return.  This value must be between [1, 8], inclusive. If unset, this will default to 1.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateTextRequest
instance A.FromJSON GenerateTextRequest where
  parseJSON = A.withObject "GenerateTextRequest" $ \o ->
    GenerateTextRequest
      <$> (o .:? "stopSequences")
      <*> (o .: "prompt")
      <*> (o .:? "maxOutputTokens")
      <*> (o .:? "safetySettings")
      <*> (o .:? "temperature")
      <*> (o .:? "topK")
      <*> (o .:? "topP")
      <*> (o .:? "candidateCount")

-- | ToJSON GenerateTextRequest
instance A.ToJSON GenerateTextRequest where
  toJSON GenerateTextRequest {..} =
    _omitNulls
      [ "stopSequences" .= generateTextRequestStopSequences
      , "prompt" .= generateTextRequestPrompt
      , "maxOutputTokens" .= generateTextRequestMaxOutputTokens
      , "safetySettings" .= generateTextRequestSafetySettings
      , "temperature" .= generateTextRequestTemperature
      , "topK" .= generateTextRequestTopK
      , "topP" .= generateTextRequestTopP
      , "candidateCount" .= generateTextRequestCandidateCount
      ]

-- | Construct a value of type 'GenerateTextRequest' (by applying it's required fields, if any)
mkGenerateTextRequest ::
  -- | 'generateTextRequestPrompt': Required. The free-form input text given to the model as a prompt.  Given a prompt, the model will generate a TextCompletion response it predicts as the completion of the input text.
  TextPrompt ->
  GenerateTextRequest
mkGenerateTextRequest generateTextRequestPrompt =
  GenerateTextRequest
    { generateTextRequestStopSequences = Nothing
    , generateTextRequestPrompt
    , generateTextRequestMaxOutputTokens = Nothing
    , generateTextRequestSafetySettings = Nothing
    , generateTextRequestTemperature = Nothing
    , generateTextRequestTopK = Nothing
    , generateTextRequestTopP = Nothing
    , generateTextRequestCandidateCount = Nothing
    }

-- ** GenerateTextResponse

{- | GenerateTextResponse
The response from the model, including candidate completions.
-}
data GenerateTextResponse = GenerateTextResponse
  { generateTextResponseSafetyFeedback :: !(Maybe [SafetyFeedback])
  -- ^ "safetyFeedback" - Returns any safety feedback related to content filtering.
  , generateTextResponseCandidates :: !(Maybe [TextCompletion])
  -- ^ "candidates" - Candidate responses from the model.
  , generateTextResponseFilters :: !(Maybe [ContentFilter])
  -- ^ "filters" - A set of content filtering metadata for the prompt and response text.  This indicates which &#x60;SafetyCategory&#x60;(s) blocked a candidate from this response, the lowest &#x60;HarmProbability&#x60; that triggered a block, and the HarmThreshold setting for that category. This indicates the smallest change to the &#x60;SafetySettings&#x60; that would be necessary to unblock at least 1 response.  The blocking is configured by the &#x60;SafetySettings&#x60; in the request (or the default &#x60;SafetySettings&#x60; of the API).
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateTextResponse
instance A.FromJSON GenerateTextResponse where
  parseJSON = A.withObject "GenerateTextResponse" $ \o ->
    GenerateTextResponse
      <$> (o .:? "safetyFeedback")
      <*> (o .:? "candidates")
      <*> (o .:? "filters")

-- | ToJSON GenerateTextResponse
instance A.ToJSON GenerateTextResponse where
  toJSON GenerateTextResponse {..} =
    _omitNulls
      [ "safetyFeedback" .= generateTextResponseSafetyFeedback
      , "candidates" .= generateTextResponseCandidates
      , "filters" .= generateTextResponseFilters
      ]

-- | Construct a value of type 'GenerateTextResponse' (by applying it's required fields, if any)
mkGenerateTextResponse ::
  GenerateTextResponse
mkGenerateTextResponse =
  GenerateTextResponse
    { generateTextResponseSafetyFeedback = Nothing
    , generateTextResponseCandidates = Nothing
    , generateTextResponseFilters = Nothing
    }

-- ** GenerateVideoResponse

{- | GenerateVideoResponse
Veo response.
-}
data GenerateVideoResponse = GenerateVideoResponse
  { generateVideoResponseGeneratedSamples :: !(Maybe [Media])
  -- ^ "generatedSamples" - The generated samples.
  , generateVideoResponseRaiMediaFilteredCount :: !(Maybe Int)
  -- ^ "raiMediaFilteredCount" - Returns if any videos were filtered due to RAI policies.
  , generateVideoResponseRaiMediaFilteredReasons :: !(Maybe [Text])
  -- ^ "raiMediaFilteredReasons" - Returns rai failure reasons if any.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateVideoResponse
instance A.FromJSON GenerateVideoResponse where
  parseJSON = A.withObject "GenerateVideoResponse" $ \o ->
    GenerateVideoResponse
      <$> (o .:? "generatedSamples")
      <*> (o .:? "raiMediaFilteredCount")
      <*> (o .:? "raiMediaFilteredReasons")

-- | ToJSON GenerateVideoResponse
instance A.ToJSON GenerateVideoResponse where
  toJSON GenerateVideoResponse {..} =
    _omitNulls
      [ "generatedSamples" .= generateVideoResponseGeneratedSamples
      , "raiMediaFilteredCount" .= generateVideoResponseRaiMediaFilteredCount
      , "raiMediaFilteredReasons" .= generateVideoResponseRaiMediaFilteredReasons
      ]

-- | Construct a value of type 'GenerateVideoResponse' (by applying it's required fields, if any)
mkGenerateVideoResponse ::
  GenerateVideoResponse
mkGenerateVideoResponse =
  GenerateVideoResponse
    { generateVideoResponseGeneratedSamples = Nothing
    , generateVideoResponseRaiMediaFilteredCount = Nothing
    , generateVideoResponseRaiMediaFilteredReasons = Nothing
    }

-- ** GeneratedFile

{- | GeneratedFile
A file generated on behalf of a user.
-}
data GeneratedFile = GeneratedFile
  { generatedFileError :: !(Maybe Status)
  -- ^ "error" - Error details if the GeneratedFile ends up in the STATE_FAILED state.
  , generatedFileName :: !(Maybe Text)
  -- ^ "name" - Identifier. The name of the generated file. Example: &#x60;generatedFiles/abc-123&#x60;
  , generatedFileState :: !(Maybe E'State2)
  -- ^ /ReadOnly/ "state" - Output only. The state of the GeneratedFile.
  , generatedFileMimeType :: !(Maybe Text)
  -- ^ "mimeType" - MIME type of the generatedFile.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GeneratedFile
instance A.FromJSON GeneratedFile where
  parseJSON = A.withObject "GeneratedFile" $ \o ->
    GeneratedFile
      <$> (o .:? "error")
      <*> (o .:? "name")
      <*> (o .:? "state")
      <*> (o .:? "mimeType")

-- | ToJSON GeneratedFile
instance A.ToJSON GeneratedFile where
  toJSON GeneratedFile {..} =
    _omitNulls
      [ "error" .= generatedFileError
      , "name" .= generatedFileName
      , "state" .= generatedFileState
      , "mimeType" .= generatedFileMimeType
      ]

-- | Construct a value of type 'GeneratedFile' (by applying it's required fields, if any)
mkGeneratedFile ::
  GeneratedFile
mkGeneratedFile =
  GeneratedFile
    { generatedFileError = Nothing
    , generatedFileName = Nothing
    , generatedFileState = Nothing
    , generatedFileMimeType = Nothing
    }

-- ** GenerationConfig

{- | GenerationConfig
Configuration options for model generation and outputs. Not all parameters are configurable for every model.
-}
data GenerationConfig = GenerationConfig
  { generationConfigResponseSchema :: !(Maybe Schema)
  -- ^ "responseSchema" - Optional. Output schema of the generated candidate text. Schemas must be a subset of the [OpenAPI schema](https://spec.openapis.org/oas/v3.0.3#schema) and can be objects, primitives or arrays.  If set, a compatible &#x60;response_mime_type&#x60; must also be set. Compatible MIME types: &#x60;application/json&#x60;: Schema for JSON response. Refer to the [JSON text generation guide](https://ai.google.dev/gemini-api/docs/json-mode) for more details.
  , generationConfigThinkingConfig :: !(Maybe ThinkingConfig)
  -- ^ "thinkingConfig" - Optional. Config for thinking features. An error will be returned if this field is set for models that don&#39;t support thinking.
  , generationConfigLogprobs :: !(Maybe Int)
  -- ^ "logprobs" - Optional. Only valid if response_logprobs&#x3D;True. This sets the number of top logprobs to return at each decoding step in the Candidate.logprobs_result.
  , generationConfigMediaResolution :: !(Maybe E'MediaResolution)
  -- ^ "mediaResolution" - Optional. If specified, the media resolution specified will be used.
  , generationConfigStopSequences :: !(Maybe [Text])
  -- ^ "stopSequences" - Optional. The set of character sequences (up to 5) that will stop output generation. If specified, the API will stop at the first appearance of a &#x60;stop_sequence&#x60;. The stop sequence will not be included as part of the response.
  , generationConfigSpeechConfig :: !(Maybe SpeechConfig)
  -- ^ "speechConfig" - Optional. The speech generation config.
  , generationConfigResponseJsonSchema :: !(Maybe String)
  -- ^ "responseJsonSchema" - Optional. Output schema of the generated response. This is an alternative to &#x60;response_schema&#x60; that accepts [JSON Schema](https://json-schema.org/).  If set, &#x60;response_schema&#x60; must be omitted, but &#x60;response_mime_type&#x60; is required.  While the full JSON Schema may be sent, not all features are supported. Specifically, only the following properties are supported:  - &#x60;$id&#x60; - &#x60;$defs&#x60; - &#x60;$ref&#x60; - &#x60;$anchor&#x60; - &#x60;type&#x60; - &#x60;format&#x60; - &#x60;title&#x60; - &#x60;description&#x60; - &#x60;enum&#x60; (for strings and numbers) - &#x60;items&#x60; - &#x60;prefixItems&#x60; - &#x60;minItems&#x60; - &#x60;maxItems&#x60; - &#x60;minimum&#x60; - &#x60;maximum&#x60; - &#x60;anyOf&#x60; - &#x60;oneOf&#x60; (interpreted the same as &#x60;anyOf&#x60;) - &#x60;properties&#x60; - &#x60;additionalProperties&#x60; - &#x60;required&#x60;  The non-standard &#x60;propertyOrdering&#x60; property may also be set.  Cyclic references are unrolled to a limited degree and, as such, may only be used within non-required properties. (Nullable properties are not sufficient.) If &#x60;$ref&#x60; is set on a sub-schema, no other properties, except for than those starting as a &#x60;$&#x60;, may be set.
  , generationConfigPresencePenalty :: !(Maybe Float)
  -- ^ "presencePenalty" - Optional. Presence penalty applied to the next token&#39;s logprobs if the token has already been seen in the response.  This penalty is binary on/off and not dependant on the number of times the token is used (after the first). Use frequency_penalty for a penalty that increases with each use.  A positive penalty will discourage the use of tokens that have already been used in the response, increasing the vocabulary.  A negative penalty will encourage the use of tokens that have already been used in the response, decreasing the vocabulary.
  , generationConfigTopP :: !(Maybe Float)
  -- ^ "topP" - Optional. The maximum cumulative probability of tokens to consider when sampling.  The model uses combined Top-k and Top-p (nucleus) sampling.  Tokens are sorted based on their assigned probabilities so that only the most likely tokens are considered. Top-k sampling directly limits the maximum number of tokens to consider, while Nucleus sampling limits the number of tokens based on the cumulative probability.  Note: The default value varies by &#x60;Model&#x60; and is specified by the&#x60;Model.top_p&#x60; attribute returned from the &#x60;getModel&#x60; function. An empty &#x60;top_k&#x60; attribute indicates that the model doesn&#39;t apply top-k sampling and doesn&#39;t allow setting &#x60;top_k&#x60; on requests.
  , generationConfigTemperature :: !(Maybe Float)
  -- ^ "temperature" - Optional. Controls the randomness of the output.  Note: The default value varies by model, see the &#x60;Model.temperature&#x60; attribute of the &#x60;Model&#x60; returned from the &#x60;getModel&#x60; function.  Values can range from [0.0, 2.0].
  , generationConfigTopK :: !(Maybe Int)
  -- ^ "topK" - Optional. The maximum number of tokens to consider when sampling.  Gemini models use Top-p (nucleus) sampling or a combination of Top-k and nucleus sampling. Top-k sampling considers the set of &#x60;top_k&#x60; most probable tokens. Models running with nucleus sampling don&#39;t allow top_k setting.  Note: The default value varies by &#x60;Model&#x60; and is specified by the&#x60;Model.top_p&#x60; attribute returned from the &#x60;getModel&#x60; function. An empty &#x60;top_k&#x60; attribute indicates that the model doesn&#39;t apply top-k sampling and doesn&#39;t allow setting &#x60;top_k&#x60; on requests.
  , generationConfigCandidateCount :: !(Maybe Int)
  -- ^ "candidateCount" - Optional. Number of generated responses to return. If unset, this will default to 1. Please note that this doesn&#39;t work for previous generation models (Gemini 1.0 family)
  , generationConfigEnableEnhancedCivicAnswers :: !(Maybe Bool)
  -- ^ "enableEnhancedCivicAnswers" - Optional. Enables enhanced civic answers. It may not be available for all models.
  , generationConfigResponseLogprobs :: !(Maybe Bool)
  -- ^ "responseLogprobs" - Optional. If true, export the logprobs results in response.
  , generationConfigResponseModalities :: !(Maybe [E'ResponseModalities])
  -- ^ "responseModalities" - Optional. The requested modalities of the response. Represents the set of modalities that the model can return, and should be expected in the response. This is an exact match to the modalities of the response.  A model may have multiple combinations of supported modalities. If the requested modalities do not match any of the supported combinations, an error will be returned.  An empty list is equivalent to requesting only text.
  , generationConfigFrequencyPenalty :: !(Maybe Float)
  -- ^ "frequencyPenalty" - Optional. Frequency penalty applied to the next token&#39;s logprobs, multiplied by the number of times each token has been seen in the respponse so far.  A positive penalty will discourage the use of tokens that have already been used, proportional to the number of times the token has been used: The more a token is used, the more difficult it is for the model to use that token again increasing the vocabulary of responses.  Caution: A _negative_ penalty will encourage the model to reuse tokens proportional to the number of times the token has been used. Small negative values will reduce the vocabulary of a response. Larger negative values will cause the model to start repeating a common token  until it hits the max_output_tokens limit.
  , generationConfigSeed :: !(Maybe Int)
  -- ^ "seed" - Optional. Seed used in decoding. If not set, the request uses a randomly generated seed.
  , generationConfigMaxOutputTokens :: !(Maybe Int)
  -- ^ "maxOutputTokens" - Optional. The maximum number of tokens to include in a response candidate.  Note: The default value varies by model, see the &#x60;Model.output_token_limit&#x60; attribute of the &#x60;Model&#x60; returned from the &#x60;getModel&#x60; function.
  , generationConfigResponseMimeType :: !(Maybe Text)
  -- ^ "responseMimeType" - Optional. MIME type of the generated candidate text. Supported MIME types are: &#x60;text/plain&#x60;: (default) Text output. &#x60;application/json&#x60;: JSON response in the response candidates. &#x60;text/x.enum&#x60;: ENUM as a string response in the response candidates. Refer to the [docs](https://ai.google.dev/gemini-api/docs/prompting_with_media#plain_text_formats) for a list of all supported text MIME types.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerationConfig
instance A.FromJSON GenerationConfig where
  parseJSON = A.withObject "GenerationConfig" $ \o ->
    GenerationConfig
      <$> (o .:? "responseSchema")
      <*> (o .:? "thinkingConfig")
      <*> (o .:? "logprobs")
      <*> (o .:? "mediaResolution")
      <*> (o .:? "stopSequences")
      <*> (o .:? "speechConfig")
      <*> (o .:? "responseJsonSchema")
      <*> (o .:? "presencePenalty")
      <*> (o .:? "topP")
      <*> (o .:? "temperature")
      <*> (o .:? "topK")
      <*> (o .:? "candidateCount")
      <*> (o .:? "enableEnhancedCivicAnswers")
      <*> (o .:? "responseLogprobs")
      <*> (o .:? "responseModalities")
      <*> (o .:? "frequencyPenalty")
      <*> (o .:? "seed")
      <*> (o .:? "maxOutputTokens")
      <*> (o .:? "responseMimeType")

-- | ToJSON GenerationConfig
instance A.ToJSON GenerationConfig where
  toJSON GenerationConfig {..} =
    _omitNulls
      [ "responseSchema" .= generationConfigResponseSchema
      , "thinkingConfig" .= generationConfigThinkingConfig
      , "logprobs" .= generationConfigLogprobs
      , "mediaResolution" .= generationConfigMediaResolution
      , "stopSequences" .= generationConfigStopSequences
      , "speechConfig" .= generationConfigSpeechConfig
      , "responseJsonSchema" .= generationConfigResponseJsonSchema
      , "presencePenalty" .= generationConfigPresencePenalty
      , "topP" .= generationConfigTopP
      , "temperature" .= generationConfigTemperature
      , "topK" .= generationConfigTopK
      , "candidateCount" .= generationConfigCandidateCount
      , "enableEnhancedCivicAnswers" .= generationConfigEnableEnhancedCivicAnswers
      , "responseLogprobs" .= generationConfigResponseLogprobs
      , "responseModalities" .= generationConfigResponseModalities
      , "frequencyPenalty" .= generationConfigFrequencyPenalty
      , "seed" .= generationConfigSeed
      , "maxOutputTokens" .= generationConfigMaxOutputTokens
      , "responseMimeType" .= generationConfigResponseMimeType
      ]

-- | Construct a value of type 'GenerationConfig' (by applying it's required fields, if any)
mkGenerationConfig ::
  GenerationConfig
mkGenerationConfig =
  GenerationConfig
    { generationConfigResponseSchema = Nothing
    , generationConfigThinkingConfig = Nothing
    , generationConfigLogprobs = Nothing
    , generationConfigMediaResolution = Nothing
    , generationConfigStopSequences = Nothing
    , generationConfigSpeechConfig = Nothing
    , generationConfigResponseJsonSchema = Nothing
    , generationConfigPresencePenalty = Nothing
    , generationConfigTopP = Nothing
    , generationConfigTemperature = Nothing
    , generationConfigTopK = Nothing
    , generationConfigCandidateCount = Nothing
    , generationConfigEnableEnhancedCivicAnswers = Nothing
    , generationConfigResponseLogprobs = Nothing
    , generationConfigResponseModalities = Nothing
    , generationConfigFrequencyPenalty = Nothing
    , generationConfigSeed = Nothing
    , generationConfigMaxOutputTokens = Nothing
    , generationConfigResponseMimeType = Nothing
    }

-- ** GoogleSearch

{- | GoogleSearch
GoogleSearch tool type. Tool to support Google Search in Model. Powered by Google.
-}
data GoogleSearch = GoogleSearch
  { googleSearchTimeRangeFilter :: !(Maybe Interval)
  -- ^ "timeRangeFilter" - Optional. Filter search results to a specific time range. If customers set a start time, they must set an end time (and vice versa).
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoogleSearch
instance A.FromJSON GoogleSearch where
  parseJSON = A.withObject "GoogleSearch" $ \o ->
    GoogleSearch
      <$> (o .:? "timeRangeFilter")

-- | ToJSON GoogleSearch
instance A.ToJSON GoogleSearch where
  toJSON GoogleSearch {..} =
    _omitNulls
      [ "timeRangeFilter" .= googleSearchTimeRangeFilter
      ]

-- | Construct a value of type 'GoogleSearch' (by applying it's required fields, if any)
mkGoogleSearch ::
  GoogleSearch
mkGoogleSearch =
  GoogleSearch
    { googleSearchTimeRangeFilter = Nothing
    }

-- ** GoogleSearchRetrieval

{- | GoogleSearchRetrieval
Tool to retrieve public web data for grounding, powered by Google.
-}
data GoogleSearchRetrieval = GoogleSearchRetrieval
  { googleSearchRetrievalDynamicRetrievalConfig :: !(Maybe DynamicRetrievalConfig)
  -- ^ "dynamicRetrievalConfig" - Specifies the dynamic retrieval configuration for the given source.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GoogleSearchRetrieval
instance A.FromJSON GoogleSearchRetrieval where
  parseJSON = A.withObject "GoogleSearchRetrieval" $ \o ->
    GoogleSearchRetrieval
      <$> (o .:? "dynamicRetrievalConfig")

-- | ToJSON GoogleSearchRetrieval
instance A.ToJSON GoogleSearchRetrieval where
  toJSON GoogleSearchRetrieval {..} =
    _omitNulls
      [ "dynamicRetrievalConfig" .= googleSearchRetrievalDynamicRetrievalConfig
      ]

-- | Construct a value of type 'GoogleSearchRetrieval' (by applying it's required fields, if any)
mkGoogleSearchRetrieval ::
  GoogleSearchRetrieval
mkGoogleSearchRetrieval =
  GoogleSearchRetrieval
    { googleSearchRetrievalDynamicRetrievalConfig = Nothing
    }

-- ** GroundingAttribution

{- | GroundingAttribution
Attribution for a source that contributed to an answer.
-}
data GroundingAttribution = GroundingAttribution
  { groundingAttributionSourceId :: !(Maybe AttributionSourceId)
  -- ^ /ReadOnly/ "sourceId" - Output only. Identifier for the source contributing to this attribution.
  , groundingAttributionContent :: !(Maybe Content)
  -- ^ "content" - Grounding source content that makes up this attribution.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroundingAttribution
instance A.FromJSON GroundingAttribution where
  parseJSON = A.withObject "GroundingAttribution" $ \o ->
    GroundingAttribution
      <$> (o .:? "sourceId")
      <*> (o .:? "content")

-- | ToJSON GroundingAttribution
instance A.ToJSON GroundingAttribution where
  toJSON GroundingAttribution {..} =
    _omitNulls
      [ "sourceId" .= groundingAttributionSourceId
      , "content" .= groundingAttributionContent
      ]

-- | Construct a value of type 'GroundingAttribution' (by applying it's required fields, if any)
mkGroundingAttribution ::
  GroundingAttribution
mkGroundingAttribution =
  GroundingAttribution
    { groundingAttributionSourceId = Nothing
    , groundingAttributionContent = Nothing
    }

-- ** GroundingChunk

{- | GroundingChunk
Grounding chunk.
-}
data GroundingChunk = GroundingChunk
  { groundingChunkWeb :: !(Maybe Web)
  -- ^ "web" - Grounding chunk from the web.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroundingChunk
instance A.FromJSON GroundingChunk where
  parseJSON = A.withObject "GroundingChunk" $ \o ->
    GroundingChunk
      <$> (o .:? "web")

-- | ToJSON GroundingChunk
instance A.ToJSON GroundingChunk where
  toJSON GroundingChunk {..} =
    _omitNulls
      [ "web" .= groundingChunkWeb
      ]

-- | Construct a value of type 'GroundingChunk' (by applying it's required fields, if any)
mkGroundingChunk ::
  GroundingChunk
mkGroundingChunk =
  GroundingChunk
    { groundingChunkWeb = Nothing
    }

-- ** GroundingMetadata

{- | GroundingMetadata
Metadata returned to client when grounding is enabled.
-}
data GroundingMetadata = GroundingMetadata
  { groundingMetadataRetrievalMetadata :: !(Maybe RetrievalMetadata)
  -- ^ "retrievalMetadata" - Metadata related to retrieval in the grounding flow.
  , groundingMetadataWebSearchQueries :: !(Maybe [Text])
  -- ^ "webSearchQueries" - Web search queries for the following-up web search.
  , groundingMetadataGroundingChunks :: !(Maybe [GroundingChunk])
  -- ^ "groundingChunks" - List of supporting references retrieved from specified grounding source.
  , groundingMetadataSearchEntryPoint :: !(Maybe SearchEntryPoint)
  -- ^ "searchEntryPoint" - Optional. Google search entry for the following-up web searches.
  , groundingMetadataGroundingSupports :: !(Maybe [GroundingSupport])
  -- ^ "groundingSupports" - List of grounding support.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroundingMetadata
instance A.FromJSON GroundingMetadata where
  parseJSON = A.withObject "GroundingMetadata" $ \o ->
    GroundingMetadata
      <$> (o .:? "retrievalMetadata")
      <*> (o .:? "webSearchQueries")
      <*> (o .:? "groundingChunks")
      <*> (o .:? "searchEntryPoint")
      <*> (o .:? "groundingSupports")

-- | ToJSON GroundingMetadata
instance A.ToJSON GroundingMetadata where
  toJSON GroundingMetadata {..} =
    _omitNulls
      [ "retrievalMetadata" .= groundingMetadataRetrievalMetadata
      , "webSearchQueries" .= groundingMetadataWebSearchQueries
      , "groundingChunks" .= groundingMetadataGroundingChunks
      , "searchEntryPoint" .= groundingMetadataSearchEntryPoint
      , "groundingSupports" .= groundingMetadataGroundingSupports
      ]

-- | Construct a value of type 'GroundingMetadata' (by applying it's required fields, if any)
mkGroundingMetadata ::
  GroundingMetadata
mkGroundingMetadata =
  GroundingMetadata
    { groundingMetadataRetrievalMetadata = Nothing
    , groundingMetadataWebSearchQueries = Nothing
    , groundingMetadataGroundingChunks = Nothing
    , groundingMetadataSearchEntryPoint = Nothing
    , groundingMetadataGroundingSupports = Nothing
    }

-- ** GroundingPassage

{- | GroundingPassage
Passage included inline with a grounding configuration.
-}
data GroundingPassage = GroundingPassage
  { groundingPassageContent :: !(Maybe Content)
  -- ^ "content" - Content of the passage.
  , groundingPassageId :: !(Maybe Text)
  -- ^ "id" - Identifier for the passage for attributing this passage in grounded answers.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroundingPassage
instance A.FromJSON GroundingPassage where
  parseJSON = A.withObject "GroundingPassage" $ \o ->
    GroundingPassage
      <$> (o .:? "content")
      <*> (o .:? "id")

-- | ToJSON GroundingPassage
instance A.ToJSON GroundingPassage where
  toJSON GroundingPassage {..} =
    _omitNulls
      [ "content" .= groundingPassageContent
      , "id" .= groundingPassageId
      ]

-- | Construct a value of type 'GroundingPassage' (by applying it's required fields, if any)
mkGroundingPassage ::
  GroundingPassage
mkGroundingPassage =
  GroundingPassage
    { groundingPassageContent = Nothing
    , groundingPassageId = Nothing
    }

-- ** GroundingPassageId

{- | GroundingPassageId
Identifier for a part within a `GroundingPassage`.
-}
data GroundingPassageId = GroundingPassageId
  { groundingPassageIdPassageId :: !(Maybe Text)
  -- ^ /ReadOnly/ "passageId" - Output only. ID of the passage matching the &#x60;GenerateAnswerRequest&#x60;&#39;s &#x60;GroundingPassage.id&#x60;.
  , groundingPassageIdPartIndex :: !(Maybe Int)
  -- ^ /ReadOnly/ "partIndex" - Output only. Index of the part within the &#x60;GenerateAnswerRequest&#x60;&#39;s &#x60;GroundingPassage.content&#x60;.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroundingPassageId
instance A.FromJSON GroundingPassageId where
  parseJSON = A.withObject "GroundingPassageId" $ \o ->
    GroundingPassageId
      <$> (o .:? "passageId")
      <*> (o .:? "partIndex")

-- | ToJSON GroundingPassageId
instance A.ToJSON GroundingPassageId where
  toJSON GroundingPassageId {..} =
    _omitNulls
      [ "passageId" .= groundingPassageIdPassageId
      , "partIndex" .= groundingPassageIdPartIndex
      ]

-- | Construct a value of type 'GroundingPassageId' (by applying it's required fields, if any)
mkGroundingPassageId ::
  GroundingPassageId
mkGroundingPassageId =
  GroundingPassageId
    { groundingPassageIdPassageId = Nothing
    , groundingPassageIdPartIndex = Nothing
    }

-- ** GroundingPassages

{- | GroundingPassages
A repeated list of passages.
-}
data GroundingPassages = GroundingPassages
  { groundingPassagesPassages :: !(Maybe [GroundingPassage])
  -- ^ "passages" - List of passages.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroundingPassages
instance A.FromJSON GroundingPassages where
  parseJSON = A.withObject "GroundingPassages" $ \o ->
    GroundingPassages
      <$> (o .:? "passages")

-- | ToJSON GroundingPassages
instance A.ToJSON GroundingPassages where
  toJSON GroundingPassages {..} =
    _omitNulls
      [ "passages" .= groundingPassagesPassages
      ]

-- | Construct a value of type 'GroundingPassages' (by applying it's required fields, if any)
mkGroundingPassages ::
  GroundingPassages
mkGroundingPassages =
  GroundingPassages
    { groundingPassagesPassages = Nothing
    }

-- ** GroundingSupport

{- | GroundingSupport
Grounding support.
-}
data GroundingSupport = GroundingSupport
  { groundingSupportConfidenceScores :: !(Maybe [Float])
  -- ^ "confidenceScores" - Confidence score of the support references. Ranges from 0 to 1. 1 is the most confident. This list must have the same size as the grounding_chunk_indices.
  , groundingSupportGroundingChunkIndices :: !(Maybe [Int])
  -- ^ "groundingChunkIndices" - A list of indices (into &#39;grounding_chunk&#39;) specifying the citations associated with the claim. For instance [1,3,4] means that grounding_chunk[1], grounding_chunk[3], grounding_chunk[4] are the retrieved content attributed to the claim.
  , groundingSupportSegment :: !(Maybe Segment)
  -- ^ "segment" - Segment of the content this support belongs to.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroundingSupport
instance A.FromJSON GroundingSupport where
  parseJSON = A.withObject "GroundingSupport" $ \o ->
    GroundingSupport
      <$> (o .:? "confidenceScores")
      <*> (o .:? "groundingChunkIndices")
      <*> (o .:? "segment")

-- | ToJSON GroundingSupport
instance A.ToJSON GroundingSupport where
  toJSON GroundingSupport {..} =
    _omitNulls
      [ "confidenceScores" .= groundingSupportConfidenceScores
      , "groundingChunkIndices" .= groundingSupportGroundingChunkIndices
      , "segment" .= groundingSupportSegment
      ]

-- | Construct a value of type 'GroundingSupport' (by applying it's required fields, if any)
mkGroundingSupport ::
  GroundingSupport
mkGroundingSupport =
  GroundingSupport
    { groundingSupportConfidenceScores = Nothing
    , groundingSupportGroundingChunkIndices = Nothing
    , groundingSupportSegment = Nothing
    }

-- ** Hyperparameters

{- | Hyperparameters
Hyperparameters controlling the tuning process. Read more at https://ai.google.dev/docs/model_tuning_guidance
-}
data Hyperparameters = Hyperparameters
  { hyperparametersEpochCount :: !(Maybe Int)
  -- ^ "epochCount" - Immutable. The number of training epochs. An epoch is one pass through the training data. If not set, a default of 5 will be used.
  , hyperparametersLearningRate :: !(Maybe Float)
  -- ^ "learningRate" - Optional. Immutable. The learning rate hyperparameter for tuning. If not set, a default of 0.001 or 0.0002 will be calculated based on the number of training examples.
  , hyperparametersLearningRateMultiplier :: !(Maybe Float)
  -- ^ "learningRateMultiplier" - Optional. Immutable. The learning rate multiplier is used to calculate a final learning_rate based on the default (recommended) value. Actual learning rate :&#x3D; learning_rate_multiplier * default learning rate Default learning rate is dependent on base model and dataset size. If not set, a default of 1.0 will be used.
  , hyperparametersBatchSize :: !(Maybe Int)
  -- ^ "batchSize" - Immutable. The batch size hyperparameter for tuning. If not set, a default of 4 or 16 will be used based on the number of training examples.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Hyperparameters
instance A.FromJSON Hyperparameters where
  parseJSON = A.withObject "Hyperparameters" $ \o ->
    Hyperparameters
      <$> (o .:? "epochCount")
      <*> (o .:? "learningRate")
      <*> (o .:? "learningRateMultiplier")
      <*> (o .:? "batchSize")

-- | ToJSON Hyperparameters
instance A.ToJSON Hyperparameters where
  toJSON Hyperparameters {..} =
    _omitNulls
      [ "epochCount" .= hyperparametersEpochCount
      , "learningRate" .= hyperparametersLearningRate
      , "learningRateMultiplier" .= hyperparametersLearningRateMultiplier
      , "batchSize" .= hyperparametersBatchSize
      ]

-- | Construct a value of type 'Hyperparameters' (by applying it's required fields, if any)
mkHyperparameters ::
  Hyperparameters
mkHyperparameters =
  Hyperparameters
    { hyperparametersEpochCount = Nothing
    , hyperparametersLearningRate = Nothing
    , hyperparametersLearningRateMultiplier = Nothing
    , hyperparametersBatchSize = Nothing
    }

-- ** InputFeedback

{- | InputFeedback
Feedback related to the input data used to answer the question, as opposed to the model-generated response to the question.
-}
data InputFeedback = InputFeedback
  { inputFeedbackSafetyRatings :: !(Maybe [SafetyRating])
  -- ^ "safetyRatings" - Ratings for safety of the input. There is at most one rating per category.
  , inputFeedbackBlockReason :: !(Maybe E'BlockReason2)
  -- ^ "blockReason" - Optional. If set, the input was blocked and no candidates are returned. Rephrase the input.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InputFeedback
instance A.FromJSON InputFeedback where
  parseJSON = A.withObject "InputFeedback" $ \o ->
    InputFeedback
      <$> (o .:? "safetyRatings")
      <*> (o .:? "blockReason")

-- | ToJSON InputFeedback
instance A.ToJSON InputFeedback where
  toJSON InputFeedback {..} =
    _omitNulls
      [ "safetyRatings" .= inputFeedbackSafetyRatings
      , "blockReason" .= inputFeedbackBlockReason
      ]

-- | Construct a value of type 'InputFeedback' (by applying it's required fields, if any)
mkInputFeedback ::
  InputFeedback
mkInputFeedback =
  InputFeedback
    { inputFeedbackSafetyRatings = Nothing
    , inputFeedbackBlockReason = Nothing
    }

-- ** Interval

{- | Interval
Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).  The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time.
-}
data Interval = Interval
  { intervalStartTime :: !(Maybe DateTime)
  -- ^ "startTime" - Optional. Inclusive start of the interval.  If specified, a Timestamp matching this interval will have to be the same or after the start.
  , intervalEndTime :: !(Maybe DateTime)
  -- ^ "endTime" - Optional. Exclusive end of the interval.  If specified, a Timestamp matching this interval will have to be before the end.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Interval
instance A.FromJSON Interval where
  parseJSON = A.withObject "Interval" $ \o ->
    Interval
      <$> (o .:? "startTime")
      <*> (o .:? "endTime")

-- | ToJSON Interval
instance A.ToJSON Interval where
  toJSON Interval {..} =
    _omitNulls
      [ "startTime" .= intervalStartTime
      , "endTime" .= intervalEndTime
      ]

-- | Construct a value of type 'Interval' (by applying it's required fields, if any)
mkInterval ::
  Interval
mkInterval =
  Interval
    { intervalStartTime = Nothing
    , intervalEndTime = Nothing
    }

-- ** ListCachedContentsResponse

{- | ListCachedContentsResponse
Response with CachedContents list.
-}
data ListCachedContentsResponse = ListCachedContentsResponse
  { listCachedContentsResponseNextPageToken :: !(Maybe Text)
  -- ^ "nextPageToken" - A token, which can be sent as &#x60;page_token&#x60; to retrieve the next page. If this field is omitted, there are no subsequent pages.
  , listCachedContentsResponseCachedContents :: !(Maybe [CachedContent])
  -- ^ "cachedContents" - List of cached contents.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListCachedContentsResponse
instance A.FromJSON ListCachedContentsResponse where
  parseJSON = A.withObject "ListCachedContentsResponse" $ \o ->
    ListCachedContentsResponse
      <$> (o .:? "nextPageToken")
      <*> (o .:? "cachedContents")

-- | ToJSON ListCachedContentsResponse
instance A.ToJSON ListCachedContentsResponse where
  toJSON ListCachedContentsResponse {..} =
    _omitNulls
      [ "nextPageToken" .= listCachedContentsResponseNextPageToken
      , "cachedContents" .= listCachedContentsResponseCachedContents
      ]

-- | Construct a value of type 'ListCachedContentsResponse' (by applying it's required fields, if any)
mkListCachedContentsResponse ::
  ListCachedContentsResponse
mkListCachedContentsResponse =
  ListCachedContentsResponse
    { listCachedContentsResponseNextPageToken = Nothing
    , listCachedContentsResponseCachedContents = Nothing
    }

-- ** ListChunksResponse

{- | ListChunksResponse
Response from `ListChunks` containing a paginated list of `Chunk`s. The `Chunk`s are sorted by ascending `chunk.create_time`.
-}
data ListChunksResponse = ListChunksResponse
  { listChunksResponseNextPageToken :: !(Maybe Text)
  -- ^ "nextPageToken" - A token, which can be sent as &#x60;page_token&#x60; to retrieve the next page. If this field is omitted, there are no more pages.
  , listChunksResponseChunks :: !(Maybe [Chunk])
  -- ^ "chunks" - The returned &#x60;Chunk&#x60;s.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListChunksResponse
instance A.FromJSON ListChunksResponse where
  parseJSON = A.withObject "ListChunksResponse" $ \o ->
    ListChunksResponse
      <$> (o .:? "nextPageToken")
      <*> (o .:? "chunks")

-- | ToJSON ListChunksResponse
instance A.ToJSON ListChunksResponse where
  toJSON ListChunksResponse {..} =
    _omitNulls
      [ "nextPageToken" .= listChunksResponseNextPageToken
      , "chunks" .= listChunksResponseChunks
      ]

-- | Construct a value of type 'ListChunksResponse' (by applying it's required fields, if any)
mkListChunksResponse ::
  ListChunksResponse
mkListChunksResponse =
  ListChunksResponse
    { listChunksResponseNextPageToken = Nothing
    , listChunksResponseChunks = Nothing
    }

-- ** ListCorporaResponse

{- | ListCorporaResponse
Response from `ListCorpora` containing a paginated list of `Corpora`. The results are sorted by ascending `corpus.create_time`.
-}
data ListCorporaResponse = ListCorporaResponse
  { listCorporaResponseCorpora :: !(Maybe [Corpus])
  -- ^ "corpora" - The returned corpora.
  , listCorporaResponseNextPageToken :: !(Maybe Text)
  -- ^ "nextPageToken" - A token, which can be sent as &#x60;page_token&#x60; to retrieve the next page. If this field is omitted, there are no more pages.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListCorporaResponse
instance A.FromJSON ListCorporaResponse where
  parseJSON = A.withObject "ListCorporaResponse" $ \o ->
    ListCorporaResponse
      <$> (o .:? "corpora")
      <*> (o .:? "nextPageToken")

-- | ToJSON ListCorporaResponse
instance A.ToJSON ListCorporaResponse where
  toJSON ListCorporaResponse {..} =
    _omitNulls
      [ "corpora" .= listCorporaResponseCorpora
      , "nextPageToken" .= listCorporaResponseNextPageToken
      ]

-- | Construct a value of type 'ListCorporaResponse' (by applying it's required fields, if any)
mkListCorporaResponse ::
  ListCorporaResponse
mkListCorporaResponse =
  ListCorporaResponse
    { listCorporaResponseCorpora = Nothing
    , listCorporaResponseNextPageToken = Nothing
    }

-- ** ListDocumentsResponse

{- | ListDocumentsResponse
Response from `ListDocuments` containing a paginated list of `Document`s. The `Document`s are sorted by ascending `document.create_time`.
-}
data ListDocumentsResponse = ListDocumentsResponse
  { listDocumentsResponseNextPageToken :: !(Maybe Text)
  -- ^ "nextPageToken" - A token, which can be sent as &#x60;page_token&#x60; to retrieve the next page. If this field is omitted, there are no more pages.
  , listDocumentsResponseDocuments :: !(Maybe [Document])
  -- ^ "documents" - The returned &#x60;Document&#x60;s.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListDocumentsResponse
instance A.FromJSON ListDocumentsResponse where
  parseJSON = A.withObject "ListDocumentsResponse" $ \o ->
    ListDocumentsResponse
      <$> (o .:? "nextPageToken")
      <*> (o .:? "documents")

-- | ToJSON ListDocumentsResponse
instance A.ToJSON ListDocumentsResponse where
  toJSON ListDocumentsResponse {..} =
    _omitNulls
      [ "nextPageToken" .= listDocumentsResponseNextPageToken
      , "documents" .= listDocumentsResponseDocuments
      ]

-- | Construct a value of type 'ListDocumentsResponse' (by applying it's required fields, if any)
mkListDocumentsResponse ::
  ListDocumentsResponse
mkListDocumentsResponse =
  ListDocumentsResponse
    { listDocumentsResponseNextPageToken = Nothing
    , listDocumentsResponseDocuments = Nothing
    }

-- ** ListFilesResponse

{- | ListFilesResponse
Response for `ListFiles`.
-}
data ListFilesResponse = ListFilesResponse
  { listFilesResponseNextPageToken :: !(Maybe Text)
  -- ^ "nextPageToken" - A token that can be sent as a &#x60;page_token&#x60; into a subsequent &#x60;ListFiles&#x60; call.
  , listFilesResponseFiles :: !(Maybe [File])
  -- ^ "files" - The list of &#x60;File&#x60;s.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListFilesResponse
instance A.FromJSON ListFilesResponse where
  parseJSON = A.withObject "ListFilesResponse" $ \o ->
    ListFilesResponse
      <$> (o .:? "nextPageToken")
      <*> (o .:? "files")

-- | ToJSON ListFilesResponse
instance A.ToJSON ListFilesResponse where
  toJSON ListFilesResponse {..} =
    _omitNulls
      [ "nextPageToken" .= listFilesResponseNextPageToken
      , "files" .= listFilesResponseFiles
      ]

-- | Construct a value of type 'ListFilesResponse' (by applying it's required fields, if any)
mkListFilesResponse ::
  ListFilesResponse
mkListFilesResponse =
  ListFilesResponse
    { listFilesResponseNextPageToken = Nothing
    , listFilesResponseFiles = Nothing
    }

-- ** ListGeneratedFilesResponse

{- | ListGeneratedFilesResponse
Response for `ListGeneratedFiles`.
-}
data ListGeneratedFilesResponse = ListGeneratedFilesResponse
  { listGeneratedFilesResponseNextPageToken :: !(Maybe Text)
  -- ^ "nextPageToken" - A token that can be sent as a &#x60;page_token&#x60; into a subsequent &#x60;ListGeneratedFiles&#x60; call.
  , listGeneratedFilesResponseGeneratedFiles :: !(Maybe [GeneratedFile])
  -- ^ "generatedFiles" - The list of &#x60;GeneratedFile&#x60;s.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListGeneratedFilesResponse
instance A.FromJSON ListGeneratedFilesResponse where
  parseJSON = A.withObject "ListGeneratedFilesResponse" $ \o ->
    ListGeneratedFilesResponse
      <$> (o .:? "nextPageToken")
      <*> (o .:? "generatedFiles")

-- | ToJSON ListGeneratedFilesResponse
instance A.ToJSON ListGeneratedFilesResponse where
  toJSON ListGeneratedFilesResponse {..} =
    _omitNulls
      [ "nextPageToken" .= listGeneratedFilesResponseNextPageToken
      , "generatedFiles" .= listGeneratedFilesResponseGeneratedFiles
      ]

-- | Construct a value of type 'ListGeneratedFilesResponse' (by applying it's required fields, if any)
mkListGeneratedFilesResponse ::
  ListGeneratedFilesResponse
mkListGeneratedFilesResponse =
  ListGeneratedFilesResponse
    { listGeneratedFilesResponseNextPageToken = Nothing
    , listGeneratedFilesResponseGeneratedFiles = Nothing
    }

-- ** ListModelsResponse

{- | ListModelsResponse
Response from `ListModel` containing a paginated list of Models.
-}
data ListModelsResponse = ListModelsResponse
  { listModelsResponseModels :: !(Maybe [Model])
  -- ^ "models" - The returned Models.
  , listModelsResponseNextPageToken :: !(Maybe Text)
  -- ^ "nextPageToken" - A token, which can be sent as &#x60;page_token&#x60; to retrieve the next page.  If this field is omitted, there are no more pages.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListModelsResponse
instance A.FromJSON ListModelsResponse where
  parseJSON = A.withObject "ListModelsResponse" $ \o ->
    ListModelsResponse
      <$> (o .:? "models")
      <*> (o .:? "nextPageToken")

-- | ToJSON ListModelsResponse
instance A.ToJSON ListModelsResponse where
  toJSON ListModelsResponse {..} =
    _omitNulls
      [ "models" .= listModelsResponseModels
      , "nextPageToken" .= listModelsResponseNextPageToken
      ]

-- | Construct a value of type 'ListModelsResponse' (by applying it's required fields, if any)
mkListModelsResponse ::
  ListModelsResponse
mkListModelsResponse =
  ListModelsResponse
    { listModelsResponseModels = Nothing
    , listModelsResponseNextPageToken = Nothing
    }

-- ** ListOperationsResponse

{- | ListOperationsResponse
The response message for Operations.ListOperations.
-}
data ListOperationsResponse = ListOperationsResponse
  { listOperationsResponseNextPageToken :: !(Maybe Text)
  -- ^ "nextPageToken" - The standard List next-page token.
  , listOperationsResponseOperations :: !(Maybe [Operation])
  -- ^ "operations" - A list of operations that matches the specified filter in the request.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListOperationsResponse
instance A.FromJSON ListOperationsResponse where
  parseJSON = A.withObject "ListOperationsResponse" $ \o ->
    ListOperationsResponse
      <$> (o .:? "nextPageToken")
      <*> (o .:? "operations")

-- | ToJSON ListOperationsResponse
instance A.ToJSON ListOperationsResponse where
  toJSON ListOperationsResponse {..} =
    _omitNulls
      [ "nextPageToken" .= listOperationsResponseNextPageToken
      , "operations" .= listOperationsResponseOperations
      ]

-- | Construct a value of type 'ListOperationsResponse' (by applying it's required fields, if any)
mkListOperationsResponse ::
  ListOperationsResponse
mkListOperationsResponse =
  ListOperationsResponse
    { listOperationsResponseNextPageToken = Nothing
    , listOperationsResponseOperations = Nothing
    }

-- ** ListPermissionsResponse

{- | ListPermissionsResponse
Response from `ListPermissions` containing a paginated list of permissions.
-}
data ListPermissionsResponse = ListPermissionsResponse
  { listPermissionsResponsePermissions :: !(Maybe [Permission])
  -- ^ "permissions" - Returned permissions.
  , listPermissionsResponseNextPageToken :: !(Maybe Text)
  -- ^ "nextPageToken" - A token, which can be sent as &#x60;page_token&#x60; to retrieve the next page.  If this field is omitted, there are no more pages.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListPermissionsResponse
instance A.FromJSON ListPermissionsResponse where
  parseJSON = A.withObject "ListPermissionsResponse" $ \o ->
    ListPermissionsResponse
      <$> (o .:? "permissions")
      <*> (o .:? "nextPageToken")

-- | ToJSON ListPermissionsResponse
instance A.ToJSON ListPermissionsResponse where
  toJSON ListPermissionsResponse {..} =
    _omitNulls
      [ "permissions" .= listPermissionsResponsePermissions
      , "nextPageToken" .= listPermissionsResponseNextPageToken
      ]

-- | Construct a value of type 'ListPermissionsResponse' (by applying it's required fields, if any)
mkListPermissionsResponse ::
  ListPermissionsResponse
mkListPermissionsResponse =
  ListPermissionsResponse
    { listPermissionsResponsePermissions = Nothing
    , listPermissionsResponseNextPageToken = Nothing
    }

-- ** ListTunedModelsResponse

{- | ListTunedModelsResponse
Response from `ListTunedModels` containing a paginated list of Models.
-}
data ListTunedModelsResponse = ListTunedModelsResponse
  { listTunedModelsResponseNextPageToken :: !(Maybe Text)
  -- ^ "nextPageToken" - A token, which can be sent as &#x60;page_token&#x60; to retrieve the next page.  If this field is omitted, there are no more pages.
  , listTunedModelsResponseTunedModels :: !(Maybe [TunedModel])
  -- ^ "tunedModels" - The returned Models.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListTunedModelsResponse
instance A.FromJSON ListTunedModelsResponse where
  parseJSON = A.withObject "ListTunedModelsResponse" $ \o ->
    ListTunedModelsResponse
      <$> (o .:? "nextPageToken")
      <*> (o .:? "tunedModels")

-- | ToJSON ListTunedModelsResponse
instance A.ToJSON ListTunedModelsResponse where
  toJSON ListTunedModelsResponse {..} =
    _omitNulls
      [ "nextPageToken" .= listTunedModelsResponseNextPageToken
      , "tunedModels" .= listTunedModelsResponseTunedModels
      ]

-- | Construct a value of type 'ListTunedModelsResponse' (by applying it's required fields, if any)
mkListTunedModelsResponse ::
  ListTunedModelsResponse
mkListTunedModelsResponse =
  ListTunedModelsResponse
    { listTunedModelsResponseNextPageToken = Nothing
    , listTunedModelsResponseTunedModels = Nothing
    }

-- ** LogprobsResult

{- | LogprobsResult
Logprobs Result
-}
data LogprobsResult = LogprobsResult
  { logprobsResultChosenCandidates :: !(Maybe [LogprobsResultCandidate])
  -- ^ "chosenCandidates" - Length &#x3D; total number of decoding steps. The chosen candidates may or may not be in top_candidates.
  , logprobsResultTopCandidates :: !(Maybe [TopCandidates])
  -- ^ "topCandidates" - Length &#x3D; total number of decoding steps.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogprobsResult
instance A.FromJSON LogprobsResult where
  parseJSON = A.withObject "LogprobsResult" $ \o ->
    LogprobsResult
      <$> (o .:? "chosenCandidates")
      <*> (o .:? "topCandidates")

-- | ToJSON LogprobsResult
instance A.ToJSON LogprobsResult where
  toJSON LogprobsResult {..} =
    _omitNulls
      [ "chosenCandidates" .= logprobsResultChosenCandidates
      , "topCandidates" .= logprobsResultTopCandidates
      ]

-- | Construct a value of type 'LogprobsResult' (by applying it's required fields, if any)
mkLogprobsResult ::
  LogprobsResult
mkLogprobsResult =
  LogprobsResult
    { logprobsResultChosenCandidates = Nothing
    , logprobsResultTopCandidates = Nothing
    }

-- ** LogprobsResultCandidate

{- | LogprobsResultCandidate
Candidate for the logprobs token and score.
-}
data LogprobsResultCandidate = LogprobsResultCandidate
  { logprobsResultCandidateLogProbability :: !(Maybe Float)
  -- ^ "logProbability" - The candidate&#39;s log probability.
  , logprobsResultCandidateTokenId :: !(Maybe Int)
  -- ^ "tokenId" - The candidate’s token id value.
  , logprobsResultCandidateToken :: !(Maybe Text)
  -- ^ "token" - The candidate’s token string value.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogprobsResultCandidate
instance A.FromJSON LogprobsResultCandidate where
  parseJSON = A.withObject "LogprobsResultCandidate" $ \o ->
    LogprobsResultCandidate
      <$> (o .:? "logProbability")
      <*> (o .:? "tokenId")
      <*> (o .:? "token")

-- | ToJSON LogprobsResultCandidate
instance A.ToJSON LogprobsResultCandidate where
  toJSON LogprobsResultCandidate {..} =
    _omitNulls
      [ "logProbability" .= logprobsResultCandidateLogProbability
      , "tokenId" .= logprobsResultCandidateTokenId
      , "token" .= logprobsResultCandidateToken
      ]

-- | Construct a value of type 'LogprobsResultCandidate' (by applying it's required fields, if any)
mkLogprobsResultCandidate ::
  LogprobsResultCandidate
mkLogprobsResultCandidate =
  LogprobsResultCandidate
    { logprobsResultCandidateLogProbability = Nothing
    , logprobsResultCandidateTokenId = Nothing
    , logprobsResultCandidateToken = Nothing
    }

-- ** Media

{- | Media
A proto encapsulate various type of media.
-}
data Media = Media
  { mediaVideo :: !(Maybe Video)
  -- ^ "video" - Video as the only one for now.  This is mimicking Vertex proto.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Media
instance A.FromJSON Media where
  parseJSON = A.withObject "Media" $ \o ->
    Media
      <$> (o .:? "video")

-- | ToJSON Media
instance A.ToJSON Media where
  toJSON Media {..} =
    _omitNulls
      [ "video" .= mediaVideo
      ]

-- | Construct a value of type 'Media' (by applying it's required fields, if any)
mkMedia ::
  Media
mkMedia =
  Media
    { mediaVideo = Nothing
    }

-- ** Message

{- | Message
The base unit of structured text.  A `Message` includes an `author` and the `content` of the `Message`.  The `author` is used to tag messages when they are fed to the model as text.
-}
data Message = Message
  { messageCitationMetadata :: !(Maybe CitationMetadata)
  -- ^ /ReadOnly/ "citationMetadata" - Output only. Citation information for model-generated &#x60;content&#x60; in this &#x60;Message&#x60;.  If this &#x60;Message&#x60; was generated as output from the model, this field may be populated with attribution information for any text included in the &#x60;content&#x60;. This field is used only on output.
  , messageAuthor :: !(Maybe Text)
  -- ^ "author" - Optional. The author of this Message.  This serves as a key for tagging the content of this Message when it is fed to the model as text.  The author can be any alphanumeric string.
  , messageContent :: !(Text)
  -- ^ /Required/ "content" - Required. The text content of the structured &#x60;Message&#x60;.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Message
instance A.FromJSON Message where
  parseJSON = A.withObject "Message" $ \o ->
    Message
      <$> (o .:? "citationMetadata")
      <*> (o .:? "author")
      <*> (o .: "content")

-- | ToJSON Message
instance A.ToJSON Message where
  toJSON Message {..} =
    _omitNulls
      [ "citationMetadata" .= messageCitationMetadata
      , "author" .= messageAuthor
      , "content" .= messageContent
      ]

-- | Construct a value of type 'Message' (by applying it's required fields, if any)
mkMessage ::
  -- | 'messageContent': Required. The text content of the structured `Message`.
  Text ->
  Message
mkMessage messageContent =
  Message
    { messageCitationMetadata = Nothing
    , messageAuthor = Nothing
    , messageContent
    }

-- ** MessagePrompt

{- | MessagePrompt
All of the structured input text passed to the model as a prompt.  A `MessagePrompt` contains a structured set of fields that provide context for the conversation, examples of user input/model output message pairs that prime the model to respond in different ways, and the conversation history or list of messages representing the alternating turns of the conversation between the user and the model.
-}
data MessagePrompt = MessagePrompt
  { messagePromptContext :: !(Maybe Text)
  -- ^ "context" - Optional. Text that should be provided to the model first to ground the response.  If not empty, this &#x60;context&#x60; will be given to the model first before the &#x60;examples&#x60; and &#x60;messages&#x60;. When using a &#x60;context&#x60; be sure to provide it with every request to maintain continuity.  This field can be a description of your prompt to the model to help provide context and guide the responses. Examples: \&quot;Translate the phrase from English to French.\&quot; or \&quot;Given a statement, classify the sentiment as happy, sad or neutral.\&quot;  Anything included in this field will take precedence over message history if the total input size exceeds the model&#39;s &#x60;input_token_limit&#x60; and the input request is truncated.
  , messagePromptMessages :: !([Message])
  -- ^ /Required/ "messages" - Required. A snapshot of the recent conversation history sorted chronologically.  Turns alternate between two authors.  If the total input size exceeds the model&#39;s &#x60;input_token_limit&#x60; the input will be truncated: The oldest items will be dropped from &#x60;messages&#x60;.
  , messagePromptExamples :: !(Maybe [Example])
  -- ^ "examples" - Optional. Examples of what the model should generate.  This includes both user input and the response that the model should emulate.  These &#x60;examples&#x60; are treated identically to conversation messages except that they take precedence over the history in &#x60;messages&#x60;: If the total input size exceeds the model&#39;s &#x60;input_token_limit&#x60; the input will be truncated. Items will be dropped from &#x60;messages&#x60; before &#x60;examples&#x60;.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessagePrompt
instance A.FromJSON MessagePrompt where
  parseJSON = A.withObject "MessagePrompt" $ \o ->
    MessagePrompt
      <$> (o .:? "context")
      <*> (o .: "messages")
      <*> (o .:? "examples")

-- | ToJSON MessagePrompt
instance A.ToJSON MessagePrompt where
  toJSON MessagePrompt {..} =
    _omitNulls
      [ "context" .= messagePromptContext
      , "messages" .= messagePromptMessages
      , "examples" .= messagePromptExamples
      ]

-- | Construct a value of type 'MessagePrompt' (by applying it's required fields, if any)
mkMessagePrompt ::
  -- | 'messagePromptMessages': Required. A snapshot of the recent conversation history sorted chronologically.  Turns alternate between two authors.  If the total input size exceeds the model's `input_token_limit` the input will be truncated: The oldest items will be dropped from `messages`.
  [Message] ->
  MessagePrompt
mkMessagePrompt messagePromptMessages =
  MessagePrompt
    { messagePromptContext = Nothing
    , messagePromptMessages
    , messagePromptExamples = Nothing
    }

-- ** MetadataFilter

{- | MetadataFilter
User provided filter to limit retrieval based on `Chunk` or `Document` level metadata values. Example (genre = drama OR genre = action):   key = \"document.custom_metadata.genre\"   conditions = [{string_value = \"drama\", operation = EQUAL},                 {string_value = \"action\", operation = EQUAL}]
-}
data MetadataFilter = MetadataFilter
  { metadataFilterConditions :: !([Condition])
  -- ^ /Required/ "conditions" - Required. The &#x60;Condition&#x60;s for the given key that will trigger this filter. Multiple &#x60;Condition&#x60;s are joined by logical ORs.
  , metadataFilterKey :: !(Text)
  -- ^ /Required/ "key" - Required. The key of the metadata to filter on.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MetadataFilter
instance A.FromJSON MetadataFilter where
  parseJSON = A.withObject "MetadataFilter" $ \o ->
    MetadataFilter
      <$> (o .: "conditions")
      <*> (o .: "key")

-- | ToJSON MetadataFilter
instance A.ToJSON MetadataFilter where
  toJSON MetadataFilter {..} =
    _omitNulls
      [ "conditions" .= metadataFilterConditions
      , "key" .= metadataFilterKey
      ]

-- | Construct a value of type 'MetadataFilter' (by applying it's required fields, if any)
mkMetadataFilter ::
  -- | 'metadataFilterConditions': Required. The `Condition`s for the given key that will trigger this filter. Multiple `Condition`s are joined by logical ORs.
  [Condition] ->
  -- | 'metadataFilterKey': Required. The key of the metadata to filter on.
  Text ->
  MetadataFilter
mkMetadataFilter metadataFilterConditions metadataFilterKey =
  MetadataFilter
    { metadataFilterConditions
    , metadataFilterKey
    }

-- ** ModalityTokenCount

{- | ModalityTokenCount
Represents token counting info for a single modality.
-}
data ModalityTokenCount = ModalityTokenCount
  { modalityTokenCountTokenCount :: !(Maybe Int)
  -- ^ "tokenCount" - Number of tokens.
  , modalityTokenCountModality :: !(Maybe Modality)
  -- ^ "modality" - The modality associated with this token count.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModalityTokenCount
instance A.FromJSON ModalityTokenCount where
  parseJSON = A.withObject "ModalityTokenCount" $ \o ->
    ModalityTokenCount
      <$> (o .:? "tokenCount")
      <*> (o .:? "modality")

-- | ToJSON ModalityTokenCount
instance A.ToJSON ModalityTokenCount where
  toJSON ModalityTokenCount {..} =
    _omitNulls
      [ "tokenCount" .= modalityTokenCountTokenCount
      , "modality" .= modalityTokenCountModality
      ]

-- | Construct a value of type 'ModalityTokenCount' (by applying it's required fields, if any)
mkModalityTokenCount ::
  ModalityTokenCount
mkModalityTokenCount =
  ModalityTokenCount
    { modalityTokenCountTokenCount = Nothing
    , modalityTokenCountModality = Nothing
    }

-- ** Model

{- | Model
Information about a Generative Language Model.
-}
data Model = Model
  { modelTopK :: !(Maybe Int)
  -- ^ "topK" - For Top-k sampling.  Top-k sampling considers the set of &#x60;top_k&#x60; most probable tokens. This value specifies default to be used by the backend while making the call to the model. If empty, indicates the model doesn&#39;t use top-k sampling, and &#x60;top_k&#x60; isn&#39;t allowed as a generation parameter.
  , modelName :: !(Text)
  -- ^ /Required/ "name" - Required. The resource name of the &#x60;Model&#x60;. Refer to [Model variants](https://ai.google.dev/gemini-api/docs/models/gemini#model-variations) for all allowed values.  Format: &#x60;models/{model}&#x60; with a &#x60;{model}&#x60; naming convention of:  * \&quot;{base_model_id}-{version}\&quot;  Examples:  * &#x60;models/gemini-1.5-flash-001&#x60;
  , modelBaseModelId :: !(Text)
  -- ^ /Required/ "baseModelId" - Required. The name of the base model, pass this to the generation request.  Examples:  * &#x60;gemini-1.5-flash&#x60;
  , modelVersion :: !(Text)
  -- ^ /Required/ "version" - Required. The version number of the model.  This represents the major version (&#x60;1.0&#x60; or &#x60;1.5&#x60;)
  , modelInputTokenLimit :: !(Maybe Int)
  -- ^ "inputTokenLimit" - Maximum number of input tokens allowed for this model.
  , modelTopP :: !(Maybe Float)
  -- ^ "topP" - For [Nucleus sampling](https://ai.google.dev/gemini-api/docs/prompting-strategies#top-p).  Nucleus sampling considers the smallest set of tokens whose probability sum is at least &#x60;top_p&#x60;. This value specifies default to be used by the backend while making the call to the model.
  , modelSupportedGenerationMethods :: !(Maybe [Text])
  -- ^ "supportedGenerationMethods" - The model&#39;s supported generation methods.  The corresponding API method names are defined as Pascal case strings, such as &#x60;generateMessage&#x60; and &#x60;generateContent&#x60;.
  , modelTemperature :: !(Maybe Float)
  -- ^ "temperature" - Controls the randomness of the output.  Values can range over &#x60;[0.0,max_temperature]&#x60;, inclusive. A higher value will produce responses that are more varied, while a value closer to &#x60;0.0&#x60; will typically result in less surprising responses from the model. This value specifies default to be used by the backend while making the call to the model.
  , modelDisplayName :: !(Maybe Text)
  -- ^ "displayName" - The human-readable name of the model. E.g. \&quot;Gemini 1.5 Flash\&quot;.  The name can be up to 128 characters long and can consist of any UTF-8 characters.
  , modelDescription :: !(Maybe Text)
  -- ^ "description" - A short description of the model.
  , modelMaxTemperature :: !(Maybe Float)
  -- ^ "maxTemperature" - The maximum temperature this model can use.
  , modelOutputTokenLimit :: !(Maybe Int)
  -- ^ "outputTokenLimit" - Maximum number of output tokens available for this model.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Model
instance A.FromJSON Model where
  parseJSON = A.withObject "Model" $ \o ->
    Model
      <$> (o .:? "topK")
      <*> (o .: "name")
      <*> (o .: "baseModelId")
      <*> (o .: "version")
      <*> (o .:? "inputTokenLimit")
      <*> (o .:? "topP")
      <*> (o .:? "supportedGenerationMethods")
      <*> (o .:? "temperature")
      <*> (o .:? "displayName")
      <*> (o .:? "description")
      <*> (o .:? "maxTemperature")
      <*> (o .:? "outputTokenLimit")

-- | ToJSON Model
instance A.ToJSON Model where
  toJSON Model {..} =
    _omitNulls
      [ "topK" .= modelTopK
      , "name" .= modelName
      , "baseModelId" .= modelBaseModelId
      , "version" .= modelVersion
      , "inputTokenLimit" .= modelInputTokenLimit
      , "topP" .= modelTopP
      , "supportedGenerationMethods" .= modelSupportedGenerationMethods
      , "temperature" .= modelTemperature
      , "displayName" .= modelDisplayName
      , "description" .= modelDescription
      , "maxTemperature" .= modelMaxTemperature
      , "outputTokenLimit" .= modelOutputTokenLimit
      ]

-- | Construct a value of type 'Model' (by applying it's required fields, if any)
mkModel ::
  -- | 'modelName': Required. The resource name of the `Model`. Refer to [Model variants](https://ai.google.dev/gemini-api/docs/models/gemini#model-variations) for all allowed values.  Format: `models/{model}` with a `{model}` naming convention of:  * \"{base_model_id}-{version}\"  Examples:  * `models/gemini-1.5-flash-001`
  Text ->
  -- | 'modelBaseModelId': Required. The name of the base model, pass this to the generation request.  Examples:  * `gemini-1.5-flash`
  Text ->
  -- | 'modelVersion': Required. The version number of the model.  This represents the major version (`1.0` or `1.5`)
  Text ->
  Model
mkModel modelName modelBaseModelId modelVersion =
  Model
    { modelTopK = Nothing
    , modelName
    , modelBaseModelId
    , modelVersion
    , modelInputTokenLimit = Nothing
    , modelTopP = Nothing
    , modelSupportedGenerationMethods = Nothing
    , modelTemperature = Nothing
    , modelDisplayName = Nothing
    , modelDescription = Nothing
    , modelMaxTemperature = Nothing
    , modelOutputTokenLimit = Nothing
    }

-- ** MultiSpeakerVoiceConfig

{- | MultiSpeakerVoiceConfig
The configuration for the multi-speaker setup.
-}
data MultiSpeakerVoiceConfig = MultiSpeakerVoiceConfig
  { multiSpeakerVoiceConfigSpeakerVoiceConfigs :: !([SpeakerVoiceConfig])
  -- ^ /Required/ "speakerVoiceConfigs" - Required. All the enabled speaker voices.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MultiSpeakerVoiceConfig
instance A.FromJSON MultiSpeakerVoiceConfig where
  parseJSON = A.withObject "MultiSpeakerVoiceConfig" $ \o ->
    MultiSpeakerVoiceConfig
      <$> (o .: "speakerVoiceConfigs")

-- | ToJSON MultiSpeakerVoiceConfig
instance A.ToJSON MultiSpeakerVoiceConfig where
  toJSON MultiSpeakerVoiceConfig {..} =
    _omitNulls
      [ "speakerVoiceConfigs" .= multiSpeakerVoiceConfigSpeakerVoiceConfigs
      ]

-- | Construct a value of type 'MultiSpeakerVoiceConfig' (by applying it's required fields, if any)
mkMultiSpeakerVoiceConfig ::
  -- | 'multiSpeakerVoiceConfigSpeakerVoiceConfigs': Required. All the enabled speaker voices.
  [SpeakerVoiceConfig] ->
  MultiSpeakerVoiceConfig
mkMultiSpeakerVoiceConfig multiSpeakerVoiceConfigSpeakerVoiceConfigs =
  MultiSpeakerVoiceConfig
    { multiSpeakerVoiceConfigSpeakerVoiceConfigs
    }

-- ** Operation

{- | Operation
This resource represents a long-running operation that is the result of a network API call.
-}
data Operation = Operation
  { operationDone :: !(Maybe Bool)
  -- ^ "done" - If the value is &#x60;false&#x60;, it means the operation is still in progress. If &#x60;true&#x60;, the operation is completed, and either &#x60;error&#x60; or &#x60;response&#x60; is available.
  , operationName :: !(Maybe Text)
  -- ^ "name" - The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the &#x60;name&#x60; should be a resource name ending with &#x60;operations/{unique_id}&#x60;.
  , operationError :: !(Maybe Status)
  -- ^ "error" - The error result of the operation in case of failure or cancellation.
  , operationMetadata :: !(Maybe (Map.Map String String))
  -- ^ "metadata" - Service-specific metadata associated with the operation.  It typically contains progress information and common metadata such as create time. Some services might not provide such metadata.  Any method that returns a long-running operation should document the metadata type, if any.
  , operationResponse :: !(Maybe (Map.Map String String))
  -- ^ "response" - The normal, successful response of the operation.  If the original method returns no data on success, such as &#x60;Delete&#x60;, the response is &#x60;google.protobuf.Empty&#x60;.  If the original method is standard &#x60;Get&#x60;/&#x60;Create&#x60;/&#x60;Update&#x60;, the response should be the resource.  For other methods, the response should have the type &#x60;XxxResponse&#x60;, where &#x60;Xxx&#x60; is the original method name.  For example, if the original method name is &#x60;TakeSnapshot()&#x60;, the inferred response type is &#x60;TakeSnapshotResponse&#x60;.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Operation
instance A.FromJSON Operation where
  parseJSON = A.withObject "Operation" $ \o ->
    Operation
      <$> (o .:? "done")
      <*> (o .:? "name")
      <*> (o .:? "error")
      <*> (o .:? "metadata")
      <*> (o .:? "response")

-- | ToJSON Operation
instance A.ToJSON Operation where
  toJSON Operation {..} =
    _omitNulls
      [ "done" .= operationDone
      , "name" .= operationName
      , "error" .= operationError
      , "metadata" .= operationMetadata
      , "response" .= operationResponse
      ]

-- | Construct a value of type 'Operation' (by applying it's required fields, if any)
mkOperation ::
  Operation
mkOperation =
  Operation
    { operationDone = Nothing
    , operationName = Nothing
    , operationError = Nothing
    , operationMetadata = Nothing
    , operationResponse = Nothing
    }

-- ** Part

{- | Part
A datatype containing media that is part of a multi-part `Content` message.  A `Part` consists of data which has an associated datatype. A `Part` can only contain one of the accepted types in `Part.data`.  A `Part` must have a fixed IANA MIME type identifying the type and subtype of the media if the `inline_data` field is filled with raw bytes.
-}
data Part = Part
  { partInlineData :: !(Maybe Blob)
  -- ^ "inlineData" - Inline media bytes.
  , partFunctionResponse :: !(Maybe FunctionResponse)
  -- ^ "functionResponse" - The result output of a &#x60;FunctionCall&#x60; that contains a string representing the &#x60;FunctionDeclaration.name&#x60; and a structured JSON object containing any output from the function is used as context to the model.
  , partCodeExecutionResult :: !(Maybe CodeExecutionResult)
  -- ^ "codeExecutionResult" - Result of executing the &#x60;ExecutableCode&#x60;.
  , partFileData :: !(Maybe FileData)
  -- ^ "fileData" - URI based data.
  , partExecutableCode :: !(Maybe ExecutableCode)
  -- ^ "executableCode" - Code generated by the model that is meant to be executed.
  , partVideoMetadata :: !(Maybe VideoMetadata)
  -- ^ "videoMetadata" - Optional. Video metadata. The metadata should only be specified while the video data is presented in inline_data or file_data.
  , partThought :: !(Maybe Bool)
  -- ^ "thought" - Optional. Indicates if the part is thought from the model.
  , partText :: !(Maybe Text)
  -- ^ "text" - Inline text.
  , partThoughtSignature :: !(Maybe ByteArray)
  -- ^ "thoughtSignature" - Optional. An opaque signature for the thought so it can be reused in subsequent requests.
  , partFunctionCall :: !(Maybe FunctionCall)
  -- ^ "functionCall" - A predicted &#x60;FunctionCall&#x60; returned from the model that contains a string representing the &#x60;FunctionDeclaration.name&#x60; with the arguments and their values.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Part
instance A.FromJSON Part where
  parseJSON = A.withObject "Part" $ \o ->
    Part
      <$> (o .:? "inlineData")
      <*> (o .:? "functionResponse")
      <*> (o .:? "codeExecutionResult")
      <*> (o .:? "fileData")
      <*> (o .:? "executableCode")
      <*> (o .:? "videoMetadata")
      <*> (o .:? "thought")
      <*> (o .:? "text")
      <*> (o .:? "thoughtSignature")
      <*> (o .:? "functionCall")

-- | ToJSON Part
instance A.ToJSON Part where
  toJSON Part {..} =
    _omitNulls
      [ "inlineData" .= partInlineData
      , "functionResponse" .= partFunctionResponse
      , "codeExecutionResult" .= partCodeExecutionResult
      , "fileData" .= partFileData
      , "executableCode" .= partExecutableCode
      , "videoMetadata" .= partVideoMetadata
      , "thought" .= partThought
      , "text" .= partText
      , "thoughtSignature" .= partThoughtSignature
      , "functionCall" .= partFunctionCall
      ]

-- | Construct a value of type 'Part' (by applying it's required fields, if any)
mkPart ::
  Part
mkPart =
  Part
    { partInlineData = Nothing
    , partFunctionResponse = Nothing
    , partCodeExecutionResult = Nothing
    , partFileData = Nothing
    , partExecutableCode = Nothing
    , partVideoMetadata = Nothing
    , partThought = Nothing
    , partText = Nothing
    , partThoughtSignature = Nothing
    , partFunctionCall = Nothing
    }

-- ** Permission

{- | Permission
Permission resource grants user, group or the rest of the world access to the PaLM API resource (e.g. a tuned model, corpus).  A role is a collection of permitted operations that allows users to perform specific actions on PaLM API resources. To make them available to users, groups, or service accounts, you assign roles. When you assign a role, you grant permissions that the role contains.  There are three concentric roles. Each role is a superset of the previous role's permitted operations:  - reader can use the resource (e.g. tuned model, corpus) for inference - writer has reader's permissions and additionally can edit and share - owner has writer's permissions and additionally can delete
-}
data Permission = Permission
  { permissionName :: !(Maybe Text)
  -- ^ /ReadOnly/ "name" - Output only. Identifier. The permission name. A unique name will be generated on create. Examples:     tunedModels/{tuned_model}/permissions/{permission}     corpora/{corpus}/permissions/{permission} Output only.
  , permissionGranteeType :: !(Maybe E'GranteeType)
  -- ^ "granteeType" - Optional. Immutable. The type of the grantee.
  , permissionRole :: !(E'Role)
  -- ^ /Required/ "role" - Required. The role granted by this permission.
  , permissionEmailAddress :: !(Maybe Text)
  -- ^ "emailAddress" - Optional. Immutable. The email address of the user of group which this permission refers. Field is not set when permission&#39;s grantee type is EVERYONE.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Permission
instance A.FromJSON Permission where
  parseJSON = A.withObject "Permission" $ \o ->
    Permission
      <$> (o .:? "name")
      <*> (o .:? "granteeType")
      <*> (o .: "role")
      <*> (o .:? "emailAddress")

-- | ToJSON Permission
instance A.ToJSON Permission where
  toJSON Permission {..} =
    _omitNulls
      [ "name" .= permissionName
      , "granteeType" .= permissionGranteeType
      , "role" .= permissionRole
      , "emailAddress" .= permissionEmailAddress
      ]

-- | Construct a value of type 'Permission' (by applying it's required fields, if any)
mkPermission ::
  -- | 'permissionRole': Required. The role granted by this permission.
  E'Role ->
  Permission
mkPermission permissionRole =
  Permission
    { permissionName = Nothing
    , permissionGranteeType = Nothing
    , permissionRole
    , permissionEmailAddress = Nothing
    }

-- ** PrebuiltVoiceConfig

{- | PrebuiltVoiceConfig
The configuration for the prebuilt speaker to use.
-}
data PrebuiltVoiceConfig = PrebuiltVoiceConfig
  { prebuiltVoiceConfigVoiceName :: !(Maybe Text)
  -- ^ "voiceName" - The name of the preset voice to use.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrebuiltVoiceConfig
instance A.FromJSON PrebuiltVoiceConfig where
  parseJSON = A.withObject "PrebuiltVoiceConfig" $ \o ->
    PrebuiltVoiceConfig
      <$> (o .:? "voiceName")

-- | ToJSON PrebuiltVoiceConfig
instance A.ToJSON PrebuiltVoiceConfig where
  toJSON PrebuiltVoiceConfig {..} =
    _omitNulls
      [ "voiceName" .= prebuiltVoiceConfigVoiceName
      ]

-- | Construct a value of type 'PrebuiltVoiceConfig' (by applying it's required fields, if any)
mkPrebuiltVoiceConfig ::
  PrebuiltVoiceConfig
mkPrebuiltVoiceConfig =
  PrebuiltVoiceConfig
    { prebuiltVoiceConfigVoiceName = Nothing
    }

-- ** PredictLongRunningOperation

{- | PredictLongRunningOperation
This resource represents a long-running operation where metadata and response fields are strongly typed.
-}
data PredictLongRunningOperation = PredictLongRunningOperation
  { predictLongRunningOperationDone :: !(Maybe Bool)
  -- ^ "done" - If the value is &#x60;false&#x60;, it means the operation is still in progress. If &#x60;true&#x60;, the operation is completed, and either &#x60;error&#x60; or &#x60;response&#x60; is available.
  , predictLongRunningOperationName :: !(Maybe Text)
  -- ^ "name" - The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the &#x60;name&#x60; should be a resource name ending with &#x60;operations/{unique_id}&#x60;.
  , predictLongRunningOperationError :: !(Maybe Status)
  -- ^ "error" - The error result of the operation in case of failure or cancellation.
  , predictLongRunningOperationMetadata :: !(Maybe A.Value)
  -- ^ "metadata" - Metadata for PredictLongRunning long running operations.
  , predictLongRunningOperationResponse :: !(Maybe PredictLongRunningResponse)
  -- ^ "response"
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PredictLongRunningOperation
instance A.FromJSON PredictLongRunningOperation where
  parseJSON = A.withObject "PredictLongRunningOperation" $ \o ->
    PredictLongRunningOperation
      <$> (o .:? "done")
      <*> (o .:? "name")
      <*> (o .:? "error")
      <*> (o .:? "metadata")
      <*> (o .:? "response")

-- | ToJSON PredictLongRunningOperation
instance A.ToJSON PredictLongRunningOperation where
  toJSON PredictLongRunningOperation {..} =
    _omitNulls
      [ "done" .= predictLongRunningOperationDone
      , "name" .= predictLongRunningOperationName
      , "error" .= predictLongRunningOperationError
      , "metadata" .= predictLongRunningOperationMetadata
      , "response" .= predictLongRunningOperationResponse
      ]

-- | Construct a value of type 'PredictLongRunningOperation' (by applying it's required fields, if any)
mkPredictLongRunningOperation ::
  PredictLongRunningOperation
mkPredictLongRunningOperation =
  PredictLongRunningOperation
    { predictLongRunningOperationDone = Nothing
    , predictLongRunningOperationName = Nothing
    , predictLongRunningOperationError = Nothing
    , predictLongRunningOperationMetadata = Nothing
    , predictLongRunningOperationResponse = Nothing
    }

-- ** PredictLongRunningRequest

{- | PredictLongRunningRequest
Request message for [PredictionService.PredictLongRunning].
-}
data PredictLongRunningRequest = PredictLongRunningRequest
  { predictLongRunningRequestParameters :: !(Maybe String)
  -- ^ "parameters" - Optional. The parameters that govern the prediction call.
  , predictLongRunningRequestInstances :: !([String])
  -- ^ /Required/ "instances" - Required. The instances that are the input to the prediction call.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PredictLongRunningRequest
instance A.FromJSON PredictLongRunningRequest where
  parseJSON = A.withObject "PredictLongRunningRequest" $ \o ->
    PredictLongRunningRequest
      <$> (o .:? "parameters")
      <*> (o .: "instances")

-- | ToJSON PredictLongRunningRequest
instance A.ToJSON PredictLongRunningRequest where
  toJSON PredictLongRunningRequest {..} =
    _omitNulls
      [ "parameters" .= predictLongRunningRequestParameters
      , "instances" .= predictLongRunningRequestInstances
      ]

-- | Construct a value of type 'PredictLongRunningRequest' (by applying it's required fields, if any)
mkPredictLongRunningRequest ::
  -- | 'predictLongRunningRequestInstances': Required. The instances that are the input to the prediction call.
  [String] ->
  PredictLongRunningRequest
mkPredictLongRunningRequest predictLongRunningRequestInstances =
  PredictLongRunningRequest
    { predictLongRunningRequestParameters = Nothing
    , predictLongRunningRequestInstances
    }

-- ** PredictLongRunningResponse

{- | PredictLongRunningResponse
Response message for [PredictionService.PredictLongRunning]
-}
data PredictLongRunningResponse = PredictLongRunningResponse
  { predictLongRunningResponseGenerateVideoResponse :: !(Maybe GenerateVideoResponse)
  -- ^ "generateVideoResponse" - The response of the video generation prediction.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PredictLongRunningResponse
instance A.FromJSON PredictLongRunningResponse where
  parseJSON = A.withObject "PredictLongRunningResponse" $ \o ->
    PredictLongRunningResponse
      <$> (o .:? "generateVideoResponse")

-- | ToJSON PredictLongRunningResponse
instance A.ToJSON PredictLongRunningResponse where
  toJSON PredictLongRunningResponse {..} =
    _omitNulls
      [ "generateVideoResponse" .= predictLongRunningResponseGenerateVideoResponse
      ]

-- | Construct a value of type 'PredictLongRunningResponse' (by applying it's required fields, if any)
mkPredictLongRunningResponse ::
  PredictLongRunningResponse
mkPredictLongRunningResponse =
  PredictLongRunningResponse
    { predictLongRunningResponseGenerateVideoResponse = Nothing
    }

-- ** PredictRequest

{- | PredictRequest
Request message for PredictionService.Predict.
-}
data PredictRequest = PredictRequest
  { predictRequestInstances :: !([String])
  -- ^ /Required/ "instances" - Required. The instances that are the input to the prediction call.
  , predictRequestParameters :: !(Maybe String)
  -- ^ "parameters" - Optional. The parameters that govern the prediction call.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PredictRequest
instance A.FromJSON PredictRequest where
  parseJSON = A.withObject "PredictRequest" $ \o ->
    PredictRequest
      <$> (o .: "instances")
      <*> (o .:? "parameters")

-- | ToJSON PredictRequest
instance A.ToJSON PredictRequest where
  toJSON PredictRequest {..} =
    _omitNulls
      [ "instances" .= predictRequestInstances
      , "parameters" .= predictRequestParameters
      ]

-- | Construct a value of type 'PredictRequest' (by applying it's required fields, if any)
mkPredictRequest ::
  -- | 'predictRequestInstances': Required. The instances that are the input to the prediction call.
  [String] ->
  PredictRequest
mkPredictRequest predictRequestInstances =
  PredictRequest
    { predictRequestInstances
    , predictRequestParameters = Nothing
    }

-- ** PredictResponse

{- | PredictResponse
Response message for [PredictionService.Predict].
-}
data PredictResponse = PredictResponse
  { predictResponsePredictions :: !(Maybe [String])
  -- ^ "predictions" - The outputs of the prediction call.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PredictResponse
instance A.FromJSON PredictResponse where
  parseJSON = A.withObject "PredictResponse" $ \o ->
    PredictResponse
      <$> (o .:? "predictions")

-- | ToJSON PredictResponse
instance A.ToJSON PredictResponse where
  toJSON PredictResponse {..} =
    _omitNulls
      [ "predictions" .= predictResponsePredictions
      ]

-- | Construct a value of type 'PredictResponse' (by applying it's required fields, if any)
mkPredictResponse ::
  PredictResponse
mkPredictResponse =
  PredictResponse
    { predictResponsePredictions = Nothing
    }

-- ** PromptFeedback

{- | PromptFeedback
A set of the feedback metadata the prompt specified in `GenerateContentRequest.content`.
-}
data PromptFeedback = PromptFeedback
  { promptFeedbackBlockReason :: !(Maybe E'BlockReason)
  -- ^ "blockReason" - Optional. If set, the prompt was blocked and no candidates are returned. Rephrase the prompt.
  , promptFeedbackSafetyRatings :: !(Maybe [SafetyRating])
  -- ^ "safetyRatings" - Ratings for safety of the prompt. There is at most one rating per category.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PromptFeedback
instance A.FromJSON PromptFeedback where
  parseJSON = A.withObject "PromptFeedback" $ \o ->
    PromptFeedback
      <$> (o .:? "blockReason")
      <*> (o .:? "safetyRatings")

-- | ToJSON PromptFeedback
instance A.ToJSON PromptFeedback where
  toJSON PromptFeedback {..} =
    _omitNulls
      [ "blockReason" .= promptFeedbackBlockReason
      , "safetyRatings" .= promptFeedbackSafetyRatings
      ]

-- | Construct a value of type 'PromptFeedback' (by applying it's required fields, if any)
mkPromptFeedback ::
  PromptFeedback
mkPromptFeedback =
  PromptFeedback
    { promptFeedbackBlockReason = Nothing
    , promptFeedbackSafetyRatings = Nothing
    }

-- ** QueryCorpusRequest

{- | QueryCorpusRequest
Request for querying a `Corpus`.
-}
data QueryCorpusRequest = QueryCorpusRequest
  { queryCorpusRequestMetadataFilters :: !(Maybe [MetadataFilter])
  -- ^ "metadataFilters" - Optional. Filter for &#x60;Chunk&#x60; and &#x60;Document&#x60; metadata. Each &#x60;MetadataFilter&#x60; object should correspond to a unique key. Multiple &#x60;MetadataFilter&#x60; objects are joined by logical \&quot;AND\&quot;s.  Example query at document level: (year &gt;&#x3D; 2020 OR year &lt; 2010) AND (genre &#x3D; drama OR genre &#x3D; action)  &#x60;MetadataFilter&#x60; object list:  metadata_filters &#x3D; [  {key &#x3D; \&quot;document.custom_metadata.year\&quot;   conditions &#x3D; [{int_value &#x3D; 2020, operation &#x3D; GREATER_EQUAL},                 {int_value &#x3D; 2010, operation &#x3D; LESS}]},  {key &#x3D; \&quot;document.custom_metadata.year\&quot;   conditions &#x3D; [{int_value &#x3D; 2020, operation &#x3D; GREATER_EQUAL},                 {int_value &#x3D; 2010, operation &#x3D; LESS}]},  {key &#x3D; \&quot;document.custom_metadata.genre\&quot;   conditions &#x3D; [{string_value &#x3D; \&quot;drama\&quot;, operation &#x3D; EQUAL},                 {string_value &#x3D; \&quot;action\&quot;, operation &#x3D; EQUAL}]}]  Example query at chunk level for a numeric range of values: (year &gt; 2015 AND year &lt;&#x3D; 2020)  &#x60;MetadataFilter&#x60; object list:  metadata_filters &#x3D; [  {key &#x3D; \&quot;chunk.custom_metadata.year\&quot;   conditions &#x3D; [{int_value &#x3D; 2015, operation &#x3D; GREATER}]},  {key &#x3D; \&quot;chunk.custom_metadata.year\&quot;   conditions &#x3D; [{int_value &#x3D; 2020, operation &#x3D; LESS_EQUAL}]}]  Note: \&quot;AND\&quot;s for the same key are only supported for numeric values. String values only support \&quot;OR\&quot;s for the same key.
  , queryCorpusRequestQuery :: !(Text)
  -- ^ /Required/ "query" - Required. Query string to perform semantic search.
  , queryCorpusRequestResultsCount :: !(Maybe Int)
  -- ^ "resultsCount" - Optional. The maximum number of &#x60;Chunk&#x60;s to return. The service may return fewer &#x60;Chunk&#x60;s.  If unspecified, at most 10 &#x60;Chunk&#x60;s will be returned. The maximum specified result count is 100.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QueryCorpusRequest
instance A.FromJSON QueryCorpusRequest where
  parseJSON = A.withObject "QueryCorpusRequest" $ \o ->
    QueryCorpusRequest
      <$> (o .:? "metadataFilters")
      <*> (o .: "query")
      <*> (o .:? "resultsCount")

-- | ToJSON QueryCorpusRequest
instance A.ToJSON QueryCorpusRequest where
  toJSON QueryCorpusRequest {..} =
    _omitNulls
      [ "metadataFilters" .= queryCorpusRequestMetadataFilters
      , "query" .= queryCorpusRequestQuery
      , "resultsCount" .= queryCorpusRequestResultsCount
      ]

-- | Construct a value of type 'QueryCorpusRequest' (by applying it's required fields, if any)
mkQueryCorpusRequest ::
  -- | 'queryCorpusRequestQuery': Required. Query string to perform semantic search.
  Text ->
  QueryCorpusRequest
mkQueryCorpusRequest queryCorpusRequestQuery =
  QueryCorpusRequest
    { queryCorpusRequestMetadataFilters = Nothing
    , queryCorpusRequestQuery
    , queryCorpusRequestResultsCount = Nothing
    }

-- ** QueryCorpusResponse

{- | QueryCorpusResponse
Response from `QueryCorpus` containing a list of relevant chunks.
-}
data QueryCorpusResponse = QueryCorpusResponse
  { queryCorpusResponseRelevantChunks :: !(Maybe [RelevantChunk])
  -- ^ "relevantChunks" - The relevant chunks.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QueryCorpusResponse
instance A.FromJSON QueryCorpusResponse where
  parseJSON = A.withObject "QueryCorpusResponse" $ \o ->
    QueryCorpusResponse
      <$> (o .:? "relevantChunks")

-- | ToJSON QueryCorpusResponse
instance A.ToJSON QueryCorpusResponse where
  toJSON QueryCorpusResponse {..} =
    _omitNulls
      [ "relevantChunks" .= queryCorpusResponseRelevantChunks
      ]

-- | Construct a value of type 'QueryCorpusResponse' (by applying it's required fields, if any)
mkQueryCorpusResponse ::
  QueryCorpusResponse
mkQueryCorpusResponse =
  QueryCorpusResponse
    { queryCorpusResponseRelevantChunks = Nothing
    }

-- ** QueryDocumentRequest

{- | QueryDocumentRequest
Request for querying a `Document`.
-}
data QueryDocumentRequest = QueryDocumentRequest
  { queryDocumentRequestQuery :: !(Text)
  -- ^ /Required/ "query" - Required. Query string to perform semantic search.
  , queryDocumentRequestResultsCount :: !(Maybe Int)
  -- ^ "resultsCount" - Optional. The maximum number of &#x60;Chunk&#x60;s to return. The service may return fewer &#x60;Chunk&#x60;s.  If unspecified, at most 10 &#x60;Chunk&#x60;s will be returned. The maximum specified result count is 100.
  , queryDocumentRequestMetadataFilters :: !(Maybe [MetadataFilter])
  -- ^ "metadataFilters" - Optional. Filter for &#x60;Chunk&#x60; metadata. Each &#x60;MetadataFilter&#x60; object should correspond to a unique key. Multiple &#x60;MetadataFilter&#x60; objects are joined by logical \&quot;AND\&quot;s.  Note: &#x60;Document&#x60;-level filtering is not supported for this request because a &#x60;Document&#x60; name is already specified.  Example query: (year &gt;&#x3D; 2020 OR year &lt; 2010) AND (genre &#x3D; drama OR genre &#x3D; action)  &#x60;MetadataFilter&#x60; object list:  metadata_filters &#x3D; [  {key &#x3D; \&quot;chunk.custom_metadata.year\&quot;   conditions &#x3D; [{int_value &#x3D; 2020, operation &#x3D; GREATER_EQUAL},                 {int_value &#x3D; 2010, operation &#x3D; LESS}},  {key &#x3D; \&quot;chunk.custom_metadata.genre\&quot;   conditions &#x3D; [{string_value &#x3D; \&quot;drama\&quot;, operation &#x3D; EQUAL},                 {string_value &#x3D; \&quot;action\&quot;, operation &#x3D; EQUAL}}]  Example query for a numeric range of values: (year &gt; 2015 AND year &lt;&#x3D; 2020)  &#x60;MetadataFilter&#x60; object list:  metadata_filters &#x3D; [  {key &#x3D; \&quot;chunk.custom_metadata.year\&quot;   conditions &#x3D; [{int_value &#x3D; 2015, operation &#x3D; GREATER}]},  {key &#x3D; \&quot;chunk.custom_metadata.year\&quot;   conditions &#x3D; [{int_value &#x3D; 2020, operation &#x3D; LESS_EQUAL}]}]  Note: \&quot;AND\&quot;s for the same key are only supported for numeric values. String values only support \&quot;OR\&quot;s for the same key.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QueryDocumentRequest
instance A.FromJSON QueryDocumentRequest where
  parseJSON = A.withObject "QueryDocumentRequest" $ \o ->
    QueryDocumentRequest
      <$> (o .: "query")
      <*> (o .:? "resultsCount")
      <*> (o .:? "metadataFilters")

-- | ToJSON QueryDocumentRequest
instance A.ToJSON QueryDocumentRequest where
  toJSON QueryDocumentRequest {..} =
    _omitNulls
      [ "query" .= queryDocumentRequestQuery
      , "resultsCount" .= queryDocumentRequestResultsCount
      , "metadataFilters" .= queryDocumentRequestMetadataFilters
      ]

-- | Construct a value of type 'QueryDocumentRequest' (by applying it's required fields, if any)
mkQueryDocumentRequest ::
  -- | 'queryDocumentRequestQuery': Required. Query string to perform semantic search.
  Text ->
  QueryDocumentRequest
mkQueryDocumentRequest queryDocumentRequestQuery =
  QueryDocumentRequest
    { queryDocumentRequestQuery
    , queryDocumentRequestResultsCount = Nothing
    , queryDocumentRequestMetadataFilters = Nothing
    }

-- ** QueryDocumentResponse

{- | QueryDocumentResponse
Response from `QueryDocument` containing a list of relevant chunks.
-}
data QueryDocumentResponse = QueryDocumentResponse
  { queryDocumentResponseRelevantChunks :: !(Maybe [RelevantChunk])
  -- ^ "relevantChunks" - The returned relevant chunks.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QueryDocumentResponse
instance A.FromJSON QueryDocumentResponse where
  parseJSON = A.withObject "QueryDocumentResponse" $ \o ->
    QueryDocumentResponse
      <$> (o .:? "relevantChunks")

-- | ToJSON QueryDocumentResponse
instance A.ToJSON QueryDocumentResponse where
  toJSON QueryDocumentResponse {..} =
    _omitNulls
      [ "relevantChunks" .= queryDocumentResponseRelevantChunks
      ]

-- | Construct a value of type 'QueryDocumentResponse' (by applying it's required fields, if any)
mkQueryDocumentResponse ::
  QueryDocumentResponse
mkQueryDocumentResponse =
  QueryDocumentResponse
    { queryDocumentResponseRelevantChunks = Nothing
    }

-- ** RelevantChunk

{- | RelevantChunk
The information for a chunk relevant to a query.
-}
data RelevantChunk = RelevantChunk
  { relevantChunkChunk :: !(Maybe Chunk)
  -- ^ "chunk" - &#x60;Chunk&#x60; associated with the query.
  , relevantChunkChunkRelevanceScore :: !(Maybe Float)
  -- ^ "chunkRelevanceScore" - &#x60;Chunk&#x60; relevance to the query.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RelevantChunk
instance A.FromJSON RelevantChunk where
  parseJSON = A.withObject "RelevantChunk" $ \o ->
    RelevantChunk
      <$> (o .:? "chunk")
      <*> (o .:? "chunkRelevanceScore")

-- | ToJSON RelevantChunk
instance A.ToJSON RelevantChunk where
  toJSON RelevantChunk {..} =
    _omitNulls
      [ "chunk" .= relevantChunkChunk
      , "chunkRelevanceScore" .= relevantChunkChunkRelevanceScore
      ]

-- | Construct a value of type 'RelevantChunk' (by applying it's required fields, if any)
mkRelevantChunk ::
  RelevantChunk
mkRelevantChunk =
  RelevantChunk
    { relevantChunkChunk = Nothing
    , relevantChunkChunkRelevanceScore = Nothing
    }

-- ** RetrievalMetadata

{- | RetrievalMetadata
Metadata related to retrieval in the grounding flow.
-}
data RetrievalMetadata = RetrievalMetadata
  { retrievalMetadataGoogleSearchDynamicRetrievalScore :: !(Maybe Float)
  -- ^ "googleSearchDynamicRetrievalScore" - Optional. Score indicating how likely information from google search could help answer the prompt. The score is in the range [0, 1], where 0 is the least likely and 1 is the most likely. This score is only populated when google search grounding and dynamic retrieval is enabled. It will be compared to the threshold to determine whether to trigger google search.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrievalMetadata
instance A.FromJSON RetrievalMetadata where
  parseJSON = A.withObject "RetrievalMetadata" $ \o ->
    RetrievalMetadata
      <$> (o .:? "googleSearchDynamicRetrievalScore")

-- | ToJSON RetrievalMetadata
instance A.ToJSON RetrievalMetadata where
  toJSON RetrievalMetadata {..} =
    _omitNulls
      [ "googleSearchDynamicRetrievalScore" .= retrievalMetadataGoogleSearchDynamicRetrievalScore
      ]

-- | Construct a value of type 'RetrievalMetadata' (by applying it's required fields, if any)
mkRetrievalMetadata ::
  RetrievalMetadata
mkRetrievalMetadata =
  RetrievalMetadata
    { retrievalMetadataGoogleSearchDynamicRetrievalScore = Nothing
    }

-- ** SafetyFeedback

{- | SafetyFeedback
Safety feedback for an entire request.  This field is populated if content in the input and/or response is blocked due to safety settings. SafetyFeedback may not exist for every HarmCategory. Each SafetyFeedback will return the safety settings used by the request as well as the lowest HarmProbability that should be allowed in order to return a result.
-}
data SafetyFeedback = SafetyFeedback
  { safetyFeedbackSetting :: !(Maybe SafetySetting)
  -- ^ "setting" - Safety settings applied to the request.
  , safetyFeedbackRating :: !(Maybe SafetyRating)
  -- ^ "rating" - Safety rating evaluated from content.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SafetyFeedback
instance A.FromJSON SafetyFeedback where
  parseJSON = A.withObject "SafetyFeedback" $ \o ->
    SafetyFeedback
      <$> (o .:? "setting")
      <*> (o .:? "rating")

-- | ToJSON SafetyFeedback
instance A.ToJSON SafetyFeedback where
  toJSON SafetyFeedback {..} =
    _omitNulls
      [ "setting" .= safetyFeedbackSetting
      , "rating" .= safetyFeedbackRating
      ]

-- | Construct a value of type 'SafetyFeedback' (by applying it's required fields, if any)
mkSafetyFeedback ::
  SafetyFeedback
mkSafetyFeedback =
  SafetyFeedback
    { safetyFeedbackSetting = Nothing
    , safetyFeedbackRating = Nothing
    }

-- ** SafetyRating

{- | SafetyRating
Safety rating for a piece of content.  The safety rating contains the category of harm and the harm probability level in that category for a piece of content. Content is classified for safety across a number of harm categories and the probability of the harm classification is included here.
-}
data SafetyRating = SafetyRating
  { safetyRatingCategory :: !(HarmCategory)
  -- ^ /Required/ "category" - Required. The category for this rating.
  , safetyRatingBlocked :: !(Maybe Bool)
  -- ^ "blocked" - Was this content blocked because of this rating?
  , safetyRatingProbability :: !(E'Probability)
  -- ^ /Required/ "probability" - Required. The probability of harm for this content.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SafetyRating
instance A.FromJSON SafetyRating where
  parseJSON = A.withObject "SafetyRating" $ \o ->
    SafetyRating
      <$> (o .: "category")
      <*> (o .:? "blocked")
      <*> (o .: "probability")

-- | ToJSON SafetyRating
instance A.ToJSON SafetyRating where
  toJSON SafetyRating {..} =
    _omitNulls
      [ "category" .= safetyRatingCategory
      , "blocked" .= safetyRatingBlocked
      , "probability" .= safetyRatingProbability
      ]

-- | Construct a value of type 'SafetyRating' (by applying it's required fields, if any)
mkSafetyRating ::
  -- | 'safetyRatingCategory': Required. The category for this rating.
  HarmCategory ->
  -- | 'safetyRatingProbability': Required. The probability of harm for this content.
  E'Probability ->
  SafetyRating
mkSafetyRating safetyRatingCategory safetyRatingProbability =
  SafetyRating
    { safetyRatingCategory
    , safetyRatingBlocked = Nothing
    , safetyRatingProbability
    }

-- ** SafetySetting

{- | SafetySetting
Safety setting, affecting the safety-blocking behavior.  Passing a safety setting for a category changes the allowed probability that content is blocked.
-}
data SafetySetting = SafetySetting
  { safetySettingThreshold :: !(E'Threshold)
  -- ^ /Required/ "threshold" - Required. Controls the probability threshold at which harm is blocked.
  , safetySettingCategory :: !(HarmCategory)
  -- ^ /Required/ "category" - Required. The category for this setting.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SafetySetting
instance A.FromJSON SafetySetting where
  parseJSON = A.withObject "SafetySetting" $ \o ->
    SafetySetting
      <$> (o .: "threshold")
      <*> (o .: "category")

-- | ToJSON SafetySetting
instance A.ToJSON SafetySetting where
  toJSON SafetySetting {..} =
    _omitNulls
      [ "threshold" .= safetySettingThreshold
      , "category" .= safetySettingCategory
      ]

-- | Construct a value of type 'SafetySetting' (by applying it's required fields, if any)
mkSafetySetting ::
  -- | 'safetySettingThreshold': Required. Controls the probability threshold at which harm is blocked.
  E'Threshold ->
  -- | 'safetySettingCategory': Required. The category for this setting.
  HarmCategory ->
  SafetySetting
mkSafetySetting safetySettingThreshold safetySettingCategory =
  SafetySetting
    { safetySettingThreshold
    , safetySettingCategory
    }

-- ** Schema

{- | Schema
The `Schema` object allows the definition of input and output data types. These types can be objects, but also primitives and arrays. Represents a select subset of an [OpenAPI 3.0 schema object](https://spec.openapis.org/oas/v3.0.3#schema).
-}
data Schema = Schema
  { schemaItems :: !(Maybe Schema)
  -- ^ "items" - Optional. Schema of the elements of Type.ARRAY.
  , schemaAnyOf :: !(Maybe [Schema])
  -- ^ "anyOf" - Optional. The value should be validated against any (one or more) of the subschemas in the list.
  , schemaMinLength :: !(Maybe Text)
  -- ^ "minLength" - Optional. SCHEMA FIELDS FOR TYPE STRING Minimum length of the Type.STRING
  , schemaMaximum :: !(Maybe Double)
  -- ^ "maximum" - Optional. Maximum value of the Type.INTEGER and Type.NUMBER
  , schemaPropertyOrdering :: !(Maybe [Text])
  -- ^ "propertyOrdering" - Optional. The order of the properties. Not a standard field in open api spec. Used to determine the order of the properties in the response.
  , schemaNullable :: !(Maybe Bool)
  -- ^ "nullable" - Optional. Indicates if the value may be null.
  , schemaRequired :: !(Maybe [Text])
  -- ^ "required" - Optional. Required properties of Type.OBJECT.
  , schemaMinProperties :: !(Maybe Text)
  -- ^ "minProperties" - Optional. Minimum number of the properties for Type.OBJECT.
  , schemaMaxItems :: !(Maybe Text)
  -- ^ "maxItems" - Optional. Maximum number of the elements for Type.ARRAY.
  , schemaExample :: !(Maybe String)
  -- ^ "example" - Optional. Example of the object. Will only populated when the object is the root.
  , schemaTitle :: !(Maybe Text)
  -- ^ "title" - Optional. The title of the schema.
  , schemaMinItems :: !(Maybe Text)
  -- ^ "minItems" - Optional. Minimum number of the elements for Type.ARRAY.
  , schemaDescription :: !(Maybe Text)
  -- ^ "description" - Optional. A brief description of the parameter. This could contain examples of use. Parameter description may be formatted as Markdown.
  , schemaType :: !(ModelType)
  -- ^ /Required/ "type" - Required. Data type.
  , schemaDefault :: !(Maybe String)
  -- ^ "default" - Optional. Default value of the field. Per JSON Schema, this field is intended for documentation generators and doesn&#39;t affect validation. Thus it&#39;s included here and ignored so that developers who send schemas with a &#x60;default&#x60; field don&#39;t get unknown-field errors.
  , schemaMinimum :: !(Maybe Double)
  -- ^ "minimum" - Optional. SCHEMA FIELDS FOR TYPE INTEGER and NUMBER Minimum value of the Type.INTEGER and Type.NUMBER
  , schemaPattern :: !(Maybe Text)
  -- ^ "pattern" - Optional. Pattern of the Type.STRING to restrict a string to a regular expression.
  , schemaProperties :: !(Maybe (Map.Map String Schema))
  -- ^ "properties" - Optional. Properties of Type.OBJECT.
  , schemaMaxProperties :: !(Maybe Text)
  -- ^ "maxProperties" - Optional. Maximum number of the properties for Type.OBJECT.
  , schemaFormat :: !(Maybe Text)
  -- ^ "format" - Optional. The format of the data. This is used only for primitive datatypes. Supported formats:  for NUMBER type: float, double  for INTEGER type: int32, int64  for STRING type: enum, date-time
  , schemaEnum :: !(Maybe [Text])
  -- ^ "enum" - Optional. Possible values of the element of Type.STRING with enum format. For example we can define an Enum Direction as : {type:STRING, format:enum, enum:[\&quot;EAST\&quot;, NORTH\&quot;, \&quot;SOUTH\&quot;, \&quot;WEST\&quot;]}
  , schemaMaxLength :: !(Maybe Text)
  -- ^ "maxLength" - Optional. Maximum length of the Type.STRING
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Schema
instance A.FromJSON Schema where
  parseJSON = A.withObject "Schema" $ \o ->
    Schema
      <$> (o .:? "items")
      <*> (o .:? "anyOf")
      <*> (o .:? "minLength")
      <*> (o .:? "maximum")
      <*> (o .:? "propertyOrdering")
      <*> (o .:? "nullable")
      <*> (o .:? "required")
      <*> (o .:? "minProperties")
      <*> (o .:? "maxItems")
      <*> (o .:? "example")
      <*> (o .:? "title")
      <*> (o .:? "minItems")
      <*> (o .:? "description")
      <*> (o .: "type")
      <*> (o .:? "default")
      <*> (o .:? "minimum")
      <*> (o .:? "pattern")
      <*> (o .:? "properties")
      <*> (o .:? "maxProperties")
      <*> (o .:? "format")
      <*> (o .:? "enum")
      <*> (o .:? "maxLength")

-- | ToJSON Schema
instance A.ToJSON Schema where
  toJSON Schema {..} =
    _omitNulls
      [ "items" .= schemaItems
      , "anyOf" .= schemaAnyOf
      , "minLength" .= schemaMinLength
      , "maximum" .= schemaMaximum
      , "propertyOrdering" .= schemaPropertyOrdering
      , "nullable" .= schemaNullable
      , "required" .= schemaRequired
      , "minProperties" .= schemaMinProperties
      , "maxItems" .= schemaMaxItems
      , "example" .= schemaExample
      , "title" .= schemaTitle
      , "minItems" .= schemaMinItems
      , "description" .= schemaDescription
      , "type" .= schemaType
      , "default" .= schemaDefault
      , "minimum" .= schemaMinimum
      , "pattern" .= schemaPattern
      , "properties" .= schemaProperties
      , "maxProperties" .= schemaMaxProperties
      , "format" .= schemaFormat
      , "enum" .= schemaEnum
      , "maxLength" .= schemaMaxLength
      ]

-- | Construct a value of type 'Schema' (by applying it's required fields, if any)
mkSchema ::
  -- | 'schemaType': Required. Data type.
  ModelType ->
  Schema
mkSchema schemaType =
  Schema
    { schemaItems = Nothing
    , schemaAnyOf = Nothing
    , schemaMinLength = Nothing
    , schemaMaximum = Nothing
    , schemaPropertyOrdering = Nothing
    , schemaNullable = Nothing
    , schemaRequired = Nothing
    , schemaMinProperties = Nothing
    , schemaMaxItems = Nothing
    , schemaExample = Nothing
    , schemaTitle = Nothing
    , schemaMinItems = Nothing
    , schemaDescription = Nothing
    , schemaType
    , schemaDefault = Nothing
    , schemaMinimum = Nothing
    , schemaPattern = Nothing
    , schemaProperties = Nothing
    , schemaMaxProperties = Nothing
    , schemaFormat = Nothing
    , schemaEnum = Nothing
    , schemaMaxLength = Nothing
    }

-- ** SearchEntryPoint

{- | SearchEntryPoint
Google search entry point.
-}
data SearchEntryPoint = SearchEntryPoint
  { searchEntryPointSdkBlob :: !(Maybe ByteArray)
  -- ^ "sdkBlob" - Optional. Base64 encoded JSON representing array of  tuple.
  , searchEntryPointRenderedContent :: !(Maybe Text)
  -- ^ "renderedContent" - Optional. Web content snippet that can be embedded in a web page or an app webview.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchEntryPoint
instance A.FromJSON SearchEntryPoint where
  parseJSON = A.withObject "SearchEntryPoint" $ \o ->
    SearchEntryPoint
      <$> (o .:? "sdkBlob")
      <*> (o .:? "renderedContent")

-- | ToJSON SearchEntryPoint
instance A.ToJSON SearchEntryPoint where
  toJSON SearchEntryPoint {..} =
    _omitNulls
      [ "sdkBlob" .= searchEntryPointSdkBlob
      , "renderedContent" .= searchEntryPointRenderedContent
      ]

-- | Construct a value of type 'SearchEntryPoint' (by applying it's required fields, if any)
mkSearchEntryPoint ::
  SearchEntryPoint
mkSearchEntryPoint =
  SearchEntryPoint
    { searchEntryPointSdkBlob = Nothing
    , searchEntryPointRenderedContent = Nothing
    }

-- ** Segment

{- | Segment
Segment of the content.
-}
data Segment = Segment
  { segmentPartIndex :: !(Maybe Int)
  -- ^ /ReadOnly/ "partIndex" - Output only. The index of a Part object within its parent Content object.
  , segmentStartIndex :: !(Maybe Int)
  -- ^ /ReadOnly/ "startIndex" - Output only. Start index in the given Part, measured in bytes. Offset from the start of the Part, inclusive, starting at zero.
  , segmentText :: !(Maybe Text)
  -- ^ /ReadOnly/ "text" - Output only. The text corresponding to the segment from the response.
  , segmentEndIndex :: !(Maybe Int)
  -- ^ /ReadOnly/ "endIndex" - Output only. End index in the given Part, measured in bytes. Offset from the start of the Part, exclusive, starting at zero.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Segment
instance A.FromJSON Segment where
  parseJSON = A.withObject "Segment" $ \o ->
    Segment
      <$> (o .:? "partIndex")
      <*> (o .:? "startIndex")
      <*> (o .:? "text")
      <*> (o .:? "endIndex")

-- | ToJSON Segment
instance A.ToJSON Segment where
  toJSON Segment {..} =
    _omitNulls
      [ "partIndex" .= segmentPartIndex
      , "startIndex" .= segmentStartIndex
      , "text" .= segmentText
      , "endIndex" .= segmentEndIndex
      ]

-- | Construct a value of type 'Segment' (by applying it's required fields, if any)
mkSegment ::
  Segment
mkSegment =
  Segment
    { segmentPartIndex = Nothing
    , segmentStartIndex = Nothing
    , segmentText = Nothing
    , segmentEndIndex = Nothing
    }

-- ** SemanticRetrieverChunk

{- | SemanticRetrieverChunk
Identifier for a `Chunk` retrieved via Semantic Retriever specified in the `GenerateAnswerRequest` using `SemanticRetrieverConfig`.
-}
data SemanticRetrieverChunk = SemanticRetrieverChunk
  { semanticRetrieverChunkChunk :: !(Maybe Text)
  -- ^ /ReadOnly/ "chunk" - Output only. Name of the &#x60;Chunk&#x60; containing the attributed text. Example: &#x60;corpora/123/documents/abc/chunks/xyz&#x60;
  , semanticRetrieverChunkSource :: !(Maybe Text)
  -- ^ /ReadOnly/ "source" - Output only. Name of the source matching the request&#39;s &#x60;SemanticRetrieverConfig.source&#x60;. Example: &#x60;corpora/123&#x60; or &#x60;corpora/123/documents/abc&#x60;
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SemanticRetrieverChunk
instance A.FromJSON SemanticRetrieverChunk where
  parseJSON = A.withObject "SemanticRetrieverChunk" $ \o ->
    SemanticRetrieverChunk
      <$> (o .:? "chunk")
      <*> (o .:? "source")

-- | ToJSON SemanticRetrieverChunk
instance A.ToJSON SemanticRetrieverChunk where
  toJSON SemanticRetrieverChunk {..} =
    _omitNulls
      [ "chunk" .= semanticRetrieverChunkChunk
      , "source" .= semanticRetrieverChunkSource
      ]

-- | Construct a value of type 'SemanticRetrieverChunk' (by applying it's required fields, if any)
mkSemanticRetrieverChunk ::
  SemanticRetrieverChunk
mkSemanticRetrieverChunk =
  SemanticRetrieverChunk
    { semanticRetrieverChunkChunk = Nothing
    , semanticRetrieverChunkSource = Nothing
    }

-- ** SemanticRetrieverConfig

{- | SemanticRetrieverConfig
Configuration for retrieving grounding content from a `Corpus` or `Document` created using the Semantic Retriever API.
-}
data SemanticRetrieverConfig = SemanticRetrieverConfig
  { semanticRetrieverConfigSource :: !(Text)
  -- ^ /Required/ "source" - Required. Name of the resource for retrieval. Example: &#x60;corpora/123&#x60; or &#x60;corpora/123/documents/abc&#x60;.
  , semanticRetrieverConfigQuery :: !(Content)
  -- ^ /Required/ "query" - Required. Query to use for matching &#x60;Chunk&#x60;s in the given resource by similarity.
  , semanticRetrieverConfigMaxChunksCount :: !(Maybe Int)
  -- ^ "maxChunksCount" - Optional. Maximum number of relevant &#x60;Chunk&#x60;s to retrieve.
  , semanticRetrieverConfigMetadataFilters :: !(Maybe [MetadataFilter])
  -- ^ "metadataFilters" - Optional. Filters for selecting &#x60;Document&#x60;s and/or &#x60;Chunk&#x60;s from the resource.
  , semanticRetrieverConfigMinimumRelevanceScore :: !(Maybe Float)
  -- ^ "minimumRelevanceScore" - Optional. Minimum relevance score for retrieved relevant &#x60;Chunk&#x60;s.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SemanticRetrieverConfig
instance A.FromJSON SemanticRetrieverConfig where
  parseJSON = A.withObject "SemanticRetrieverConfig" $ \o ->
    SemanticRetrieverConfig
      <$> (o .: "source")
      <*> (o .: "query")
      <*> (o .:? "maxChunksCount")
      <*> (o .:? "metadataFilters")
      <*> (o .:? "minimumRelevanceScore")

-- | ToJSON SemanticRetrieverConfig
instance A.ToJSON SemanticRetrieverConfig where
  toJSON SemanticRetrieverConfig {..} =
    _omitNulls
      [ "source" .= semanticRetrieverConfigSource
      , "query" .= semanticRetrieverConfigQuery
      , "maxChunksCount" .= semanticRetrieverConfigMaxChunksCount
      , "metadataFilters" .= semanticRetrieverConfigMetadataFilters
      , "minimumRelevanceScore" .= semanticRetrieverConfigMinimumRelevanceScore
      ]

-- | Construct a value of type 'SemanticRetrieverConfig' (by applying it's required fields, if any)
mkSemanticRetrieverConfig ::
  -- | 'semanticRetrieverConfigSource': Required. Name of the resource for retrieval. Example: `corpora/123` or `corpora/123/documents/abc`.
  Text ->
  -- | 'semanticRetrieverConfigQuery': Required. Query to use for matching `Chunk`s in the given resource by similarity.
  Content ->
  SemanticRetrieverConfig
mkSemanticRetrieverConfig semanticRetrieverConfigSource semanticRetrieverConfigQuery =
  SemanticRetrieverConfig
    { semanticRetrieverConfigSource
    , semanticRetrieverConfigQuery
    , semanticRetrieverConfigMaxChunksCount = Nothing
    , semanticRetrieverConfigMetadataFilters = Nothing
    , semanticRetrieverConfigMinimumRelevanceScore = Nothing
    }

-- ** SpeakerVoiceConfig

{- | SpeakerVoiceConfig
The configuration for a single speaker in a multi speaker setup.
-}
data SpeakerVoiceConfig = SpeakerVoiceConfig
  { speakerVoiceConfigVoiceConfig :: !(VoiceConfig)
  -- ^ /Required/ "voiceConfig" - Required. The configuration for the voice to use.
  , speakerVoiceConfigSpeaker :: !(Text)
  -- ^ /Required/ "speaker" - Required. The name of the speaker to use. Should be the same as in the prompt.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SpeakerVoiceConfig
instance A.FromJSON SpeakerVoiceConfig where
  parseJSON = A.withObject "SpeakerVoiceConfig" $ \o ->
    SpeakerVoiceConfig
      <$> (o .: "voiceConfig")
      <*> (o .: "speaker")

-- | ToJSON SpeakerVoiceConfig
instance A.ToJSON SpeakerVoiceConfig where
  toJSON SpeakerVoiceConfig {..} =
    _omitNulls
      [ "voiceConfig" .= speakerVoiceConfigVoiceConfig
      , "speaker" .= speakerVoiceConfigSpeaker
      ]

-- | Construct a value of type 'SpeakerVoiceConfig' (by applying it's required fields, if any)
mkSpeakerVoiceConfig ::
  -- | 'speakerVoiceConfigVoiceConfig': Required. The configuration for the voice to use.
  VoiceConfig ->
  -- | 'speakerVoiceConfigSpeaker': Required. The name of the speaker to use. Should be the same as in the prompt.
  Text ->
  SpeakerVoiceConfig
mkSpeakerVoiceConfig speakerVoiceConfigVoiceConfig speakerVoiceConfigSpeaker =
  SpeakerVoiceConfig
    { speakerVoiceConfigVoiceConfig
    , speakerVoiceConfigSpeaker
    }

-- ** SpeechConfig

{- | SpeechConfig
The speech generation config.
-}
data SpeechConfig = SpeechConfig
  { speechConfigVoiceConfig :: !(Maybe VoiceConfig)
  -- ^ "voiceConfig" - The configuration in case of single-voice output.
  , speechConfigLanguageCode :: !(Maybe Text)
  -- ^ "languageCode" - Optional. Language code (in BCP 47 format, e.g. \&quot;en-US\&quot;) for speech synthesis.  Valid values are: de-DE, en-AU, en-GB, en-IN, en-US, es-US, fr-FR, hi-IN, pt-BR, ar-XA, es-ES, fr-CA, id-ID, it-IT, ja-JP, tr-TR, vi-VN, bn-IN, gu-IN, kn-IN, ml-IN, mr-IN, ta-IN, te-IN, nl-NL, ko-KR, cmn-CN, pl-PL, ru-RU, and th-TH.
  , speechConfigMultiSpeakerVoiceConfig :: !(Maybe MultiSpeakerVoiceConfig)
  -- ^ "multiSpeakerVoiceConfig" - Optional. The configuration for the multi-speaker setup. It is mutually exclusive with the voice_config field.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SpeechConfig
instance A.FromJSON SpeechConfig where
  parseJSON = A.withObject "SpeechConfig" $ \o ->
    SpeechConfig
      <$> (o .:? "voiceConfig")
      <*> (o .:? "languageCode")
      <*> (o .:? "multiSpeakerVoiceConfig")

-- | ToJSON SpeechConfig
instance A.ToJSON SpeechConfig where
  toJSON SpeechConfig {..} =
    _omitNulls
      [ "voiceConfig" .= speechConfigVoiceConfig
      , "languageCode" .= speechConfigLanguageCode
      , "multiSpeakerVoiceConfig" .= speechConfigMultiSpeakerVoiceConfig
      ]

-- | Construct a value of type 'SpeechConfig' (by applying it's required fields, if any)
mkSpeechConfig ::
  SpeechConfig
mkSpeechConfig =
  SpeechConfig
    { speechConfigVoiceConfig = Nothing
    , speechConfigLanguageCode = Nothing
    , speechConfigMultiSpeakerVoiceConfig = Nothing
    }

-- ** Status

{- | Status
The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details.  You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
-}
data Status = Status
  { statusCode :: !(Maybe Int)
  -- ^ "code" - The status code, which should be an enum value of google.rpc.Code.
  , statusDetails :: !(Maybe [(Map.Map String String)])
  -- ^ "details" - A list of messages that carry the error details.  There is a common set of message types for APIs to use.
  , statusMessage :: !(Maybe Text)
  -- ^ "message" - A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Status
instance A.FromJSON Status where
  parseJSON = A.withObject "Status" $ \o ->
    Status
      <$> (o .:? "code")
      <*> (o .:? "details")
      <*> (o .:? "message")

-- | ToJSON Status
instance A.ToJSON Status where
  toJSON Status {..} =
    _omitNulls
      [ "code" .= statusCode
      , "details" .= statusDetails
      , "message" .= statusMessage
      ]

-- | Construct a value of type 'Status' (by applying it's required fields, if any)
mkStatus ::
  Status
mkStatus =
  Status
    { statusCode = Nothing
    , statusDetails = Nothing
    , statusMessage = Nothing
    }

-- ** StringList

{- | StringList
User provided string values assigned to a single metadata key.
-}
data StringList = StringList
  { stringListValues :: !(Maybe [Text])
  -- ^ "values" - The string values of the metadata to store.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StringList
instance A.FromJSON StringList where
  parseJSON = A.withObject "StringList" $ \o ->
    StringList
      <$> (o .:? "values")

-- | ToJSON StringList
instance A.ToJSON StringList where
  toJSON StringList {..} =
    _omitNulls
      [ "values" .= stringListValues
      ]

-- | Construct a value of type 'StringList' (by applying it's required fields, if any)
mkStringList ::
  StringList
mkStringList =
  StringList
    { stringListValues = Nothing
    }

-- ** TextCompletion

{- | TextCompletion
Output text returned from a model.
-}
data TextCompletion = TextCompletion
  { textCompletionSafetyRatings :: !(Maybe [SafetyRating])
  -- ^ "safetyRatings" - Ratings for the safety of a response.  There is at most one rating per category.
  , textCompletionOutput :: !(Maybe Text)
  -- ^ /ReadOnly/ "output" - Output only. The generated text returned from the model.
  , textCompletionCitationMetadata :: !(Maybe CitationMetadata)
  -- ^ /ReadOnly/ "citationMetadata" - Output only. Citation information for model-generated &#x60;output&#x60; in this &#x60;TextCompletion&#x60;.  This field may be populated with attribution information for any text included in the &#x60;output&#x60;.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TextCompletion
instance A.FromJSON TextCompletion where
  parseJSON = A.withObject "TextCompletion" $ \o ->
    TextCompletion
      <$> (o .:? "safetyRatings")
      <*> (o .:? "output")
      <*> (o .:? "citationMetadata")

-- | ToJSON TextCompletion
instance A.ToJSON TextCompletion where
  toJSON TextCompletion {..} =
    _omitNulls
      [ "safetyRatings" .= textCompletionSafetyRatings
      , "output" .= textCompletionOutput
      , "citationMetadata" .= textCompletionCitationMetadata
      ]

-- | Construct a value of type 'TextCompletion' (by applying it's required fields, if any)
mkTextCompletion ::
  TextCompletion
mkTextCompletion =
  TextCompletion
    { textCompletionSafetyRatings = Nothing
    , textCompletionOutput = Nothing
    , textCompletionCitationMetadata = Nothing
    }

-- ** TextPrompt

{- | TextPrompt
Text given to the model as a prompt.  The Model will use this TextPrompt to Generate a text completion.
-}
data TextPrompt = TextPrompt
  { textPromptText :: !(Text)
  -- ^ /Required/ "text" - Required. The prompt text.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TextPrompt
instance A.FromJSON TextPrompt where
  parseJSON = A.withObject "TextPrompt" $ \o ->
    TextPrompt
      <$> (o .: "text")

-- | ToJSON TextPrompt
instance A.ToJSON TextPrompt where
  toJSON TextPrompt {..} =
    _omitNulls
      [ "text" .= textPromptText
      ]

-- | Construct a value of type 'TextPrompt' (by applying it's required fields, if any)
mkTextPrompt ::
  -- | 'textPromptText': Required. The prompt text.
  Text ->
  TextPrompt
mkTextPrompt textPromptText =
  TextPrompt
    { textPromptText
    }

-- ** ThinkingConfig

{- | ThinkingConfig
Config for thinking features.
-}
data ThinkingConfig = ThinkingConfig
  { thinkingConfigThinkingBudget :: !(Maybe Int)
  -- ^ "thinkingBudget" - The number of thoughts tokens that the model should generate.
  , thinkingConfigIncludeThoughts :: !(Maybe Bool)
  -- ^ "includeThoughts" - Indicates whether to include thoughts in the response. If true, thoughts are returned only when available.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ThinkingConfig
instance A.FromJSON ThinkingConfig where
  parseJSON = A.withObject "ThinkingConfig" $ \o ->
    ThinkingConfig
      <$> (o .:? "thinkingBudget")
      <*> (o .:? "includeThoughts")

-- | ToJSON ThinkingConfig
instance A.ToJSON ThinkingConfig where
  toJSON ThinkingConfig {..} =
    _omitNulls
      [ "thinkingBudget" .= thinkingConfigThinkingBudget
      , "includeThoughts" .= thinkingConfigIncludeThoughts
      ]

-- | Construct a value of type 'ThinkingConfig' (by applying it's required fields, if any)
mkThinkingConfig ::
  ThinkingConfig
mkThinkingConfig =
  ThinkingConfig
    { thinkingConfigThinkingBudget = Nothing
    , thinkingConfigIncludeThoughts = Nothing
    }

-- ** Tool

{- | Tool
Tool details that the model may use to generate response.  A `Tool` is a piece of code that enables the system to interact with external systems to perform an action, or set of actions, outside of knowledge and scope of the model.
-}
data Tool = Tool
  { toolFunctionDeclarations :: !(Maybe [FunctionDeclaration])
  -- ^ "functionDeclarations" - Optional. A list of &#x60;FunctionDeclarations&#x60; available to the model that can be used for function calling.  The model or system does not execute the function. Instead the defined function may be returned as a FunctionCall with arguments to the client side for execution. The model may decide to call a subset of these functions by populating FunctionCall in the response. The next conversation turn may contain a FunctionResponse with the Content.role \&quot;function\&quot; generation context for the next model turn.
  , toolGoogleSearchRetrieval :: !(Maybe GoogleSearchRetrieval)
  -- ^ "googleSearchRetrieval" - Optional. Retrieval tool that is powered by Google search.
  , toolGoogleSearch :: !(Maybe GoogleSearch)
  -- ^ "googleSearch" - Optional. GoogleSearch tool type. Tool to support Google Search in Model. Powered by Google.
  , toolCodeExecution :: !(Maybe A.Value)
  -- ^ "codeExecution" - Optional. Enables the model to execute code as part of generation.
  , toolUrlContext :: !(Maybe A.Value)
  -- ^ "urlContext" - Optional. Tool to support URL context retrieval.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Tool
instance A.FromJSON Tool where
  parseJSON = A.withObject "Tool" $ \o ->
    Tool
      <$> (o .:? "functionDeclarations")
      <*> (o .:? "googleSearchRetrieval")
      <*> (o .:? "googleSearch")
      <*> (o .:? "codeExecution")
      <*> (o .:? "urlContext")

-- | ToJSON Tool
instance A.ToJSON Tool where
  toJSON Tool {..} =
    _omitNulls
      [ "functionDeclarations" .= toolFunctionDeclarations
      , "googleSearchRetrieval" .= toolGoogleSearchRetrieval
      , "googleSearch" .= toolGoogleSearch
      , "codeExecution" .= toolCodeExecution
      , "urlContext" .= toolUrlContext
      ]

-- | Construct a value of type 'Tool' (by applying it's required fields, if any)
mkTool ::
  Tool
mkTool =
  Tool
    { toolFunctionDeclarations = Nothing
    , toolGoogleSearchRetrieval = Nothing
    , toolGoogleSearch = Nothing
    , toolCodeExecution = Nothing
    , toolUrlContext = Nothing
    }

-- ** ToolConfig

{- | ToolConfig
The Tool configuration containing parameters for specifying `Tool` use in the request.
-}
data ToolConfig = ToolConfig
  { toolConfigFunctionCallingConfig :: !(Maybe FunctionCallingConfig)
  -- ^ "functionCallingConfig" - Optional. Function calling config.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ToolConfig
instance A.FromJSON ToolConfig where
  parseJSON = A.withObject "ToolConfig" $ \o ->
    ToolConfig
      <$> (o .:? "functionCallingConfig")

-- | ToJSON ToolConfig
instance A.ToJSON ToolConfig where
  toJSON ToolConfig {..} =
    _omitNulls
      [ "functionCallingConfig" .= toolConfigFunctionCallingConfig
      ]

-- | Construct a value of type 'ToolConfig' (by applying it's required fields, if any)
mkToolConfig ::
  ToolConfig
mkToolConfig =
  ToolConfig
    { toolConfigFunctionCallingConfig = Nothing
    }

-- ** TopCandidates

{- | TopCandidates
Candidates with top log probabilities at each decoding step.
-}
data TopCandidates = TopCandidates
  { topCandidatesCandidates :: !(Maybe [LogprobsResultCandidate])
  -- ^ "candidates" - Sorted by log probability in descending order.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopCandidates
instance A.FromJSON TopCandidates where
  parseJSON = A.withObject "TopCandidates" $ \o ->
    TopCandidates
      <$> (o .:? "candidates")

-- | ToJSON TopCandidates
instance A.ToJSON TopCandidates where
  toJSON TopCandidates {..} =
    _omitNulls
      [ "candidates" .= topCandidatesCandidates
      ]

-- | Construct a value of type 'TopCandidates' (by applying it's required fields, if any)
mkTopCandidates ::
  TopCandidates
mkTopCandidates =
  TopCandidates
    { topCandidatesCandidates = Nothing
    }

-- ** TransferOwnershipRequest

{- | TransferOwnershipRequest
Request to transfer the ownership of the tuned model.
-}
data TransferOwnershipRequest = TransferOwnershipRequest
  { transferOwnershipRequestEmailAddress :: !(Text)
  -- ^ /Required/ "emailAddress" - Required. The email address of the user to whom the tuned model is being transferred to.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransferOwnershipRequest
instance A.FromJSON TransferOwnershipRequest where
  parseJSON = A.withObject "TransferOwnershipRequest" $ \o ->
    TransferOwnershipRequest
      <$> (o .: "emailAddress")

-- | ToJSON TransferOwnershipRequest
instance A.ToJSON TransferOwnershipRequest where
  toJSON TransferOwnershipRequest {..} =
    _omitNulls
      [ "emailAddress" .= transferOwnershipRequestEmailAddress
      ]

-- | Construct a value of type 'TransferOwnershipRequest' (by applying it's required fields, if any)
mkTransferOwnershipRequest ::
  -- | 'transferOwnershipRequestEmailAddress': Required. The email address of the user to whom the tuned model is being transferred to.
  Text ->
  TransferOwnershipRequest
mkTransferOwnershipRequest transferOwnershipRequestEmailAddress =
  TransferOwnershipRequest
    { transferOwnershipRequestEmailAddress
    }

-- ** TunedModel

{- | TunedModel
A fine-tuned model created using ModelService.CreateTunedModel.
-}
data TunedModel = TunedModel
  { tunedModelUpdateTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "updateTime" - Output only. The timestamp when this model was updated.
  , tunedModelName :: !(Maybe Text)
  -- ^ /ReadOnly/ "name" - Output only. The tuned model name. A unique name will be generated on create. Example: &#x60;tunedModels/az2mb0bpw6i&#x60; If display_name is set on create, the id portion of the name will be set by concatenating the words of the display_name with hyphens and adding a random portion for uniqueness.  Example:   * display_name &#x3D; &#x60;Sentence Translator&#x60;  * name &#x3D; &#x60;tunedModels/sentence-translator-u3b7m&#x60;
  , tunedModelCreateTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "createTime" - Output only. The timestamp when this model was created.
  , tunedModelTuningTask :: !(TuningTask)
  -- ^ /Required/ "tuningTask" - Required. The tuning task that creates the tuned model.
  , tunedModelTunedModelSource :: !(Maybe TunedModelSource)
  -- ^ "tunedModelSource" - Optional. TunedModel to use as the starting point for training the new model.
  , tunedModelBaseModel :: !(Maybe Text)
  -- ^ "baseModel" - Immutable. The name of the &#x60;Model&#x60; to tune. Example: &#x60;models/gemini-1.5-flash-001&#x60;
  , tunedModelReaderProjectNumbers :: !(Maybe [Text])
  -- ^ "readerProjectNumbers" - Optional. List of project numbers that have read access to the tuned model.
  , tunedModelDisplayName :: !(Maybe Text)
  -- ^ "displayName" - Optional. The name to display for this model in user interfaces. The display name must be up to 40 characters including spaces.
  , tunedModelTemperature :: !(Maybe Float)
  -- ^ "temperature" - Optional. Controls the randomness of the output.  Values can range over &#x60;[0.0,1.0]&#x60;, inclusive. A value closer to &#x60;1.0&#x60; will produce responses that are more varied, while a value closer to &#x60;0.0&#x60; will typically result in less surprising responses from the model.  This value specifies default to be the one used by the base model while creating the model.
  , tunedModelDescription :: !(Maybe Text)
  -- ^ "description" - Optional. A short description of this model.
  , tunedModelTopP :: !(Maybe Float)
  -- ^ "topP" - Optional. For Nucleus sampling.  Nucleus sampling considers the smallest set of tokens whose probability sum is at least &#x60;top_p&#x60;.  This value specifies default to be the one used by the base model while creating the model.
  , tunedModelTopK :: !(Maybe Int)
  -- ^ "topK" - Optional. For Top-k sampling.  Top-k sampling considers the set of &#x60;top_k&#x60; most probable tokens. This value specifies default to be used by the backend while making the call to the model.  This value specifies default to be the one used by the base model while creating the model.
  , tunedModelState :: !(Maybe E'State3)
  -- ^ /ReadOnly/ "state" - Output only. The state of the tuned model.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TunedModel
instance A.FromJSON TunedModel where
  parseJSON = A.withObject "TunedModel" $ \o ->
    TunedModel
      <$> (o .:? "updateTime")
      <*> (o .:? "name")
      <*> (o .:? "createTime")
      <*> (o .: "tuningTask")
      <*> (o .:? "tunedModelSource")
      <*> (o .:? "baseModel")
      <*> (o .:? "readerProjectNumbers")
      <*> (o .:? "displayName")
      <*> (o .:? "temperature")
      <*> (o .:? "description")
      <*> (o .:? "topP")
      <*> (o .:? "topK")
      <*> (o .:? "state")

-- | ToJSON TunedModel
instance A.ToJSON TunedModel where
  toJSON TunedModel {..} =
    _omitNulls
      [ "updateTime" .= tunedModelUpdateTime
      , "name" .= tunedModelName
      , "createTime" .= tunedModelCreateTime
      , "tuningTask" .= tunedModelTuningTask
      , "tunedModelSource" .= tunedModelTunedModelSource
      , "baseModel" .= tunedModelBaseModel
      , "readerProjectNumbers" .= tunedModelReaderProjectNumbers
      , "displayName" .= tunedModelDisplayName
      , "temperature" .= tunedModelTemperature
      , "description" .= tunedModelDescription
      , "topP" .= tunedModelTopP
      , "topK" .= tunedModelTopK
      , "state" .= tunedModelState
      ]

-- | Construct a value of type 'TunedModel' (by applying it's required fields, if any)
mkTunedModel ::
  -- | 'tunedModelTuningTask': Required. The tuning task that creates the tuned model.
  TuningTask ->
  TunedModel
mkTunedModel tunedModelTuningTask =
  TunedModel
    { tunedModelUpdateTime = Nothing
    , tunedModelName = Nothing
    , tunedModelCreateTime = Nothing
    , tunedModelTuningTask
    , tunedModelTunedModelSource = Nothing
    , tunedModelBaseModel = Nothing
    , tunedModelReaderProjectNumbers = Nothing
    , tunedModelDisplayName = Nothing
    , tunedModelTemperature = Nothing
    , tunedModelDescription = Nothing
    , tunedModelTopP = Nothing
    , tunedModelTopK = Nothing
    , tunedModelState = Nothing
    }

-- ** TunedModelSource

{- | TunedModelSource
Tuned model as a source for training a new model.
-}
data TunedModelSource = TunedModelSource
  { tunedModelSourceTunedModel :: !(Maybe Text)
  -- ^ "tunedModel" - Immutable. The name of the &#x60;TunedModel&#x60; to use as the starting point for training the new model. Example: &#x60;tunedModels/my-tuned-model&#x60;
  , tunedModelSourceBaseModel :: !(Maybe Text)
  -- ^ /ReadOnly/ "baseModel" - Output only. The name of the base &#x60;Model&#x60; this &#x60;TunedModel&#x60; was tuned from. Example: &#x60;models/gemini-1.5-flash-001&#x60;
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TunedModelSource
instance A.FromJSON TunedModelSource where
  parseJSON = A.withObject "TunedModelSource" $ \o ->
    TunedModelSource
      <$> (o .:? "tunedModel")
      <*> (o .:? "baseModel")

-- | ToJSON TunedModelSource
instance A.ToJSON TunedModelSource where
  toJSON TunedModelSource {..} =
    _omitNulls
      [ "tunedModel" .= tunedModelSourceTunedModel
      , "baseModel" .= tunedModelSourceBaseModel
      ]

-- | Construct a value of type 'TunedModelSource' (by applying it's required fields, if any)
mkTunedModelSource ::
  TunedModelSource
mkTunedModelSource =
  TunedModelSource
    { tunedModelSourceTunedModel = Nothing
    , tunedModelSourceBaseModel = Nothing
    }

-- ** TuningExample

{- | TuningExample
A single example for tuning.
-}
data TuningExample = TuningExample
  { tuningExampleTextInput :: !(Maybe Text)
  -- ^ "textInput" - Optional. Text model input.
  , tuningExampleOutput :: !(Text)
  -- ^ /Required/ "output" - Required. The expected model output.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TuningExample
instance A.FromJSON TuningExample where
  parseJSON = A.withObject "TuningExample" $ \o ->
    TuningExample
      <$> (o .:? "textInput")
      <*> (o .: "output")

-- | ToJSON TuningExample
instance A.ToJSON TuningExample where
  toJSON TuningExample {..} =
    _omitNulls
      [ "textInput" .= tuningExampleTextInput
      , "output" .= tuningExampleOutput
      ]

-- | Construct a value of type 'TuningExample' (by applying it's required fields, if any)
mkTuningExample ::
  -- | 'tuningExampleOutput': Required. The expected model output.
  Text ->
  TuningExample
mkTuningExample tuningExampleOutput =
  TuningExample
    { tuningExampleTextInput = Nothing
    , tuningExampleOutput
    }

-- ** TuningExamples

{- | TuningExamples
A set of tuning examples. Can be training or validation data.
-}
data TuningExamples = TuningExamples
  { tuningExamplesExamples :: !(Maybe [TuningExample])
  -- ^ "examples" - The examples. Example input can be for text or discuss, but all examples in a set must be of the same type.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TuningExamples
instance A.FromJSON TuningExamples where
  parseJSON = A.withObject "TuningExamples" $ \o ->
    TuningExamples
      <$> (o .:? "examples")

-- | ToJSON TuningExamples
instance A.ToJSON TuningExamples where
  toJSON TuningExamples {..} =
    _omitNulls
      [ "examples" .= tuningExamplesExamples
      ]

-- | Construct a value of type 'TuningExamples' (by applying it's required fields, if any)
mkTuningExamples ::
  TuningExamples
mkTuningExamples =
  TuningExamples
    { tuningExamplesExamples = Nothing
    }

-- ** TuningSnapshot

{- | TuningSnapshot
Record for a single tuning step.
-}
data TuningSnapshot = TuningSnapshot
  { tuningSnapshotMeanLoss :: !(Maybe Float)
  -- ^ /ReadOnly/ "meanLoss" - Output only. The mean loss of the training examples for this step.
  , tuningSnapshotComputeTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "computeTime" - Output only. The timestamp when this metric was computed.
  , tuningSnapshotStep :: !(Maybe Int)
  -- ^ /ReadOnly/ "step" - Output only. The tuning step.
  , tuningSnapshotEpoch :: !(Maybe Int)
  -- ^ /ReadOnly/ "epoch" - Output only. The epoch this step was part of.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TuningSnapshot
instance A.FromJSON TuningSnapshot where
  parseJSON = A.withObject "TuningSnapshot" $ \o ->
    TuningSnapshot
      <$> (o .:? "meanLoss")
      <*> (o .:? "computeTime")
      <*> (o .:? "step")
      <*> (o .:? "epoch")

-- | ToJSON TuningSnapshot
instance A.ToJSON TuningSnapshot where
  toJSON TuningSnapshot {..} =
    _omitNulls
      [ "meanLoss" .= tuningSnapshotMeanLoss
      , "computeTime" .= tuningSnapshotComputeTime
      , "step" .= tuningSnapshotStep
      , "epoch" .= tuningSnapshotEpoch
      ]

-- | Construct a value of type 'TuningSnapshot' (by applying it's required fields, if any)
mkTuningSnapshot ::
  TuningSnapshot
mkTuningSnapshot =
  TuningSnapshot
    { tuningSnapshotMeanLoss = Nothing
    , tuningSnapshotComputeTime = Nothing
    , tuningSnapshotStep = Nothing
    , tuningSnapshotEpoch = Nothing
    }

-- ** TuningTask

{- | TuningTask
Tuning tasks that create tuned models.
-}
data TuningTask = TuningTask
  { tuningTaskStartTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "startTime" - Output only. The timestamp when tuning this model started.
  , tuningTaskTrainingData :: !(Dataset)
  -- ^ /Required/ "trainingData" - Required. Input only. Immutable. The model training data.
  , tuningTaskHyperparameters :: !(Maybe Hyperparameters)
  -- ^ "hyperparameters" - Immutable. Hyperparameters controlling the tuning process. If not provided, default values will be used.
  , tuningTaskCompleteTime :: !(Maybe DateTime)
  -- ^ /ReadOnly/ "completeTime" - Output only. The timestamp when tuning this model completed.
  , tuningTaskSnapshots :: !(Maybe [TuningSnapshot])
  -- ^ /ReadOnly/ "snapshots" - Output only. Metrics collected during tuning.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TuningTask
instance A.FromJSON TuningTask where
  parseJSON = A.withObject "TuningTask" $ \o ->
    TuningTask
      <$> (o .:? "startTime")
      <*> (o .: "trainingData")
      <*> (o .:? "hyperparameters")
      <*> (o .:? "completeTime")
      <*> (o .:? "snapshots")

-- | ToJSON TuningTask
instance A.ToJSON TuningTask where
  toJSON TuningTask {..} =
    _omitNulls
      [ "startTime" .= tuningTaskStartTime
      , "trainingData" .= tuningTaskTrainingData
      , "hyperparameters" .= tuningTaskHyperparameters
      , "completeTime" .= tuningTaskCompleteTime
      , "snapshots" .= tuningTaskSnapshots
      ]

-- | Construct a value of type 'TuningTask' (by applying it's required fields, if any)
mkTuningTask ::
  -- | 'tuningTaskTrainingData': Required. Input only. Immutable. The model training data.
  Dataset ->
  TuningTask
mkTuningTask tuningTaskTrainingData =
  TuningTask
    { tuningTaskStartTime = Nothing
    , tuningTaskTrainingData
    , tuningTaskHyperparameters = Nothing
    , tuningTaskCompleteTime = Nothing
    , tuningTaskSnapshots = Nothing
    }

-- ** UpdateChunkRequest

{- | UpdateChunkRequest
Request to update a `Chunk`.
-}
data UpdateChunkRequest = UpdateChunkRequest
  { updateChunkRequestUpdateMask :: !(Text)
  -- ^ /Required/ "updateMask" - Required. The list of fields to update. Currently, this only supports updating &#x60;custom_metadata&#x60; and &#x60;data&#x60;.
  , updateChunkRequestChunk :: !(Chunk)
  -- ^ /Required/ "chunk" - Required. The &#x60;Chunk&#x60; to update.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateChunkRequest
instance A.FromJSON UpdateChunkRequest where
  parseJSON = A.withObject "UpdateChunkRequest" $ \o ->
    UpdateChunkRequest
      <$> (o .: "updateMask")
      <*> (o .: "chunk")

-- | ToJSON UpdateChunkRequest
instance A.ToJSON UpdateChunkRequest where
  toJSON UpdateChunkRequest {..} =
    _omitNulls
      [ "updateMask" .= updateChunkRequestUpdateMask
      , "chunk" .= updateChunkRequestChunk
      ]

-- | Construct a value of type 'UpdateChunkRequest' (by applying it's required fields, if any)
mkUpdateChunkRequest ::
  -- | 'updateChunkRequestUpdateMask': Required. The list of fields to update. Currently, this only supports updating `custom_metadata` and `data`.
  Text ->
  -- | 'updateChunkRequestChunk': Required. The `Chunk` to update.
  Chunk ->
  UpdateChunkRequest
mkUpdateChunkRequest updateChunkRequestUpdateMask updateChunkRequestChunk =
  UpdateChunkRequest
    { updateChunkRequestUpdateMask
    , updateChunkRequestChunk
    }

-- ** UrlContextMetadata

{- | UrlContextMetadata
Metadata related to url context retrieval tool.
-}
data UrlContextMetadata = UrlContextMetadata
  { urlContextMetadataUrlMetadata :: !(Maybe [UrlMetadata])
  -- ^ "urlMetadata" - List of url context.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UrlContextMetadata
instance A.FromJSON UrlContextMetadata where
  parseJSON = A.withObject "UrlContextMetadata" $ \o ->
    UrlContextMetadata
      <$> (o .:? "urlMetadata")

-- | ToJSON UrlContextMetadata
instance A.ToJSON UrlContextMetadata where
  toJSON UrlContextMetadata {..} =
    _omitNulls
      [ "urlMetadata" .= urlContextMetadataUrlMetadata
      ]

-- | Construct a value of type 'UrlContextMetadata' (by applying it's required fields, if any)
mkUrlContextMetadata ::
  UrlContextMetadata
mkUrlContextMetadata =
  UrlContextMetadata
    { urlContextMetadataUrlMetadata = Nothing
    }

-- ** UrlMetadata

{- | UrlMetadata
Context of the a single url retrieval.
-}
data UrlMetadata = UrlMetadata
  { urlMetadataRetrievedUrl :: !(Maybe Text)
  -- ^ "retrievedUrl" - Retrieved url by the tool.
  , urlMetadataUrlRetrievalStatus :: !(Maybe E'UrlRetrievalStatus)
  -- ^ "urlRetrievalStatus" - Status of the url retrieval.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UrlMetadata
instance A.FromJSON UrlMetadata where
  parseJSON = A.withObject "UrlMetadata" $ \o ->
    UrlMetadata
      <$> (o .:? "retrievedUrl")
      <*> (o .:? "urlRetrievalStatus")

-- | ToJSON UrlMetadata
instance A.ToJSON UrlMetadata where
  toJSON UrlMetadata {..} =
    _omitNulls
      [ "retrievedUrl" .= urlMetadataRetrievedUrl
      , "urlRetrievalStatus" .= urlMetadataUrlRetrievalStatus
      ]

-- | Construct a value of type 'UrlMetadata' (by applying it's required fields, if any)
mkUrlMetadata ::
  UrlMetadata
mkUrlMetadata =
  UrlMetadata
    { urlMetadataRetrievedUrl = Nothing
    , urlMetadataUrlRetrievalStatus = Nothing
    }

-- ** UsageMetadata

{- | UsageMetadata
Metadata on the generation request's token usage.
-}
data UsageMetadata = UsageMetadata
  { usageMetadataCandidatesTokensDetails :: !(Maybe [ModalityTokenCount])
  -- ^ /ReadOnly/ "candidatesTokensDetails" - Output only. List of modalities that were returned in the response.
  , usageMetadataThoughtsTokenCount :: !(Maybe Int)
  -- ^ /ReadOnly/ "thoughtsTokenCount" - Output only. Number of tokens of thoughts for thinking models.
  , usageMetadataToolUsePromptTokenCount :: !(Maybe Int)
  -- ^ /ReadOnly/ "toolUsePromptTokenCount" - Output only. Number of tokens present in tool-use prompt(s).
  , usageMetadataCachedContentTokenCount :: !(Maybe Int)
  -- ^ "cachedContentTokenCount" - Number of tokens in the cached part of the prompt (the cached content)
  , usageMetadataPromptTokenCount :: !(Maybe Int)
  -- ^ "promptTokenCount" - Number of tokens in the prompt. When &#x60;cached_content&#x60; is set, this is still the total effective prompt size meaning this includes the number of tokens in the cached content.
  , usageMetadataCandidatesTokenCount :: !(Maybe Int)
  -- ^ "candidatesTokenCount" - Total number of tokens across all the generated response candidates.
  , usageMetadataPromptTokensDetails :: !(Maybe [ModalityTokenCount])
  -- ^ /ReadOnly/ "promptTokensDetails" - Output only. List of modalities that were processed in the request input.
  , usageMetadataTotalTokenCount :: !(Maybe Int)
  -- ^ "totalTokenCount" - Total token count for the generation request (prompt + response candidates).
  , usageMetadataCacheTokensDetails :: !(Maybe [ModalityTokenCount])
  -- ^ /ReadOnly/ "cacheTokensDetails" - Output only. List of modalities of the cached content in the request input.
  , usageMetadataToolUsePromptTokensDetails :: !(Maybe [ModalityTokenCount])
  -- ^ /ReadOnly/ "toolUsePromptTokensDetails" - Output only. List of modalities that were processed for tool-use request inputs.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UsageMetadata
instance A.FromJSON UsageMetadata where
  parseJSON = A.withObject "UsageMetadata" $ \o ->
    UsageMetadata
      <$> (o .:? "candidatesTokensDetails")
      <*> (o .:? "thoughtsTokenCount")
      <*> (o .:? "toolUsePromptTokenCount")
      <*> (o .:? "cachedContentTokenCount")
      <*> (o .:? "promptTokenCount")
      <*> (o .:? "candidatesTokenCount")
      <*> (o .:? "promptTokensDetails")
      <*> (o .:? "totalTokenCount")
      <*> (o .:? "cacheTokensDetails")
      <*> (o .:? "toolUsePromptTokensDetails")

-- | ToJSON UsageMetadata
instance A.ToJSON UsageMetadata where
  toJSON UsageMetadata {..} =
    _omitNulls
      [ "candidatesTokensDetails" .= usageMetadataCandidatesTokensDetails
      , "thoughtsTokenCount" .= usageMetadataThoughtsTokenCount
      , "toolUsePromptTokenCount" .= usageMetadataToolUsePromptTokenCount
      , "cachedContentTokenCount" .= usageMetadataCachedContentTokenCount
      , "promptTokenCount" .= usageMetadataPromptTokenCount
      , "candidatesTokenCount" .= usageMetadataCandidatesTokenCount
      , "promptTokensDetails" .= usageMetadataPromptTokensDetails
      , "totalTokenCount" .= usageMetadataTotalTokenCount
      , "cacheTokensDetails" .= usageMetadataCacheTokensDetails
      , "toolUsePromptTokensDetails" .= usageMetadataToolUsePromptTokensDetails
      ]

-- | Construct a value of type 'UsageMetadata' (by applying it's required fields, if any)
mkUsageMetadata ::
  UsageMetadata
mkUsageMetadata =
  UsageMetadata
    { usageMetadataCandidatesTokensDetails = Nothing
    , usageMetadataThoughtsTokenCount = Nothing
    , usageMetadataToolUsePromptTokenCount = Nothing
    , usageMetadataCachedContentTokenCount = Nothing
    , usageMetadataPromptTokenCount = Nothing
    , usageMetadataCandidatesTokenCount = Nothing
    , usageMetadataPromptTokensDetails = Nothing
    , usageMetadataTotalTokenCount = Nothing
    , usageMetadataCacheTokensDetails = Nothing
    , usageMetadataToolUsePromptTokensDetails = Nothing
    }

-- ** Video

{- | Video
Representation of a video.
-}
data Video = Video
  { videoVideo :: !(Maybe ByteArray)
  -- ^ "video" - Raw bytes.
  , videoUri :: !(Maybe Text)
  -- ^ "uri" - Path to another storage.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Video
instance A.FromJSON Video where
  parseJSON = A.withObject "Video" $ \o ->
    Video
      <$> (o .:? "video")
      <*> (o .:? "uri")

-- | ToJSON Video
instance A.ToJSON Video where
  toJSON Video {..} =
    _omitNulls
      [ "video" .= videoVideo
      , "uri" .= videoUri
      ]

-- | Construct a value of type 'Video' (by applying it's required fields, if any)
mkVideo ::
  Video
mkVideo =
  Video
    { videoVideo = Nothing
    , videoUri = Nothing
    }

-- ** VideoFileMetadata

{- | VideoFileMetadata
Metadata for a video `File`.
-}
data VideoFileMetadata = VideoFileMetadata
  { videoFileMetadataVideoDuration :: !(Maybe Text)
  -- ^ "videoDuration" - Duration of the video.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VideoFileMetadata
instance A.FromJSON VideoFileMetadata where
  parseJSON = A.withObject "VideoFileMetadata" $ \o ->
    VideoFileMetadata
      <$> (o .:? "videoDuration")

-- | ToJSON VideoFileMetadata
instance A.ToJSON VideoFileMetadata where
  toJSON VideoFileMetadata {..} =
    _omitNulls
      [ "videoDuration" .= videoFileMetadataVideoDuration
      ]

-- | Construct a value of type 'VideoFileMetadata' (by applying it's required fields, if any)
mkVideoFileMetadata ::
  VideoFileMetadata
mkVideoFileMetadata =
  VideoFileMetadata
    { videoFileMetadataVideoDuration = Nothing
    }

-- ** VideoMetadata

{- | VideoMetadata
Metadata describes the input video content.
-}
data VideoMetadata = VideoMetadata
  { videoMetadataEndOffset :: !(Maybe Text)
  -- ^ "endOffset" - Optional. The end offset of the video.
  , videoMetadataStartOffset :: !(Maybe Text)
  -- ^ "startOffset" - Optional. The start offset of the video.
  , videoMetadataFps :: !(Maybe Double)
  -- ^ "fps" - Optional. The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0].
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VideoMetadata
instance A.FromJSON VideoMetadata where
  parseJSON = A.withObject "VideoMetadata" $ \o ->
    VideoMetadata
      <$> (o .:? "endOffset")
      <*> (o .:? "startOffset")
      <*> (o .:? "fps")

-- | ToJSON VideoMetadata
instance A.ToJSON VideoMetadata where
  toJSON VideoMetadata {..} =
    _omitNulls
      [ "endOffset" .= videoMetadataEndOffset
      , "startOffset" .= videoMetadataStartOffset
      , "fps" .= videoMetadataFps
      ]

-- | Construct a value of type 'VideoMetadata' (by applying it's required fields, if any)
mkVideoMetadata ::
  VideoMetadata
mkVideoMetadata =
  VideoMetadata
    { videoMetadataEndOffset = Nothing
    , videoMetadataStartOffset = Nothing
    , videoMetadataFps = Nothing
    }

-- ** VoiceConfig

{- | VoiceConfig
The configuration for the voice to use.
-}
data VoiceConfig = VoiceConfig
  { voiceConfigPrebuiltVoiceConfig :: !(Maybe PrebuiltVoiceConfig)
  -- ^ "prebuiltVoiceConfig" - The configuration for the prebuilt voice to use.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VoiceConfig
instance A.FromJSON VoiceConfig where
  parseJSON = A.withObject "VoiceConfig" $ \o ->
    VoiceConfig
      <$> (o .:? "prebuiltVoiceConfig")

-- | ToJSON VoiceConfig
instance A.ToJSON VoiceConfig where
  toJSON VoiceConfig {..} =
    _omitNulls
      [ "prebuiltVoiceConfig" .= voiceConfigPrebuiltVoiceConfig
      ]

-- | Construct a value of type 'VoiceConfig' (by applying it's required fields, if any)
mkVoiceConfig ::
  VoiceConfig
mkVoiceConfig =
  VoiceConfig
    { voiceConfigPrebuiltVoiceConfig = Nothing
    }

-- ** Web

{- | Web
Chunk from the web.
-}
data Web = Web
  { webTitle :: !(Maybe Text)
  -- ^ "title" - Title of the chunk.
  , webUri :: !(Maybe Text)
  -- ^ "uri" - URI reference of the chunk.
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Web
instance A.FromJSON Web where
  parseJSON = A.withObject "Web" $ \o ->
    Web
      <$> (o .:? "title")
      <*> (o .:? "uri")

-- | ToJSON Web
instance A.ToJSON Web where
  toJSON Web {..} =
    _omitNulls
      [ "title" .= webTitle
      , "uri" .= webUri
      ]

-- | Construct a value of type 'Web' (by applying it's required fields, if any)
mkWeb ::
  Web
mkWeb =
  Web
    { webTitle = Nothing
    , webUri = Nothing
    }

-- * Enums

-- ** E'Alt

-- | Enum of 'Text'
data E'Alt
  = -- | @"json"@
    E'Alt'Json
  | -- | @"media"@
    E'Alt'Media
  | -- | @"proto"@
    E'Alt'Proto
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Alt where toJSON = A.toJSON . fromE'Alt
instance A.FromJSON E'Alt where parseJSON o = P.either P.fail (pure . P.id) . toE'Alt =<< A.parseJSON o
instance WH.ToHttpApiData E'Alt where toQueryParam = WH.toQueryParam . fromE'Alt
instance WH.FromHttpApiData E'Alt where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Alt
instance MimeRender MimeMultipartFormData E'Alt where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Alt' enum
fromE'Alt :: E'Alt -> Text
fromE'Alt = \case
  E'Alt'Json -> "json"
  E'Alt'Media -> "media"
  E'Alt'Proto -> "proto"

-- | parse 'E'Alt' enum
toE'Alt :: Text -> P.Either String E'Alt
toE'Alt = \case
  "json" -> P.Right E'Alt'Json
  "media" -> P.Right E'Alt'Media
  "proto" -> P.Right E'Alt'Proto
  s -> P.Left $ "toE'Alt: enum parse failure: " P.++ P.show s

-- ** E'AnswerStyle

{- | Enum of 'Text' .
Required. Style in which answers should be returned.
-}
data E'AnswerStyle
  = -- | @"ANSWER_STYLE_UNSPECIFIED"@
    E'AnswerStyle'ANSWER_STYLE_UNSPECIFIED
  | -- | @"ABSTRACTIVE"@
    E'AnswerStyle'ABSTRACTIVE
  | -- | @"EXTRACTIVE"@
    E'AnswerStyle'EXTRACTIVE
  | -- | @"VERBOSE"@
    E'AnswerStyle'VERBOSE
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnswerStyle where toJSON = A.toJSON . fromE'AnswerStyle
instance A.FromJSON E'AnswerStyle where parseJSON o = P.either P.fail (pure . P.id) . toE'AnswerStyle =<< A.parseJSON o
instance WH.ToHttpApiData E'AnswerStyle where toQueryParam = WH.toQueryParam . fromE'AnswerStyle
instance WH.FromHttpApiData E'AnswerStyle where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnswerStyle
instance MimeRender MimeMultipartFormData E'AnswerStyle where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnswerStyle' enum
fromE'AnswerStyle :: E'AnswerStyle -> Text
fromE'AnswerStyle = \case
  E'AnswerStyle'ANSWER_STYLE_UNSPECIFIED -> "ANSWER_STYLE_UNSPECIFIED"
  E'AnswerStyle'ABSTRACTIVE -> "ABSTRACTIVE"
  E'AnswerStyle'EXTRACTIVE -> "EXTRACTIVE"
  E'AnswerStyle'VERBOSE -> "VERBOSE"

-- | parse 'E'AnswerStyle' enum
toE'AnswerStyle :: Text -> P.Either String E'AnswerStyle
toE'AnswerStyle = \case
  "ANSWER_STYLE_UNSPECIFIED" -> P.Right E'AnswerStyle'ANSWER_STYLE_UNSPECIFIED
  "ABSTRACTIVE" -> P.Right E'AnswerStyle'ABSTRACTIVE
  "EXTRACTIVE" -> P.Right E'AnswerStyle'EXTRACTIVE
  "VERBOSE" -> P.Right E'AnswerStyle'VERBOSE
  s -> P.Left $ "toE'AnswerStyle: enum parse failure: " P.++ P.show s

-- ** E'Behavior

{- | Enum of 'Text' .
Optional. Specifies the function Behavior. Currently only supported by the BidiGenerateContent method.
-}
data E'Behavior
  = -- | @"UNSPECIFIED"@
    E'Behavior'UNSPECIFIED
  | -- | @"BLOCKING"@
    E'Behavior'BLOCKING
  | -- | @"NON_BLOCKING"@
    E'Behavior'NON_BLOCKING
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Behavior where toJSON = A.toJSON . fromE'Behavior
instance A.FromJSON E'Behavior where parseJSON o = P.either P.fail (pure . P.id) . toE'Behavior =<< A.parseJSON o
instance WH.ToHttpApiData E'Behavior where toQueryParam = WH.toQueryParam . fromE'Behavior
instance WH.FromHttpApiData E'Behavior where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Behavior
instance MimeRender MimeMultipartFormData E'Behavior where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Behavior' enum
fromE'Behavior :: E'Behavior -> Text
fromE'Behavior = \case
  E'Behavior'UNSPECIFIED -> "UNSPECIFIED"
  E'Behavior'BLOCKING -> "BLOCKING"
  E'Behavior'NON_BLOCKING -> "NON_BLOCKING"

-- | parse 'E'Behavior' enum
toE'Behavior :: Text -> P.Either String E'Behavior
toE'Behavior = \case
  "UNSPECIFIED" -> P.Right E'Behavior'UNSPECIFIED
  "BLOCKING" -> P.Right E'Behavior'BLOCKING
  "NON_BLOCKING" -> P.Right E'Behavior'NON_BLOCKING
  s -> P.Left $ "toE'Behavior: enum parse failure: " P.++ P.show s

-- ** E'BlockReason

{- | Enum of 'Text' .
Optional. If set, the prompt was blocked and no candidates are returned. Rephrase the prompt.
-}
data E'BlockReason
  = -- | @"BLOCK_REASON_UNSPECIFIED"@
    E'BlockReason'BLOCK_REASON_UNSPECIFIED
  | -- | @"SAFETY"@
    E'BlockReason'SAFETY
  | -- | @"OTHER"@
    E'BlockReason'OTHER
  | -- | @"BLOCKLIST"@
    E'BlockReason'BLOCKLIST
  | -- | @"PROHIBITED_CONTENT"@
    E'BlockReason'PROHIBITED_CONTENT
  | -- | @"IMAGE_SAFETY"@
    E'BlockReason'IMAGE_SAFETY
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'BlockReason where toJSON = A.toJSON . fromE'BlockReason
instance A.FromJSON E'BlockReason where parseJSON o = P.either P.fail (pure . P.id) . toE'BlockReason =<< A.parseJSON o
instance WH.ToHttpApiData E'BlockReason where toQueryParam = WH.toQueryParam . fromE'BlockReason
instance WH.FromHttpApiData E'BlockReason where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'BlockReason
instance MimeRender MimeMultipartFormData E'BlockReason where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'BlockReason' enum
fromE'BlockReason :: E'BlockReason -> Text
fromE'BlockReason = \case
  E'BlockReason'BLOCK_REASON_UNSPECIFIED -> "BLOCK_REASON_UNSPECIFIED"
  E'BlockReason'SAFETY -> "SAFETY"
  E'BlockReason'OTHER -> "OTHER"
  E'BlockReason'BLOCKLIST -> "BLOCKLIST"
  E'BlockReason'PROHIBITED_CONTENT -> "PROHIBITED_CONTENT"
  E'BlockReason'IMAGE_SAFETY -> "IMAGE_SAFETY"

-- | parse 'E'BlockReason' enum
toE'BlockReason :: Text -> P.Either String E'BlockReason
toE'BlockReason = \case
  "BLOCK_REASON_UNSPECIFIED" -> P.Right E'BlockReason'BLOCK_REASON_UNSPECIFIED
  "SAFETY" -> P.Right E'BlockReason'SAFETY
  "OTHER" -> P.Right E'BlockReason'OTHER
  "BLOCKLIST" -> P.Right E'BlockReason'BLOCKLIST
  "PROHIBITED_CONTENT" -> P.Right E'BlockReason'PROHIBITED_CONTENT
  "IMAGE_SAFETY" -> P.Right E'BlockReason'IMAGE_SAFETY
  s -> P.Left $ "toE'BlockReason: enum parse failure: " P.++ P.show s

-- ** E'BlockReason2

{- | Enum of 'Text' .
Optional. If set, the input was blocked and no candidates are returned. Rephrase the input.
-}
data E'BlockReason2
  = -- | @"BLOCK_REASON_UNSPECIFIED"@
    E'BlockReason2'BLOCK_REASON_UNSPECIFIED
  | -- | @"SAFETY"@
    E'BlockReason2'SAFETY
  | -- | @"OTHER"@
    E'BlockReason2'OTHER
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'BlockReason2 where toJSON = A.toJSON . fromE'BlockReason2
instance A.FromJSON E'BlockReason2 where parseJSON o = P.either P.fail (pure . P.id) . toE'BlockReason2 =<< A.parseJSON o
instance WH.ToHttpApiData E'BlockReason2 where toQueryParam = WH.toQueryParam . fromE'BlockReason2
instance WH.FromHttpApiData E'BlockReason2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'BlockReason2
instance MimeRender MimeMultipartFormData E'BlockReason2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'BlockReason2' enum
fromE'BlockReason2 :: E'BlockReason2 -> Text
fromE'BlockReason2 = \case
  E'BlockReason2'BLOCK_REASON_UNSPECIFIED -> "BLOCK_REASON_UNSPECIFIED"
  E'BlockReason2'SAFETY -> "SAFETY"
  E'BlockReason2'OTHER -> "OTHER"

-- | parse 'E'BlockReason2' enum
toE'BlockReason2 :: Text -> P.Either String E'BlockReason2
toE'BlockReason2 = \case
  "BLOCK_REASON_UNSPECIFIED" -> P.Right E'BlockReason2'BLOCK_REASON_UNSPECIFIED
  "SAFETY" -> P.Right E'BlockReason2'SAFETY
  "OTHER" -> P.Right E'BlockReason2'OTHER
  s -> P.Left $ "toE'BlockReason2: enum parse failure: " P.++ P.show s

-- ** E'FinishReason

{- | Enum of 'Text' .
Optional. Output only. The reason why the model stopped generating tokens.  If empty, the model has not stopped generating tokens.
-}
data E'FinishReason
  = -- | @"FINISH_REASON_UNSPECIFIED"@
    E'FinishReason'FINISH_REASON_UNSPECIFIED
  | -- | @"STOP"@
    E'FinishReason'STOP
  | -- | @"MAX_TOKENS"@
    E'FinishReason'MAX_TOKENS
  | -- | @"SAFETY"@
    E'FinishReason'SAFETY
  | -- | @"RECITATION"@
    E'FinishReason'RECITATION
  | -- | @"LANGUAGE"@
    E'FinishReason'LANGUAGE
  | -- | @"OTHER"@
    E'FinishReason'OTHER
  | -- | @"BLOCKLIST"@
    E'FinishReason'BLOCKLIST
  | -- | @"PROHIBITED_CONTENT"@
    E'FinishReason'PROHIBITED_CONTENT
  | -- | @"SPII"@
    E'FinishReason'SPII
  | -- | @"MALFORMED_FUNCTION_CALL"@
    E'FinishReason'MALFORMED_FUNCTION_CALL
  | -- | @"IMAGE_SAFETY"@
    E'FinishReason'IMAGE_SAFETY
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FinishReason where toJSON = A.toJSON . fromE'FinishReason
instance A.FromJSON E'FinishReason where parseJSON o = P.either P.fail (pure . P.id) . toE'FinishReason =<< A.parseJSON o
instance WH.ToHttpApiData E'FinishReason where toQueryParam = WH.toQueryParam . fromE'FinishReason
instance WH.FromHttpApiData E'FinishReason where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FinishReason
instance MimeRender MimeMultipartFormData E'FinishReason where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FinishReason' enum
fromE'FinishReason :: E'FinishReason -> Text
fromE'FinishReason = \case
  E'FinishReason'FINISH_REASON_UNSPECIFIED -> "FINISH_REASON_UNSPECIFIED"
  E'FinishReason'STOP -> "STOP"
  E'FinishReason'MAX_TOKENS -> "MAX_TOKENS"
  E'FinishReason'SAFETY -> "SAFETY"
  E'FinishReason'RECITATION -> "RECITATION"
  E'FinishReason'LANGUAGE -> "LANGUAGE"
  E'FinishReason'OTHER -> "OTHER"
  E'FinishReason'BLOCKLIST -> "BLOCKLIST"
  E'FinishReason'PROHIBITED_CONTENT -> "PROHIBITED_CONTENT"
  E'FinishReason'SPII -> "SPII"
  E'FinishReason'MALFORMED_FUNCTION_CALL -> "MALFORMED_FUNCTION_CALL"
  E'FinishReason'IMAGE_SAFETY -> "IMAGE_SAFETY"

-- | parse 'E'FinishReason' enum
toE'FinishReason :: Text -> P.Either String E'FinishReason
toE'FinishReason = \case
  "FINISH_REASON_UNSPECIFIED" -> P.Right E'FinishReason'FINISH_REASON_UNSPECIFIED
  "STOP" -> P.Right E'FinishReason'STOP
  "MAX_TOKENS" -> P.Right E'FinishReason'MAX_TOKENS
  "SAFETY" -> P.Right E'FinishReason'SAFETY
  "RECITATION" -> P.Right E'FinishReason'RECITATION
  "LANGUAGE" -> P.Right E'FinishReason'LANGUAGE
  "OTHER" -> P.Right E'FinishReason'OTHER
  "BLOCKLIST" -> P.Right E'FinishReason'BLOCKLIST
  "PROHIBITED_CONTENT" -> P.Right E'FinishReason'PROHIBITED_CONTENT
  "SPII" -> P.Right E'FinishReason'SPII
  "MALFORMED_FUNCTION_CALL" -> P.Right E'FinishReason'MALFORMED_FUNCTION_CALL
  "IMAGE_SAFETY" -> P.Right E'FinishReason'IMAGE_SAFETY
  s -> P.Left $ "toE'FinishReason: enum parse failure: " P.++ P.show s

-- ** E'GranteeType

{- | Enum of 'Text' .
Optional. Immutable. The type of the grantee.
-}
data E'GranteeType
  = -- | @"GRANTEE_TYPE_UNSPECIFIED"@
    E'GranteeType'GRANTEE_TYPE_UNSPECIFIED
  | -- | @"USER"@
    E'GranteeType'USER
  | -- | @"GROUP"@
    E'GranteeType'GROUP
  | -- | @"EVERYONE"@
    E'GranteeType'EVERYONE
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'GranteeType where toJSON = A.toJSON . fromE'GranteeType
instance A.FromJSON E'GranteeType where parseJSON o = P.either P.fail (pure . P.id) . toE'GranteeType =<< A.parseJSON o
instance WH.ToHttpApiData E'GranteeType where toQueryParam = WH.toQueryParam . fromE'GranteeType
instance WH.FromHttpApiData E'GranteeType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'GranteeType
instance MimeRender MimeMultipartFormData E'GranteeType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'GranteeType' enum
fromE'GranteeType :: E'GranteeType -> Text
fromE'GranteeType = \case
  E'GranteeType'GRANTEE_TYPE_UNSPECIFIED -> "GRANTEE_TYPE_UNSPECIFIED"
  E'GranteeType'USER -> "USER"
  E'GranteeType'GROUP -> "GROUP"
  E'GranteeType'EVERYONE -> "EVERYONE"

-- | parse 'E'GranteeType' enum
toE'GranteeType :: Text -> P.Either String E'GranteeType
toE'GranteeType = \case
  "GRANTEE_TYPE_UNSPECIFIED" -> P.Right E'GranteeType'GRANTEE_TYPE_UNSPECIFIED
  "USER" -> P.Right E'GranteeType'USER
  "GROUP" -> P.Right E'GranteeType'GROUP
  "EVERYONE" -> P.Right E'GranteeType'EVERYONE
  s -> P.Left $ "toE'GranteeType: enum parse failure: " P.++ P.show s

-- ** E'Language

{- | Enum of 'Text' .
Required. Programming language of the `code`.
-}
data E'Language
  = -- | @"LANGUAGE_UNSPECIFIED"@
    E'Language'LANGUAGE_UNSPECIFIED
  | -- | @"PYTHON"@
    E'Language'PYTHON
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Language where toJSON = A.toJSON . fromE'Language
instance A.FromJSON E'Language where parseJSON o = P.either P.fail (pure . P.id) . toE'Language =<< A.parseJSON o
instance WH.ToHttpApiData E'Language where toQueryParam = WH.toQueryParam . fromE'Language
instance WH.FromHttpApiData E'Language where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Language
instance MimeRender MimeMultipartFormData E'Language where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Language' enum
fromE'Language :: E'Language -> Text
fromE'Language = \case
  E'Language'LANGUAGE_UNSPECIFIED -> "LANGUAGE_UNSPECIFIED"
  E'Language'PYTHON -> "PYTHON"

-- | parse 'E'Language' enum
toE'Language :: Text -> P.Either String E'Language
toE'Language = \case
  "LANGUAGE_UNSPECIFIED" -> P.Right E'Language'LANGUAGE_UNSPECIFIED
  "PYTHON" -> P.Right E'Language'PYTHON
  s -> P.Left $ "toE'Language: enum parse failure: " P.++ P.show s

-- ** E'MediaResolution

{- | Enum of 'Text' .
Optional. If specified, the media resolution specified will be used.
-}
data E'MediaResolution
  = -- | @"MEDIA_RESOLUTION_UNSPECIFIED"@
    E'MediaResolution'UNSPECIFIED
  | -- | @"MEDIA_RESOLUTION_LOW"@
    E'MediaResolution'LOW
  | -- | @"MEDIA_RESOLUTION_MEDIUM"@
    E'MediaResolution'MEDIUM
  | -- | @"MEDIA_RESOLUTION_HIGH"@
    E'MediaResolution'HIGH
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'MediaResolution where toJSON = A.toJSON . fromE'MediaResolution
instance A.FromJSON E'MediaResolution where parseJSON o = P.either P.fail (pure . P.id) . toE'MediaResolution =<< A.parseJSON o
instance WH.ToHttpApiData E'MediaResolution where toQueryParam = WH.toQueryParam . fromE'MediaResolution
instance WH.FromHttpApiData E'MediaResolution where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'MediaResolution
instance MimeRender MimeMultipartFormData E'MediaResolution where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'MediaResolution' enum
fromE'MediaResolution :: E'MediaResolution -> Text
fromE'MediaResolution = \case
  E'MediaResolution'UNSPECIFIED -> "MEDIA_RESOLUTION_UNSPECIFIED"
  E'MediaResolution'LOW -> "MEDIA_RESOLUTION_LOW"
  E'MediaResolution'MEDIUM -> "MEDIA_RESOLUTION_MEDIUM"
  E'MediaResolution'HIGH -> "MEDIA_RESOLUTION_HIGH"

-- | parse 'E'MediaResolution' enum
toE'MediaResolution :: Text -> P.Either String E'MediaResolution
toE'MediaResolution = \case
  "MEDIA_RESOLUTION_UNSPECIFIED" -> P.Right E'MediaResolution'UNSPECIFIED
  "MEDIA_RESOLUTION_LOW" -> P.Right E'MediaResolution'LOW
  "MEDIA_RESOLUTION_MEDIUM" -> P.Right E'MediaResolution'MEDIUM
  "MEDIA_RESOLUTION_HIGH" -> P.Right E'MediaResolution'HIGH
  s -> P.Left $ "toE'MediaResolution: enum parse failure: " P.++ P.show s

-- ** E'Mode

{- | Enum of 'Text' .
The mode of the predictor to be used in dynamic retrieval.
-}
data E'Mode
  = -- | @"MODE_UNSPECIFIED"@
    E'Mode'UNSPECIFIED
  | -- | @"MODE_DYNAMIC"@
    E'Mode'DYNAMIC
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Mode where toJSON = A.toJSON . fromE'Mode
instance A.FromJSON E'Mode where parseJSON o = P.either P.fail (pure . P.id) . toE'Mode =<< A.parseJSON o
instance WH.ToHttpApiData E'Mode where toQueryParam = WH.toQueryParam . fromE'Mode
instance WH.FromHttpApiData E'Mode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Mode
instance MimeRender MimeMultipartFormData E'Mode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Mode' enum
fromE'Mode :: E'Mode -> Text
fromE'Mode = \case
  E'Mode'UNSPECIFIED -> "MODE_UNSPECIFIED"
  E'Mode'DYNAMIC -> "MODE_DYNAMIC"

-- | parse 'E'Mode' enum
toE'Mode :: Text -> P.Either String E'Mode
toE'Mode = \case
  "MODE_UNSPECIFIED" -> P.Right E'Mode'UNSPECIFIED
  "MODE_DYNAMIC" -> P.Right E'Mode'DYNAMIC
  s -> P.Left $ "toE'Mode: enum parse failure: " P.++ P.show s

-- ** E'Mode2

{- | Enum of 'Text' .
Optional. Specifies the mode in which function calling should execute. If unspecified, the default value will be set to AUTO.
-}
data E'Mode2
  = -- | @"MODE_UNSPECIFIED"@
    E'Mode2'MODE_UNSPECIFIED
  | -- | @"AUTO"@
    E'Mode2'AUTO
  | -- | @"ANY"@
    E'Mode2'ANY
  | -- | @"NONE"@
    E'Mode2'NONE
  | -- | @"VALIDATED"@
    E'Mode2'VALIDATED
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Mode2 where toJSON = A.toJSON . fromE'Mode2
instance A.FromJSON E'Mode2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Mode2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Mode2 where toQueryParam = WH.toQueryParam . fromE'Mode2
instance WH.FromHttpApiData E'Mode2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Mode2
instance MimeRender MimeMultipartFormData E'Mode2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Mode2' enum
fromE'Mode2 :: E'Mode2 -> Text
fromE'Mode2 = \case
  E'Mode2'MODE_UNSPECIFIED -> "MODE_UNSPECIFIED"
  E'Mode2'AUTO -> "AUTO"
  E'Mode2'ANY -> "ANY"
  E'Mode2'NONE -> "NONE"
  E'Mode2'VALIDATED -> "VALIDATED"

-- | parse 'E'Mode2' enum
toE'Mode2 :: Text -> P.Either String E'Mode2
toE'Mode2 = \case
  "MODE_UNSPECIFIED" -> P.Right E'Mode2'MODE_UNSPECIFIED
  "AUTO" -> P.Right E'Mode2'AUTO
  "ANY" -> P.Right E'Mode2'ANY
  "NONE" -> P.Right E'Mode2'NONE
  "VALIDATED" -> P.Right E'Mode2'VALIDATED
  s -> P.Left $ "toE'Mode2: enum parse failure: " P.++ P.show s

-- ** E'Operation

{- | Enum of 'Text' .
Required. Operator applied to the given key-value pair to trigger the condition.
-}
data E'Operation
  = -- | @"OPERATOR_UNSPECIFIED"@
    E'Operation'OPERATOR_UNSPECIFIED
  | -- | @"LESS"@
    E'Operation'LESS
  | -- | @"LESS_EQUAL"@
    E'Operation'LESS_EQUAL
  | -- | @"EQUAL"@
    E'Operation'EQUAL
  | -- | @"GREATER_EQUAL"@
    E'Operation'GREATER_EQUAL
  | -- | @"GREATER"@
    E'Operation'GREATER
  | -- | @"NOT_EQUAL"@
    E'Operation'NOT_EQUAL
  | -- | @"INCLUDES"@
    E'Operation'INCLUDES
  | -- | @"EXCLUDES"@
    E'Operation'EXCLUDES
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Operation where toJSON = A.toJSON . fromE'Operation
instance A.FromJSON E'Operation where parseJSON o = P.either P.fail (pure . P.id) . toE'Operation =<< A.parseJSON o
instance WH.ToHttpApiData E'Operation where toQueryParam = WH.toQueryParam . fromE'Operation
instance WH.FromHttpApiData E'Operation where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Operation
instance MimeRender MimeMultipartFormData E'Operation where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Operation' enum
fromE'Operation :: E'Operation -> Text
fromE'Operation = \case
  E'Operation'OPERATOR_UNSPECIFIED -> "OPERATOR_UNSPECIFIED"
  E'Operation'LESS -> "LESS"
  E'Operation'LESS_EQUAL -> "LESS_EQUAL"
  E'Operation'EQUAL -> "EQUAL"
  E'Operation'GREATER_EQUAL -> "GREATER_EQUAL"
  E'Operation'GREATER -> "GREATER"
  E'Operation'NOT_EQUAL -> "NOT_EQUAL"
  E'Operation'INCLUDES -> "INCLUDES"
  E'Operation'EXCLUDES -> "EXCLUDES"

-- | parse 'E'Operation' enum
toE'Operation :: Text -> P.Either String E'Operation
toE'Operation = \case
  "OPERATOR_UNSPECIFIED" -> P.Right E'Operation'OPERATOR_UNSPECIFIED
  "LESS" -> P.Right E'Operation'LESS
  "LESS_EQUAL" -> P.Right E'Operation'LESS_EQUAL
  "EQUAL" -> P.Right E'Operation'EQUAL
  "GREATER_EQUAL" -> P.Right E'Operation'GREATER_EQUAL
  "GREATER" -> P.Right E'Operation'GREATER
  "NOT_EQUAL" -> P.Right E'Operation'NOT_EQUAL
  "INCLUDES" -> P.Right E'Operation'INCLUDES
  "EXCLUDES" -> P.Right E'Operation'EXCLUDES
  s -> P.Left $ "toE'Operation: enum parse failure: " P.++ P.show s

-- ** E'Outcome

{- | Enum of 'Text' .
Required. Outcome of the code execution.
-}
data E'Outcome
  = -- | @"OUTCOME_UNSPECIFIED"@
    E'Outcome'UNSPECIFIED
  | -- | @"OUTCOME_OK"@
    E'Outcome'OK
  | -- | @"OUTCOME_FAILED"@
    E'Outcome'FAILED
  | -- | @"OUTCOME_DEADLINE_EXCEEDED"@
    E'Outcome'DEADLINE_EXCEEDED
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Outcome where toJSON = A.toJSON . fromE'Outcome
instance A.FromJSON E'Outcome where parseJSON o = P.either P.fail (pure . P.id) . toE'Outcome =<< A.parseJSON o
instance WH.ToHttpApiData E'Outcome where toQueryParam = WH.toQueryParam . fromE'Outcome
instance WH.FromHttpApiData E'Outcome where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Outcome
instance MimeRender MimeMultipartFormData E'Outcome where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Outcome' enum
fromE'Outcome :: E'Outcome -> Text
fromE'Outcome = \case
  E'Outcome'UNSPECIFIED -> "OUTCOME_UNSPECIFIED"
  E'Outcome'OK -> "OUTCOME_OK"
  E'Outcome'FAILED -> "OUTCOME_FAILED"
  E'Outcome'DEADLINE_EXCEEDED -> "OUTCOME_DEADLINE_EXCEEDED"

-- | parse 'E'Outcome' enum
toE'Outcome :: Text -> P.Either String E'Outcome
toE'Outcome = \case
  "OUTCOME_UNSPECIFIED" -> P.Right E'Outcome'UNSPECIFIED
  "OUTCOME_OK" -> P.Right E'Outcome'OK
  "OUTCOME_FAILED" -> P.Right E'Outcome'FAILED
  "OUTCOME_DEADLINE_EXCEEDED" -> P.Right E'Outcome'DEADLINE_EXCEEDED
  s -> P.Left $ "toE'Outcome: enum parse failure: " P.++ P.show s

-- ** E'Probability

{- | Enum of 'Text' .
Required. The probability of harm for this content.
-}
data E'Probability
  = -- | @"HARM_PROBABILITY_UNSPECIFIED"@
    E'Probability'HARM_PROBABILITY_UNSPECIFIED
  | -- | @"NEGLIGIBLE"@
    E'Probability'NEGLIGIBLE
  | -- | @"LOW"@
    E'Probability'LOW
  | -- | @"MEDIUM"@
    E'Probability'MEDIUM
  | -- | @"HIGH"@
    E'Probability'HIGH
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Probability where toJSON = A.toJSON . fromE'Probability
instance A.FromJSON E'Probability where parseJSON o = P.either P.fail (pure . P.id) . toE'Probability =<< A.parseJSON o
instance WH.ToHttpApiData E'Probability where toQueryParam = WH.toQueryParam . fromE'Probability
instance WH.FromHttpApiData E'Probability where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Probability
instance MimeRender MimeMultipartFormData E'Probability where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Probability' enum
fromE'Probability :: E'Probability -> Text
fromE'Probability = \case
  E'Probability'HARM_PROBABILITY_UNSPECIFIED -> "HARM_PROBABILITY_UNSPECIFIED"
  E'Probability'NEGLIGIBLE -> "NEGLIGIBLE"
  E'Probability'LOW -> "LOW"
  E'Probability'MEDIUM -> "MEDIUM"
  E'Probability'HIGH -> "HIGH"

-- | parse 'E'Probability' enum
toE'Probability :: Text -> P.Either String E'Probability
toE'Probability = \case
  "HARM_PROBABILITY_UNSPECIFIED" -> P.Right E'Probability'HARM_PROBABILITY_UNSPECIFIED
  "NEGLIGIBLE" -> P.Right E'Probability'NEGLIGIBLE
  "LOW" -> P.Right E'Probability'LOW
  "MEDIUM" -> P.Right E'Probability'MEDIUM
  "HIGH" -> P.Right E'Probability'HIGH
  s -> P.Left $ "toE'Probability: enum parse failure: " P.++ P.show s

-- ** E'Reason

{- | Enum of 'Text' .
The reason content was blocked during request processing.
-}
data E'Reason
  = -- | @"BLOCKED_REASON_UNSPECIFIED"@
    E'Reason'BLOCKED_REASON_UNSPECIFIED
  | -- | @"SAFETY"@
    E'Reason'SAFETY
  | -- | @"OTHER"@
    E'Reason'OTHER
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Reason where toJSON = A.toJSON . fromE'Reason
instance A.FromJSON E'Reason where parseJSON o = P.either P.fail (pure . P.id) . toE'Reason =<< A.parseJSON o
instance WH.ToHttpApiData E'Reason where toQueryParam = WH.toQueryParam . fromE'Reason
instance WH.FromHttpApiData E'Reason where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Reason
instance MimeRender MimeMultipartFormData E'Reason where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Reason' enum
fromE'Reason :: E'Reason -> Text
fromE'Reason = \case
  E'Reason'BLOCKED_REASON_UNSPECIFIED -> "BLOCKED_REASON_UNSPECIFIED"
  E'Reason'SAFETY -> "SAFETY"
  E'Reason'OTHER -> "OTHER"

-- | parse 'E'Reason' enum
toE'Reason :: Text -> P.Either String E'Reason
toE'Reason = \case
  "BLOCKED_REASON_UNSPECIFIED" -> P.Right E'Reason'BLOCKED_REASON_UNSPECIFIED
  "SAFETY" -> P.Right E'Reason'SAFETY
  "OTHER" -> P.Right E'Reason'OTHER
  s -> P.Left $ "toE'Reason: enum parse failure: " P.++ P.show s

-- ** E'ResponseModalities

-- | Enum of 'Text'
data E'ResponseModalities
  = -- | @"MODALITY_UNSPECIFIED"@
    E'ResponseModalities'MODALITY_UNSPECIFIED
  | -- | @"TEXT"@
    E'ResponseModalities'TEXT
  | -- | @"IMAGE"@
    E'ResponseModalities'IMAGE
  | -- | @"AUDIO"@
    E'ResponseModalities'AUDIO
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ResponseModalities where toJSON = A.toJSON . fromE'ResponseModalities
instance A.FromJSON E'ResponseModalities where parseJSON o = P.either P.fail (pure . P.id) . toE'ResponseModalities =<< A.parseJSON o
instance WH.ToHttpApiData E'ResponseModalities where toQueryParam = WH.toQueryParam . fromE'ResponseModalities
instance WH.FromHttpApiData E'ResponseModalities where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ResponseModalities
instance MimeRender MimeMultipartFormData E'ResponseModalities where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ResponseModalities' enum
fromE'ResponseModalities :: E'ResponseModalities -> Text
fromE'ResponseModalities = \case
  E'ResponseModalities'MODALITY_UNSPECIFIED -> "MODALITY_UNSPECIFIED"
  E'ResponseModalities'TEXT -> "TEXT"
  E'ResponseModalities'IMAGE -> "IMAGE"
  E'ResponseModalities'AUDIO -> "AUDIO"

-- | parse 'E'ResponseModalities' enum
toE'ResponseModalities :: Text -> P.Either String E'ResponseModalities
toE'ResponseModalities = \case
  "MODALITY_UNSPECIFIED" -> P.Right E'ResponseModalities'MODALITY_UNSPECIFIED
  "TEXT" -> P.Right E'ResponseModalities'TEXT
  "IMAGE" -> P.Right E'ResponseModalities'IMAGE
  "AUDIO" -> P.Right E'ResponseModalities'AUDIO
  s -> P.Left $ "toE'ResponseModalities: enum parse failure: " P.++ P.show s

-- ** E'Role

{- | Enum of 'Text' .
Required. The role granted by this permission.
-}
data E'Role
  = -- | @"ROLE_UNSPECIFIED"@
    E'Role'ROLE_UNSPECIFIED
  | -- | @"OWNER"@
    E'Role'OWNER
  | -- | @"WRITER"@
    E'Role'WRITER
  | -- | @"READER"@
    E'Role'READER
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role where toJSON = A.toJSON . fromE'Role
instance A.FromJSON E'Role where parseJSON o = P.either P.fail (pure . P.id) . toE'Role =<< A.parseJSON o
instance WH.ToHttpApiData E'Role where toQueryParam = WH.toQueryParam . fromE'Role
instance WH.FromHttpApiData E'Role where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role
instance MimeRender MimeMultipartFormData E'Role where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role' enum
fromE'Role :: E'Role -> Text
fromE'Role = \case
  E'Role'ROLE_UNSPECIFIED -> "ROLE_UNSPECIFIED"
  E'Role'OWNER -> "OWNER"
  E'Role'WRITER -> "WRITER"
  E'Role'READER -> "READER"

-- | parse 'E'Role' enum
toE'Role :: Text -> P.Either String E'Role
toE'Role = \case
  "ROLE_UNSPECIFIED" -> P.Right E'Role'ROLE_UNSPECIFIED
  "OWNER" -> P.Right E'Role'OWNER
  "WRITER" -> P.Right E'Role'WRITER
  "READER" -> P.Right E'Role'READER
  s -> P.Left $ "toE'Role: enum parse failure: " P.++ P.show s

-- ** E'Scheduling

{- | Enum of 'Text' .
Optional. Specifies how the response should be scheduled in the conversation. Only applicable to NON_BLOCKING function calls, is ignored otherwise. Defaults to WHEN_IDLE.
-}
data E'Scheduling
  = -- | @"SCHEDULING_UNSPECIFIED"@
    E'Scheduling'SCHEDULING_UNSPECIFIED
  | -- | @"SILENT"@
    E'Scheduling'SILENT
  | -- | @"WHEN_IDLE"@
    E'Scheduling'WHEN_IDLE
  | -- | @"INTERRUPT"@
    E'Scheduling'INTERRUPT
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Scheduling where toJSON = A.toJSON . fromE'Scheduling
instance A.FromJSON E'Scheduling where parseJSON o = P.either P.fail (pure . P.id) . toE'Scheduling =<< A.parseJSON o
instance WH.ToHttpApiData E'Scheduling where toQueryParam = WH.toQueryParam . fromE'Scheduling
instance WH.FromHttpApiData E'Scheduling where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Scheduling
instance MimeRender MimeMultipartFormData E'Scheduling where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Scheduling' enum
fromE'Scheduling :: E'Scheduling -> Text
fromE'Scheduling = \case
  E'Scheduling'SCHEDULING_UNSPECIFIED -> "SCHEDULING_UNSPECIFIED"
  E'Scheduling'SILENT -> "SILENT"
  E'Scheduling'WHEN_IDLE -> "WHEN_IDLE"
  E'Scheduling'INTERRUPT -> "INTERRUPT"

-- | parse 'E'Scheduling' enum
toE'Scheduling :: Text -> P.Either String E'Scheduling
toE'Scheduling = \case
  "SCHEDULING_UNSPECIFIED" -> P.Right E'Scheduling'SCHEDULING_UNSPECIFIED
  "SILENT" -> P.Right E'Scheduling'SILENT
  "WHEN_IDLE" -> P.Right E'Scheduling'WHEN_IDLE
  "INTERRUPT" -> P.Right E'Scheduling'INTERRUPT
  s -> P.Left $ "toE'Scheduling: enum parse failure: " P.++ P.show s

-- ** E'Source

{- | Enum of 'Text' .
Source of the File.
-}
data E'Source
  = -- | @"SOURCE_UNSPECIFIED"@
    E'Source'SOURCE_UNSPECIFIED
  | -- | @"UPLOADED"@
    E'Source'UPLOADED
  | -- | @"GENERATED"@
    E'Source'GENERATED
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Source where toJSON = A.toJSON . fromE'Source
instance A.FromJSON E'Source where parseJSON o = P.either P.fail (pure . P.id) . toE'Source =<< A.parseJSON o
instance WH.ToHttpApiData E'Source where toQueryParam = WH.toQueryParam . fromE'Source
instance WH.FromHttpApiData E'Source where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Source
instance MimeRender MimeMultipartFormData E'Source where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Source' enum
fromE'Source :: E'Source -> Text
fromE'Source = \case
  E'Source'SOURCE_UNSPECIFIED -> "SOURCE_UNSPECIFIED"
  E'Source'UPLOADED -> "UPLOADED"
  E'Source'GENERATED -> "GENERATED"

-- | parse 'E'Source' enum
toE'Source :: Text -> P.Either String E'Source
toE'Source = \case
  "SOURCE_UNSPECIFIED" -> P.Right E'Source'SOURCE_UNSPECIFIED
  "UPLOADED" -> P.Right E'Source'UPLOADED
  "GENERATED" -> P.Right E'Source'GENERATED
  s -> P.Left $ "toE'Source: enum parse failure: " P.++ P.show s

-- ** E'State

{- | Enum of 'Text' .
Output only. Processing state of the File.
-}
data E'State
  = -- | @"STATE_UNSPECIFIED"@
    E'State'STATE_UNSPECIFIED
  | -- | @"PROCESSING"@
    E'State'PROCESSING
  | -- | @"ACTIVE"@
    E'State'ACTIVE
  | -- | @"FAILED"@
    E'State'FAILED
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State where toJSON = A.toJSON . fromE'State
instance A.FromJSON E'State where parseJSON o = P.either P.fail (pure . P.id) . toE'State =<< A.parseJSON o
instance WH.ToHttpApiData E'State where toQueryParam = WH.toQueryParam . fromE'State
instance WH.FromHttpApiData E'State where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State
instance MimeRender MimeMultipartFormData E'State where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State' enum
fromE'State :: E'State -> Text
fromE'State = \case
  E'State'STATE_UNSPECIFIED -> "STATE_UNSPECIFIED"
  E'State'PROCESSING -> "PROCESSING"
  E'State'ACTIVE -> "ACTIVE"
  E'State'FAILED -> "FAILED"

-- | parse 'E'State' enum
toE'State :: Text -> P.Either String E'State
toE'State = \case
  "STATE_UNSPECIFIED" -> P.Right E'State'STATE_UNSPECIFIED
  "PROCESSING" -> P.Right E'State'PROCESSING
  "ACTIVE" -> P.Right E'State'ACTIVE
  "FAILED" -> P.Right E'State'FAILED
  s -> P.Left $ "toE'State: enum parse failure: " P.++ P.show s

-- ** E'State2

{- | Enum of 'Text' .
Output only. The state of the GeneratedFile.
-}
data E'State2
  = -- | @"STATE_UNSPECIFIED"@
    E'State2'STATE_UNSPECIFIED
  | -- | @"GENERATING"@
    E'State2'GENERATING
  | -- | @"GENERATED"@
    E'State2'GENERATED
  | -- | @"FAILED"@
    E'State2'FAILED
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State2 where toJSON = A.toJSON . fromE'State2
instance A.FromJSON E'State2 where parseJSON o = P.either P.fail (pure . P.id) . toE'State2 =<< A.parseJSON o
instance WH.ToHttpApiData E'State2 where toQueryParam = WH.toQueryParam . fromE'State2
instance WH.FromHttpApiData E'State2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State2
instance MimeRender MimeMultipartFormData E'State2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State2' enum
fromE'State2 :: E'State2 -> Text
fromE'State2 = \case
  E'State2'STATE_UNSPECIFIED -> "STATE_UNSPECIFIED"
  E'State2'GENERATING -> "GENERATING"
  E'State2'GENERATED -> "GENERATED"
  E'State2'FAILED -> "FAILED"

-- | parse 'E'State2' enum
toE'State2 :: Text -> P.Either String E'State2
toE'State2 = \case
  "STATE_UNSPECIFIED" -> P.Right E'State2'STATE_UNSPECIFIED
  "GENERATING" -> P.Right E'State2'GENERATING
  "GENERATED" -> P.Right E'State2'GENERATED
  "FAILED" -> P.Right E'State2'FAILED
  s -> P.Left $ "toE'State2: enum parse failure: " P.++ P.show s

-- ** E'State3

{- | Enum of 'Text' .
Output only. The state of the tuned model.
-}
data E'State3
  = -- | @"STATE_UNSPECIFIED"@
    E'State3'STATE_UNSPECIFIED
  | -- | @"CREATING"@
    E'State3'CREATING
  | -- | @"ACTIVE"@
    E'State3'ACTIVE
  | -- | @"FAILED"@
    E'State3'FAILED
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State3 where toJSON = A.toJSON . fromE'State3
instance A.FromJSON E'State3 where parseJSON o = P.either P.fail (pure . P.id) . toE'State3 =<< A.parseJSON o
instance WH.ToHttpApiData E'State3 where toQueryParam = WH.toQueryParam . fromE'State3
instance WH.FromHttpApiData E'State3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State3
instance MimeRender MimeMultipartFormData E'State3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State3' enum
fromE'State3 :: E'State3 -> Text
fromE'State3 = \case
  E'State3'STATE_UNSPECIFIED -> "STATE_UNSPECIFIED"
  E'State3'CREATING -> "CREATING"
  E'State3'ACTIVE -> "ACTIVE"
  E'State3'FAILED -> "FAILED"

-- | parse 'E'State3' enum
toE'State3 :: Text -> P.Either String E'State3
toE'State3 = \case
  "STATE_UNSPECIFIED" -> P.Right E'State3'STATE_UNSPECIFIED
  "CREATING" -> P.Right E'State3'CREATING
  "ACTIVE" -> P.Right E'State3'ACTIVE
  "FAILED" -> P.Right E'State3'FAILED
  s -> P.Left $ "toE'State3: enum parse failure: " P.++ P.show s

-- ** E'State4

{- | Enum of 'Text' .
Output only. Current state of the `Chunk`.
-}
data E'State4
  = -- | @"STATE_UNSPECIFIED"@
    E'State4'UNSPECIFIED
  | -- | @"STATE_PENDING_PROCESSING"@
    E'State4'PENDING_PROCESSING
  | -- | @"STATE_ACTIVE"@
    E'State4'ACTIVE
  | -- | @"STATE_FAILED"@
    E'State4'FAILED
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State4 where toJSON = A.toJSON . fromE'State4
instance A.FromJSON E'State4 where parseJSON o = P.either P.fail (pure . P.id) . toE'State4 =<< A.parseJSON o
instance WH.ToHttpApiData E'State4 where toQueryParam = WH.toQueryParam . fromE'State4
instance WH.FromHttpApiData E'State4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State4
instance MimeRender MimeMultipartFormData E'State4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State4' enum
fromE'State4 :: E'State4 -> Text
fromE'State4 = \case
  E'State4'UNSPECIFIED -> "STATE_UNSPECIFIED"
  E'State4'PENDING_PROCESSING -> "STATE_PENDING_PROCESSING"
  E'State4'ACTIVE -> "STATE_ACTIVE"
  E'State4'FAILED -> "STATE_FAILED"

-- | parse 'E'State4' enum
toE'State4 :: Text -> P.Either String E'State4
toE'State4 = \case
  "STATE_UNSPECIFIED" -> P.Right E'State4'UNSPECIFIED
  "STATE_PENDING_PROCESSING" -> P.Right E'State4'PENDING_PROCESSING
  "STATE_ACTIVE" -> P.Right E'State4'ACTIVE
  "STATE_FAILED" -> P.Right E'State4'FAILED
  s -> P.Left $ "toE'State4: enum parse failure: " P.++ P.show s

-- ** E'Threshold

{- | Enum of 'Text' .
Required. Controls the probability threshold at which harm is blocked.
-}
data E'Threshold
  = -- | @"HARM_BLOCK_THRESHOLD_UNSPECIFIED"@
    E'Threshold'HARM_BLOCK_THRESHOLD_UNSPECIFIED
  | -- | @"BLOCK_LOW_AND_ABOVE"@
    E'Threshold'BLOCK_LOW_AND_ABOVE
  | -- | @"BLOCK_MEDIUM_AND_ABOVE"@
    E'Threshold'BLOCK_MEDIUM_AND_ABOVE
  | -- | @"BLOCK_ONLY_HIGH"@
    E'Threshold'BLOCK_ONLY_HIGH
  | -- | @"BLOCK_NONE"@
    E'Threshold'BLOCK_NONE
  | -- | @"OFF"@
    E'Threshold'OFF
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Threshold where toJSON = A.toJSON . fromE'Threshold
instance A.FromJSON E'Threshold where parseJSON o = P.either P.fail (pure . P.id) . toE'Threshold =<< A.parseJSON o
instance WH.ToHttpApiData E'Threshold where toQueryParam = WH.toQueryParam . fromE'Threshold
instance WH.FromHttpApiData E'Threshold where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Threshold
instance MimeRender MimeMultipartFormData E'Threshold where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Threshold' enum
fromE'Threshold :: E'Threshold -> Text
fromE'Threshold = \case
  E'Threshold'HARM_BLOCK_THRESHOLD_UNSPECIFIED -> "HARM_BLOCK_THRESHOLD_UNSPECIFIED"
  E'Threshold'BLOCK_LOW_AND_ABOVE -> "BLOCK_LOW_AND_ABOVE"
  E'Threshold'BLOCK_MEDIUM_AND_ABOVE -> "BLOCK_MEDIUM_AND_ABOVE"
  E'Threshold'BLOCK_ONLY_HIGH -> "BLOCK_ONLY_HIGH"
  E'Threshold'BLOCK_NONE -> "BLOCK_NONE"
  E'Threshold'OFF -> "OFF"

-- | parse 'E'Threshold' enum
toE'Threshold :: Text -> P.Either String E'Threshold
toE'Threshold = \case
  "HARM_BLOCK_THRESHOLD_UNSPECIFIED" -> P.Right E'Threshold'HARM_BLOCK_THRESHOLD_UNSPECIFIED
  "BLOCK_LOW_AND_ABOVE" -> P.Right E'Threshold'BLOCK_LOW_AND_ABOVE
  "BLOCK_MEDIUM_AND_ABOVE" -> P.Right E'Threshold'BLOCK_MEDIUM_AND_ABOVE
  "BLOCK_ONLY_HIGH" -> P.Right E'Threshold'BLOCK_ONLY_HIGH
  "BLOCK_NONE" -> P.Right E'Threshold'BLOCK_NONE
  "OFF" -> P.Right E'Threshold'OFF
  s -> P.Left $ "toE'Threshold: enum parse failure: " P.++ P.show s

-- ** E'UrlRetrievalStatus

{- | Enum of 'Text' .
Status of the url retrieval.
-}
data E'UrlRetrievalStatus
  = -- | @"URL_RETRIEVAL_STATUS_UNSPECIFIED"@
    E'UrlRetrievalStatus'UNSPECIFIED
  | -- | @"URL_RETRIEVAL_STATUS_SUCCESS"@
    E'UrlRetrievalStatus'SUCCESS
  | -- | @"URL_RETRIEVAL_STATUS_ERROR"@
    E'UrlRetrievalStatus'ERROR
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'UrlRetrievalStatus where toJSON = A.toJSON . fromE'UrlRetrievalStatus
instance A.FromJSON E'UrlRetrievalStatus where parseJSON o = P.either P.fail (pure . P.id) . toE'UrlRetrievalStatus =<< A.parseJSON o
instance WH.ToHttpApiData E'UrlRetrievalStatus where toQueryParam = WH.toQueryParam . fromE'UrlRetrievalStatus
instance WH.FromHttpApiData E'UrlRetrievalStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'UrlRetrievalStatus
instance MimeRender MimeMultipartFormData E'UrlRetrievalStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'UrlRetrievalStatus' enum
fromE'UrlRetrievalStatus :: E'UrlRetrievalStatus -> Text
fromE'UrlRetrievalStatus = \case
  E'UrlRetrievalStatus'UNSPECIFIED -> "URL_RETRIEVAL_STATUS_UNSPECIFIED"
  E'UrlRetrievalStatus'SUCCESS -> "URL_RETRIEVAL_STATUS_SUCCESS"
  E'UrlRetrievalStatus'ERROR -> "URL_RETRIEVAL_STATUS_ERROR"

-- | parse 'E'UrlRetrievalStatus' enum
toE'UrlRetrievalStatus :: Text -> P.Either String E'UrlRetrievalStatus
toE'UrlRetrievalStatus = \case
  "URL_RETRIEVAL_STATUS_UNSPECIFIED" -> P.Right E'UrlRetrievalStatus'UNSPECIFIED
  "URL_RETRIEVAL_STATUS_SUCCESS" -> P.Right E'UrlRetrievalStatus'SUCCESS
  "URL_RETRIEVAL_STATUS_ERROR" -> P.Right E'UrlRetrievalStatus'ERROR
  s -> P.Left $ "toE'UrlRetrievalStatus: enum parse failure: " P.++ P.show s

-- ** E'Xgafv

-- | Enum of 'Text'
data E'Xgafv
  = -- | @"1"@
    E'Xgafv'1
  | -- | @"2"@
    E'Xgafv'2
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Xgafv where toJSON = A.toJSON . fromE'Xgafv
instance A.FromJSON E'Xgafv where parseJSON o = P.either P.fail (pure . P.id) . toE'Xgafv =<< A.parseJSON o
instance WH.ToHttpApiData E'Xgafv where toQueryParam = WH.toQueryParam . fromE'Xgafv
instance WH.FromHttpApiData E'Xgafv where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Xgafv
instance MimeRender MimeMultipartFormData E'Xgafv where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Xgafv' enum
fromE'Xgafv :: E'Xgafv -> Text
fromE'Xgafv = \case
  E'Xgafv'1 -> "1"
  E'Xgafv'2 -> "2"

-- | parse 'E'Xgafv' enum
toE'Xgafv :: Text -> P.Either String E'Xgafv
toE'Xgafv = \case
  "1" -> P.Right E'Xgafv'1
  "2" -> P.Right E'Xgafv'2
  s -> P.Left $ "toE'Xgafv: enum parse failure: " P.++ P.show s

-- ** HarmCategory

-- | Enum of 'Text'
data HarmCategory
  = -- | @"HARM_CATEGORY_UNSPECIFIED"@
    HarmCategory'UNSPECIFIED
  | -- | @"HARM_CATEGORY_DEROGATORY"@
    HarmCategory'DEROGATORY
  | -- | @"HARM_CATEGORY_TOXICITY"@
    HarmCategory'TOXICITY
  | -- | @"HARM_CATEGORY_VIOLENCE"@
    HarmCategory'VIOLENCE
  | -- | @"HARM_CATEGORY_SEXUAL"@
    HarmCategory'SEXUAL
  | -- | @"HARM_CATEGORY_MEDICAL"@
    HarmCategory'MEDICAL
  | -- | @"HARM_CATEGORY_DANGEROUS"@
    HarmCategory'DANGEROUS
  | -- | @"HARM_CATEGORY_HARASSMENT"@
    HarmCategory'HARASSMENT
  | -- | @"HARM_CATEGORY_HATE_SPEECH"@
    HarmCategory'HATE_SPEECH
  | -- | @"HARM_CATEGORY_SEXUALLY_EXPLICIT"@
    HarmCategory'SEXUALLY_EXPLICIT
  | -- | @"HARM_CATEGORY_DANGEROUS_CONTENT"@
    HarmCategory'DANGEROUS_CONTENT
  | -- | @"HARM_CATEGORY_CIVIC_INTEGRITY"@
    HarmCategory'CIVIC_INTEGRITY
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON HarmCategory where toJSON = A.toJSON . fromHarmCategory
instance A.FromJSON HarmCategory where parseJSON o = P.either P.fail (pure . P.id) . toHarmCategory =<< A.parseJSON o
instance WH.ToHttpApiData HarmCategory where toQueryParam = WH.toQueryParam . fromHarmCategory
instance WH.FromHttpApiData HarmCategory where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toHarmCategory
instance MimeRender MimeMultipartFormData HarmCategory where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'HarmCategory' enum
fromHarmCategory :: HarmCategory -> Text
fromHarmCategory = \case
  HarmCategory'UNSPECIFIED -> "HARM_CATEGORY_UNSPECIFIED"
  HarmCategory'DEROGATORY -> "HARM_CATEGORY_DEROGATORY"
  HarmCategory'TOXICITY -> "HARM_CATEGORY_TOXICITY"
  HarmCategory'VIOLENCE -> "HARM_CATEGORY_VIOLENCE"
  HarmCategory'SEXUAL -> "HARM_CATEGORY_SEXUAL"
  HarmCategory'MEDICAL -> "HARM_CATEGORY_MEDICAL"
  HarmCategory'DANGEROUS -> "HARM_CATEGORY_DANGEROUS"
  HarmCategory'HARASSMENT -> "HARM_CATEGORY_HARASSMENT"
  HarmCategory'HATE_SPEECH -> "HARM_CATEGORY_HATE_SPEECH"
  HarmCategory'SEXUALLY_EXPLICIT -> "HARM_CATEGORY_SEXUALLY_EXPLICIT"
  HarmCategory'DANGEROUS_CONTENT -> "HARM_CATEGORY_DANGEROUS_CONTENT"
  HarmCategory'CIVIC_INTEGRITY -> "HARM_CATEGORY_CIVIC_INTEGRITY"

-- | parse 'HarmCategory' enum
toHarmCategory :: Text -> P.Either String HarmCategory
toHarmCategory = \case
  "HARM_CATEGORY_UNSPECIFIED" -> P.Right HarmCategory'UNSPECIFIED
  "HARM_CATEGORY_DEROGATORY" -> P.Right HarmCategory'DEROGATORY
  "HARM_CATEGORY_TOXICITY" -> P.Right HarmCategory'TOXICITY
  "HARM_CATEGORY_VIOLENCE" -> P.Right HarmCategory'VIOLENCE
  "HARM_CATEGORY_SEXUAL" -> P.Right HarmCategory'SEXUAL
  "HARM_CATEGORY_MEDICAL" -> P.Right HarmCategory'MEDICAL
  "HARM_CATEGORY_DANGEROUS" -> P.Right HarmCategory'DANGEROUS
  "HARM_CATEGORY_HARASSMENT" -> P.Right HarmCategory'HARASSMENT
  "HARM_CATEGORY_HATE_SPEECH" -> P.Right HarmCategory'HATE_SPEECH
  "HARM_CATEGORY_SEXUALLY_EXPLICIT" -> P.Right HarmCategory'SEXUALLY_EXPLICIT
  "HARM_CATEGORY_DANGEROUS_CONTENT" -> P.Right HarmCategory'DANGEROUS_CONTENT
  "HARM_CATEGORY_CIVIC_INTEGRITY" -> P.Right HarmCategory'CIVIC_INTEGRITY
  s -> P.Left $ "toHarmCategory: enum parse failure: " P.++ P.show s

-- ** Modality

-- | Enum of 'Text'
data Modality
  = -- | @"MODALITY_UNSPECIFIED"@
    Modality'MODALITY_UNSPECIFIED
  | -- | @"TEXT"@
    Modality'TEXT
  | -- | @"IMAGE"@
    Modality'IMAGE
  | -- | @"VIDEO"@
    Modality'VIDEO
  | -- | @"AUDIO"@
    Modality'AUDIO
  | -- | @"DOCUMENT"@
    Modality'DOCUMENT
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON Modality where toJSON = A.toJSON . fromModality
instance A.FromJSON Modality where parseJSON o = P.either P.fail (pure . P.id) . toModality =<< A.parseJSON o
instance WH.ToHttpApiData Modality where toQueryParam = WH.toQueryParam . fromModality
instance WH.FromHttpApiData Modality where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toModality
instance MimeRender MimeMultipartFormData Modality where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'Modality' enum
fromModality :: Modality -> Text
fromModality = \case
  Modality'MODALITY_UNSPECIFIED -> "MODALITY_UNSPECIFIED"
  Modality'TEXT -> "TEXT"
  Modality'IMAGE -> "IMAGE"
  Modality'VIDEO -> "VIDEO"
  Modality'AUDIO -> "AUDIO"
  Modality'DOCUMENT -> "DOCUMENT"

-- | parse 'Modality' enum
toModality :: Text -> P.Either String Modality
toModality = \case
  "MODALITY_UNSPECIFIED" -> P.Right Modality'MODALITY_UNSPECIFIED
  "TEXT" -> P.Right Modality'TEXT
  "IMAGE" -> P.Right Modality'IMAGE
  "VIDEO" -> P.Right Modality'VIDEO
  "AUDIO" -> P.Right Modality'AUDIO
  "DOCUMENT" -> P.Right Modality'DOCUMENT
  s -> P.Left $ "toModality: enum parse failure: " P.++ P.show s

-- ** ModelType

-- | Enum of 'Text'
data ModelType
  = -- | @"TYPE_UNSPECIFIED"@
    ModelType'TYPE_UNSPECIFIED
  | -- | @"STRING"@
    ModelType'STRING
  | -- | @"NUMBER"@
    ModelType'NUMBER
  | -- | @"INTEGER"@
    ModelType'INTEGER
  | -- | @"BOOLEAN"@
    ModelType'BOOLEAN
  | -- | @"ARRAY"@
    ModelType'ARRAY
  | -- | @"OBJECT"@
    ModelType'OBJECT
  | -- | @"NULL"@
    ModelType'NULL
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ModelType where toJSON = A.toJSON . fromModelType
instance A.FromJSON ModelType where parseJSON o = P.either P.fail (pure . P.id) . toModelType =<< A.parseJSON o
instance WH.ToHttpApiData ModelType where toQueryParam = WH.toQueryParam . fromModelType
instance WH.FromHttpApiData ModelType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toModelType
instance MimeRender MimeMultipartFormData ModelType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ModelType' enum
fromModelType :: ModelType -> Text
fromModelType = \case
  ModelType'TYPE_UNSPECIFIED -> "TYPE_UNSPECIFIED"
  ModelType'STRING -> "STRING"
  ModelType'NUMBER -> "NUMBER"
  ModelType'INTEGER -> "INTEGER"
  ModelType'BOOLEAN -> "BOOLEAN"
  ModelType'ARRAY -> "ARRAY"
  ModelType'OBJECT -> "OBJECT"
  ModelType'NULL -> "NULL"

-- | parse 'ModelType' enum
toModelType :: Text -> P.Either String ModelType
toModelType = \case
  "TYPE_UNSPECIFIED" -> P.Right ModelType'TYPE_UNSPECIFIED
  "STRING" -> P.Right ModelType'STRING
  "NUMBER" -> P.Right ModelType'NUMBER
  "INTEGER" -> P.Right ModelType'INTEGER
  "BOOLEAN" -> P.Right ModelType'BOOLEAN
  "ARRAY" -> P.Right ModelType'ARRAY
  "OBJECT" -> P.Right ModelType'OBJECT
  "NULL" -> P.Right ModelType'NULL
  s -> P.Left $ "toModelType: enum parse failure: " P.++ P.show s

-- ** TaskType

-- | Enum of 'Text'
data TaskType
  = -- | @"TASK_TYPE_UNSPECIFIED"@
    TaskType'TASK_TYPE_UNSPECIFIED
  | -- | @"RETRIEVAL_QUERY"@
    TaskType'RETRIEVAL_QUERY
  | -- | @"RETRIEVAL_DOCUMENT"@
    TaskType'RETRIEVAL_DOCUMENT
  | -- | @"SEMANTIC_SIMILARITY"@
    TaskType'SEMANTIC_SIMILARITY
  | -- | @"CLASSIFICATION"@
    TaskType'CLASSIFICATION
  | -- | @"CLUSTERING"@
    TaskType'CLUSTERING
  | -- | @"QUESTION_ANSWERING"@
    TaskType'QUESTION_ANSWERING
  | -- | @"FACT_VERIFICATION"@
    TaskType'FACT_VERIFICATION
  | -- | @"CODE_RETRIEVAL_QUERY"@
    TaskType'CODE_RETRIEVAL_QUERY
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TaskType where toJSON = A.toJSON . fromTaskType
instance A.FromJSON TaskType where parseJSON o = P.either P.fail (pure . P.id) . toTaskType =<< A.parseJSON o
instance WH.ToHttpApiData TaskType where toQueryParam = WH.toQueryParam . fromTaskType
instance WH.FromHttpApiData TaskType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTaskType
instance MimeRender MimeMultipartFormData TaskType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TaskType' enum
fromTaskType :: TaskType -> Text
fromTaskType = \case
  TaskType'TASK_TYPE_UNSPECIFIED -> "TASK_TYPE_UNSPECIFIED"
  TaskType'RETRIEVAL_QUERY -> "RETRIEVAL_QUERY"
  TaskType'RETRIEVAL_DOCUMENT -> "RETRIEVAL_DOCUMENT"
  TaskType'SEMANTIC_SIMILARITY -> "SEMANTIC_SIMILARITY"
  TaskType'CLASSIFICATION -> "CLASSIFICATION"
  TaskType'CLUSTERING -> "CLUSTERING"
  TaskType'QUESTION_ANSWERING -> "QUESTION_ANSWERING"
  TaskType'FACT_VERIFICATION -> "FACT_VERIFICATION"
  TaskType'CODE_RETRIEVAL_QUERY -> "CODE_RETRIEVAL_QUERY"

-- | parse 'TaskType' enum
toTaskType :: Text -> P.Either String TaskType
toTaskType = \case
  "TASK_TYPE_UNSPECIFIED" -> P.Right TaskType'TASK_TYPE_UNSPECIFIED
  "RETRIEVAL_QUERY" -> P.Right TaskType'RETRIEVAL_QUERY
  "RETRIEVAL_DOCUMENT" -> P.Right TaskType'RETRIEVAL_DOCUMENT
  "SEMANTIC_SIMILARITY" -> P.Right TaskType'SEMANTIC_SIMILARITY
  "CLASSIFICATION" -> P.Right TaskType'CLASSIFICATION
  "CLUSTERING" -> P.Right TaskType'CLUSTERING
  "QUESTION_ANSWERING" -> P.Right TaskType'QUESTION_ANSWERING
  "FACT_VERIFICATION" -> P.Right TaskType'FACT_VERIFICATION
  "CODE_RETRIEVAL_QUERY" -> P.Right TaskType'CODE_RETRIEVAL_QUERY
  s -> P.Left $ "toTaskType: enum parse failure: " P.++ P.show s
